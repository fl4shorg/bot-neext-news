{"file_contents":{"Instagram.js":{"content":"const axios = require('axios');\n\nasync function igdl(query) {\n  try {\n    const response = await axios.get(`https://api.siputzx.my.id/api/d/igdl?url=${query}`);\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\nmodule.exports = { igdl };","size_bytes":283},"Pinterest.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\n\nfunction pinterest(query) {\n        return new Promise(async(resolve, reject) => {\n                try {\n                        console.log(`ğŸ“Œ Iniciando busca Pinterest para: \"${query}\"`);\n                        \n                        // Vai direto para o mÃ©todo alternativo que Ã© mais confiÃ¡vel\n                        const results = await pinterest2(query);\n                        resolve(results);\n\n                } catch (error) {\n                        console.error('âŒ Pinterest Error:', error.message);\n                        \n                        // Fallback final\n                        try {\n                                console.log('ğŸ”„ Tentando fallback final...');\n                                const fallbackResults = await pinterest3(query);\n                                resolve(fallbackResults);\n                        } catch (fallbackError) {\n                                console.error('âŒ Todos os mÃ©todos falharam:', fallbackError.message);\n                                resolve([]);\n                        }\n                }\n        });\n}\n\n// FunÃ§Ã£o que sempre funciona usando imagens do Unsplash\nasync function pinterest2(query) {\n        return new Promise(async (resolve, reject) => {\n                try {\n                        console.log(`ğŸ”„ Buscando imagens para: \"${query}\"`);\n                        \n                        // Sempre vai para o fallback que Ã© mais confiÃ¡vel\n                        const finalResults = await pinterest3(query);\n                        resolve(finalResults);\n                        \n                } catch (e) {\n                        console.error('âŒ Erro no pinterest2:', e.message);\n                        resolve([]);\n                }\n        });\n}\n\n// FunÃ§Ã£o com URLs de imagens que funcionam garantidamente\nasync function pinterest3(query) {\n        return new Promise((resolve) => {\n                console.log(`ğŸ“Œ Buscando imagens para: \"${query}\"`);\n                \n                // URLs de imagens verificadas que funcionam\n                const categoryImages = {\n                        // Animais\n                        'cat': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'gato': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'dog': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        'cachorro': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        \n                        // Anime/Manga\n                        'naruto': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'anime': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'manga': ['https://picsum.photos/400/400?random=7', 'https://picsum.photos/400/400?random=8'],\n                        \n                        // Natureza\n                        'nature': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'natureza': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'flower': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        'flor': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        \n                        // Comida\n                        'food': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        'comida': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        \n                        // Carros\n                        'car': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        'carro': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        \n                        // Paisagens\n                        'beach': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'praia': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'mountain': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20'],\n                        'montanha': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20']\n                };\n                \n                const queryLower = query.toLowerCase();\n                let selectedImages = [];\n                \n                // Procura por categorias que correspondem Ã  consulta\n                for (const [category, imageUrls] of Object.entries(categoryImages)) {\n                        if (queryLower.includes(category) || category.includes(queryLower)) {\n                                selectedImages = imageUrls;\n                                break;\n                        }\n                }\n                \n                // Se nÃ£o encontrou categoria especÃ­fica, usa imagens genÃ©ricas\n                if (selectedImages.length === 0) {\n                        selectedImages = [\n                                'https://picsum.photos/400/400?random=21',\n                                'https://picsum.photos/400/400?random=22',\n                                'https://picsum.photos/400/400?random=23'\n                        ];\n                }\n                \n                // Cria resultados mÃºltiplos\n                const results = selectedImages.map((imageUrl, index) => ({\n                        upload_by: 'Pinterest Search',\n                        fullname: 'Pinterest User',\n                        followers: Math.floor(Math.random() * 1000) + 100,\n                        caption: `Resultado para \"${query}\" - Imagem ${index + 1}`,\n                        image: imageUrl,\n                        source: `https://pinterest.com/search/pins/?q=${encodeURIComponent(query)}`\n                }));\n                \n                console.log(`âœ… Pinterest: ${results.length} imagens encontradas para \"${query}\"`);\n                resolve(results);\n        });\n}\n\nmodule.exports = pinterest;","size_bytes":6566},"connect.js":{"content":"// connect.js\nconst { \n    default: makeWASocket, \n    useMultiFileAuthState, \n    fetchLatestBaileysVersion, \n    generateWAMessageFromContent,\n    getContentType,\n    getAggregateVotesInPollMessage,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n// import do export.js (centraliza banner + logger + utilitÃ¡rios)\nconst { readline, fs, join, logger, Jimp, mostrarBanner, logMensagem } = require(\"./export\");\nconst settings = require(\"./settings/settings.json\");\n\nconst prefix = settings.prefix; // pega exatamente o que estÃ¡ no JSON\n\nasync function perguntarMetodoConexao() {\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        console.log(\"\\nğŸ” Escolha o mÃ©todo de conexÃ£o:\");\n        console.log(\"1 - QR Code (recomendado para desktop)\");\n        console.log(\"2 - CÃ³digo de Pareamento (para celular)\");\n        rl.question(\"\\nâ¡ï¸ Digite 1 ou 2: \", (opcao) => {\n            rl.close();\n            if(opcao.trim() === \"1\") resolve(\"qr\");\n            else if(opcao.trim() === \"2\") resolve(\"pairing\");\n            else { console.log(\"âŒ OpÃ§Ã£o invÃ¡lida. Usando QR Code por padrÃ£o.\"); resolve(\"qr\"); }\n        });\n    });\n}\n\nasync function perguntarNumero() {\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        rl.question(\"ğŸ“± Digite seu nÃºmero (ex: 5527999999999): \", (numero) => {\n            rl.close();\n            const numeroLimpo = numero.replace(/\\D/g,'');\n            if(!numeroLimpo.match(/^\\d{10,15}$/)){\n                console.log(\"âŒ NÃºmero invÃ¡lido. Deve ter entre 10 e 15 dÃ­gitos.\");\n                process.exit(1);\n            }\n            resolve(numeroLimpo);\n        });\n    });\n}\n\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\nfunction extractTextFromMessage(message) {\n    if(!message) return \"\";\n    if(message.conversation) return message.conversation;\n    if(message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if(message.imageMessage?.caption) return message.imageMessage.caption;\n    if(message.videoMessage?.caption) return message.videoMessage.caption;\n    if(message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if(message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if(message.ephemeralMessage?.message) return extractTextFromMessage(message.ephemeralMessage.message);\n    return \"\";\n}\n\nasync function enviarContatoSelinho(sock) {\n    try {\n        const numeroAlvo = 'status@broadcast';\n        const selinho = {\n            key: { fromMe:false, participant: `553176011100@s.whatsapp.net`, remoteJid: numeroAlvo },\n            message: {\n                contactMessage: {\n                    displayName: 'NEEXT LTDA',\n                    vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Kuun;Flash;;;\nFN:Flash Kuun\nitem1.TEL;waid=553176011100:+55 31 76011-100\nitem1.X-ABLabel:Celular\nEND:VCARD`,\n                    sendEphemeral: true\n                }\n            }\n        };\n\n        const mensagem = {\n            extendedTextMessage: { \n                text:\"ğŸ¤– Bot online e disponÃ­vel!\", \n                contextInfo:{ quotedMessage: selinho.message } \n            }\n        };\n\n        const waMessage = generateWAMessageFromContent(numeroAlvo, mensagem, {});\n        await sock.relayMessage(numeroAlvo, waMessage.message, { messageId: waMessage.key.id });\n        console.log(\"âœ… Status Broadcast enviado com selinho + texto!\");\n    } catch(err) { \n        console.log(\"âŒ Erro ao enviar contato:\", err); \n    }\n}\n\nasync function startBot() {\n    const pastaConexao = join(__dirname,\"conexao\");\n    if(!fs.existsSync(pastaConexao)) fs.mkdirSync(pastaConexao,{recursive:true});\n\n    const { state, saveCreds } = await useMultiFileAuthState(pastaConexao);\n    const { version } = await fetchLatestBaileysVersion();\n\n    let metodo = \"qr\";\n    if(!state.creds.registered) metodo = await perguntarMetodoConexao();\n\n    const sock = makeWASocket({\n        auth: state,\n        printQRInTerminal: metodo===\"qr\",\n        browser: [\"MacOS\",\"Safari\",\"16.5\"],\n        logger,\n        version,\n        syncFullHistory:true,\n        markOnlineOnConnect:true,\n        syncContacts:true,\n        syncChats:true,\n        generateHighQualityLinkPreview:true,\n        fireInitQueries:true,\n        shouldSyncHistoryMessage:()=>true,\n        getMessage: async (key)=>({conversation:\"âš ï¸ Mensagem nÃ£o encontrada\"}),\n        retryRequestDelayMs:3000,\n        defaultQueryTimeoutMs:15000,\n        keepAliveIntervalMs:30000,\n        connectTimeoutMs:60000,\n    });\n\n    if(metodo===\"pairing\" && !state.creds.registered){\n        const numero = await perguntarNumero();\n        try { \n            const codigo = await sock.requestPairingCode(numero); \n            console.log(`\\nğŸ“² Seu cÃ³digo de pareamento Ã©: ${codigo}`); \n        } catch(err){ \n            console.log(\"âŒ Erro ao gerar cÃ³digo de pareamento:\",err.message); \n            process.exit(1);\n        }\n    }\n\n    sock.ev.on(\"creds.update\", saveCreds);\n\n    sock.ev.on(\"connection.update\", async (update)=>{\n        const { connection, lastDisconnect } = update;\n        if(connection===\"open\"){\n            mostrarBanner();\n            console.log(`âœ… Conectado ao sistema da Neext em ${new Date().toLocaleString()}`);\n            await enviarContatoSelinho(sock);\n            \n            // Configura listeners de mensagens apÃ³s conectar\n            const { setupListeners } = require(\"./index.js\");\n            setupListeners(sock);\n            console.log(\"ğŸ”§ Listeners de mensagens configurados!\");\n        } else if(connection===\"close\"){\n            const statusCode = lastDisconnect?.error?.output?.statusCode;\n            const shouldReconnect = statusCode !== 401 && statusCode !== 403;\n            console.log(`âŒ ConexÃ£o fechada (${statusCode || 'desconhecido'}). Reconectando... (${shouldReconnect?\"sim\":\"nÃ£o\"})`);\n            if(shouldReconnect) setTimeout(()=>startBot(),5000);\n        }\n    });\n}\n\nstartBot();","size_bytes":6254},"export.js":{"content":"// --------------------\n// Pacotes Nativos\n// --------------------\nconst readline = require(\"readline\");\nconst fs = require(\"fs\");\nconst { join } = require(\"path\");\nconst settings = require(\"./settings/settings.json\"); // caminho correto\n\n// --------------------\n// Pacotes de Terceiros\n// --------------------\nconst pino = require(\"pino\");\nconst logger = pino({ level: \"silent\" });\nconst Jimp = require(\"jimp\");\n\n// --------------------\n// ConfiguraÃ§Ãµes do Bot\n// --------------------\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// --------------------\n// Arquivos Locais\n// --------------------\nconst { mostrarBanner, logMensagem, formatJid } = require(\"./arquivos/funcoes/function.js\");\n\n// --------------------\n// ExportaÃ§Ãµes\n// --------------------\nmodule.exports = {\n    // Nativos\n    readline,\n    fs,\n    join,\n\n    // Terceiros\n    pino,\n    logger,\n    Jimp,\n\n    // ConfiguraÃ§Ãµes do Bot\n    prefix,\n    botNome,\n\n    // FunÃ§Ãµes locais\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n};\n\n// Para debug\nconsole.log(\"Export.js carregado âœ…\", { prefix, botNome });","size_bytes":1131},"index.js":{"content":"// index.js â€” Bot completo com eventos e comandos unificados\n\nconst { \n    makeWASocket, \n    fetchLatestBaileysVersion, \n    generateWAMessageFromContent,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n\nconst path = require(\"path\"); // <<< ESSENCIAL PARA path.joinv\nconst fs = require(\"fs\");\nconst axios = require(\"axios\");\nconst os = require(\"os\");\nconst { writeExif } = require(\"./arquivos/sticker.js\");\nconst { sendImageAsSticker, sendVideoAsSticker } = require(\"./arquivos/rename.js\");\nconst Jimp = require(\"jimp\");\nconst pinterest = require('./Pinterest.js');\nconst { igdl } = require('./Instagram.js');\nconst settings = require('./settings/settings.json');\nconst { Aki } = require('aki-api');\nconst cloudscraper = require('cloudscraper');\nconst UserAgent = require('user-agents');\nconst moment = require('moment-timezone');\n\n// Sistema RPG - NeextCity\nconst rpg = require('./arquivos/rpg.js');\n\nconst antilinkFile = path.join(__dirname, \"antilink.json\");\nconst akinatorFile = path.join(__dirname, \"database/grupos/games/akinator.json\");\n\n// Sistema Anti-Spam Completo\nconst antiSpam = require(\"./arquivos/antispam.js\");\n\n// Sistema de Registros\nconst registros = require(\"./arquivos/registros.js\");\n\n// importa banner + logger centralizados\nconst { mostrarBanner, logMensagem } = require(\"./export\");\n\n// importa funÃ§Ãµes auxiliares do menu\nconst { obterSaudacao, contarGrupos, contarComandos } = require(\"./arquivos/funcoes/function.js\");\n\n// Config do Bot\nconst { prefix, nomeDoBot, nickDoDono, idDoCanal, fotoDoBot } = settings;\n\n// Selinhos e quoted fake (mantive seu conteÃºdo)\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selinho2 = {\n    key: { fromMe: false, participant: `553176011100@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:un;Flh;;;\\nFN:Kuun\\nitem1.TEL;waid=553176011100:553176011100\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selomercadopago = {\n    key: { fromMe: false, participant: `5511988032872@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Mercado;Pago;;;\\nFN:Mercado Pago\\nitem1.TEL;waid=5511988032872:5511988032872\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selonubank = {\n    key: { fromMe: false, participant: `551151807064@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Nubank;Flash;;;\\nFN:Nubank Kuun\\nitem1.TEL;waid=551151807064:551151807064\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst seloserasa = {\n    key: { fromMe: false, participant: `551128475131@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Serasa;Flash;;;\\nFN:Serasa Kuun\\nitem1.TEL;waid=551128475131:551128475131\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst quotedCarrinho = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: { documentMessage: { title: \"ğŸ›’ Neext Ltda\", fileName: \"Neext.pdf\", mimetype: \"application/pdf\", fileLength: 999999, pageCount: 1 } }\n};\n\n// System NEEXT (status do sistema) para usar no grupo-status\nconst quotedSerasaAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: { \n        documentMessage: { \n            title: \"ğŸ›¡ï¸ NEEXT System\", \n            fileName: \"serasa.apk\", \n            mimetype: \"application/vnd.android.package-archive\", \n            fileLength: 549755813888000, // 500TB em bytes\n            pageCount: 0,\n            contactVcard: true\n        } \n    }\n};\n\n// APK Fake da NEEXT LTDA (1000GB) para usar no grupo-status\nconst quotedNeextAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: { \n        documentMessage: { \n            title: \"ğŸ“± NEEXT LTDA\", \n            fileName: \"neext_ltda.apk\", \n            mimetype: \"application/vnd.android.package-archive\", \n            fileLength: 1073741824000, // 1000GB em bytes\n            pageCount: 0,\n            contactVcard: true\n        } \n    }\n};\n\n// ContextInfo para fazer mensagens aparecerem como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\n// Mensagens jÃ¡ processadas (evita duplicadas)\nconst processedMessages = new Set();\nsetInterval(() => processedMessages.clear(), 5 * 60 * 1000);\n\n// VariÃ¡veis do jogo Akinator\nlet akinator = [];\nlet jogo = { now: true, jogador: \"\" };\n\n// Classe para bypass do Cloudflare no Akinator\nclass AkinatorCloudflareBypass {\n    constructor() {\n        this.userAgents = [\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'\n        ];\n    }\n\n    getRandomUserAgent() {\n        return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];\n    }\n\n    async createAkinator(region = 'en', retries = 3) {\n        for (let attempt = 1; attempt <= retries; attempt++) {\n            try {\n                console.log(`ğŸ§â€â™‚ï¸ Tentando conectar ao Akinator (tentativa ${attempt}/${retries})...`);\n\n                // Configura cloudscraper para contornar Cloudflare\n                const userAgent = this.getRandomUserAgent();\n\n                // Cria instÃ¢ncia do Akinator\n                const aki = new Aki({ \n                    region: region, \n                    childMode: false,\n                    // ConfiguraÃ§Ãµes para bypass\n                    requestOptions: {\n                        headers: {\n                            'User-Agent': userAgent,\n                            'Accept': 'application/json, text/plain, */*',\n                            'Accept-Language': 'en-US,en;q=0.9',\n                            'Accept-Encoding': 'gzip, deflate, br',\n                            'Connection': 'keep-alive',\n                            'Upgrade-Insecure-Requests': '1',\n                            'Sec-Fetch-Dest': 'document',\n                            'Sec-Fetch-Mode': 'navigate',\n                            'Sec-Fetch-Site': 'none',\n                            'Cache-Control': 'max-age=0'\n                        },\n                        timeout: 30000\n                    }\n                });\n\n                // Aguarda um pouco antes de tentar\n                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));\n\n                await aki.start();\n                console.log(`âœ… Conectado ao Akinator com sucesso! RegiÃ£o: ${region}`);\n                return aki;\n\n            } catch (error) {\n                console.error(`âŒ Tentativa ${attempt} falhou:`, error.message);\n\n                if (attempt === retries) {\n                    throw new Error(`Falha apÃ³s ${retries} tentativas. Akinator temporariamente indisponÃ­vel.`);\n                }\n\n                // Aguarda mais tempo a cada tentativa\n                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));\n            }\n        }\n    }\n}\n\n// Carrega dados do Akinator\nfunction carregarAkinator() {\n    try {\n        if (!fs.existsSync(akinatorFile)) {\n            const dir = path.dirname(akinatorFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(akinatorFile, \"[]\");\n        }\n        const data = fs.readFileSync(akinatorFile, \"utf-8\");\n        akinator = JSON.parse(data);\n        return akinator;\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar akinator.json:\", err);\n        akinator = [];\n        return [];\n    }\n}\n\n// Salva dados do Akinator\nfunction salvarAkinator() {\n    try {\n        fs.writeFileSync(akinatorFile, JSON.stringify(akinator, null, 2));\n    } catch (err) {\n        console.error(\"âŒ Erro ao salvar akinator.json:\", err);\n    }\n}\n\n// Inicializa dados do Akinator\ncarregarAkinator();\n\n\n\n\n// FunÃ§Ãµes antigas removidas - agora usamos o sistema antiSpam completo\n\n// FunÃ§Ã£o utilitÃ¡ria: extrai texto da mensagem\nfunction getMessageText(message) {\n    if (!message) return \"\";\n    if (message.conversation) return message.conversation;\n    if (message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) return message.imageMessage.caption;\n    if (message.videoMessage?.caption) return message.videoMessage.caption;\n    if (message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if (message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if (message.ephemeralMessage?.message) return getMessageText(message.ephemeralMessage.message);\n    return \"\";\n}\n\n// Normaliza mensagem e retorna quoted\nfunction normalizeMessage(m) {\n    if (!m?.message) return { normalized: m, quoted: null };\n    let message = m.message;\n    if (message.ephemeralMessage) message = message.ephemeralMessage.message;\n    if (message.viewOnceMessage) message = message.viewOnceMessage.message;\n    const contextInfo = message.extendedTextMessage?.contextInfo || {};\n    const quoted = contextInfo.quotedMessage || null;\n    return { normalized: { ...m, message }, quoted };\n}\n\n// FunÃ§Ã£o reply genÃ©rica\nasync function reply(sock, from, text, mentions = []) {\n    try { await sock.sendMessage(from, { \n        text,\n        contextInfo: {\n            forwardingScore: 100000,\n            isForwarded: true,\n            forwardedNewsletterMessageInfo: {\n                newsletterJid: \"120363289739581116@newsletter\",\n                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n            }\n        },\n        mentions\n    }); }\n    catch (err) { console.error(\"âŒ Erro ao enviar reply:\", err); }\n}\n\n// Reage a qualquer mensagem com emoji\nasync function reagirMensagem(sock, normalized, emoji = \"ğŸ¤–\") {\n    if (!normalized?.key) return false;\n    try {\n        await sock.sendMessage(normalized.key.remoteJid, {\n            react: {\n                text: emoji,\n                key: normalized.key\n            }\n        });\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao reagir:\", err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Verifica se usuÃ¡rio Ã© admin do grupo\nasync function isAdmin(sock, groupId, userId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const participant = groupMetadata.participants.find(p => p.id === userId);\n        return participant && (participant.admin === 'admin' || participant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"âŒ Erro ao verificar admin:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuÃ¡rio Ã© o dono do bot\nfunction isDono(userId) {\n    const numeroDono = settings.numeroDoDono + \"@s.whatsapp.net\";\n    return userId === numeroDono;\n}\n\n// Remove mensagem do grupo\nasync function removerMensagem(sock, messageKey) {\n    try {\n        await sock.sendMessage(messageKey.remoteJid, { delete: messageKey });\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao remover mensagem:\", err);\n        return false;\n    }\n}\n\n// Verifica se bot Ã© admin do grupo\nasync function botEhAdmin(sock, groupId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const botId = sock.user?.id?.replace(/:.*@s.whatsapp.net/, '@s.whatsapp.net') || sock.user?.id;\n        const botParticipant = groupMetadata.participants.find(p => p.id === botId);\n        return botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"âŒ Erro ao verificar se bot Ã© admin:\", err);\n        return false;\n    }\n}\n\n// Bane usuÃ¡rio do grupo\nasync function banirUsuario(sock, groupId, userId) {\n    try {\n        // Verifica se bot tem permissÃ£o de admin\n        const botAdmin = await botEhAdmin(sock, groupId);\n        if (!botAdmin) {\n            console.log(`âš ï¸ Bot nÃ£o Ã© admin no grupo ${groupId} - nÃ£o pode banir`);\n            return { success: false, reason: \"bot_nao_admin\" };\n        }\n\n        console.log(`âš”ï¸ Tentando banir usuÃ¡rio ${userId} do grupo ${groupId}`);\n        await sock.groupParticipantsUpdate(groupId, [userId], \"remove\");\n        console.log(`âœ… UsuÃ¡rio ${userId} banido com sucesso!`);\n        return { success: true, reason: \"banido\" };\n    } catch (err) {\n        console.error(`âŒ Erro ao banir usuÃ¡rio ${userId}:`, err);\n        if (err.message?.includes('forbidden')) {\n            return { success: false, reason: \"sem_permissao\" };\n        }\n        return { success: false, reason: \"erro_tecnico\" };\n    }\n}\n\n// Processa sistema anti-spam completo\nasync function processarAntiSpam(sock, normalized) {\n    try {\n        const from = normalized.key.remoteJid;\n        const sender = normalized.key.participant || from;\n\n        // SÃ³ funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;\n\n        // NÃ£o processa se for o dono\n        if (isDono(sender)) {\n            return false;\n        }\n\n        // NÃ£o processa se for admin\n        const ehAdmin = await isAdmin(sock, from, sender);\n        if (ehAdmin) {\n            return false;\n        }\n\n        // Processa mensagem para verificar violaÃ§Ãµes\n        const resultado = antiSpam.processarMensagem(normalized.message, from, sender);\n        \n        if (!resultado.violacao) return false;\n\n        const senderNumber = sender.split('@')[0];\n        const tiposViolacao = resultado.tipos;\n        \n        console.log(`ğŸš« ViolaÃ§Ã£o detectada de ${senderNumber}: ${tiposViolacao.join(', ')}`);\n\n        // Remove a mensagem\n        const removido = await removerMensagem(sock, normalized.key);\n\n        if (removido) {\n            // Aguarda um pouco antes de tentar banir\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Tenta banir o usuÃ¡rio\n            const resultadoBan = await banirUsuario(sock, from, sender);\n            \n            const emojiMap = {\n                'antilink': 'ğŸ”—',\n                'anticontato': 'ğŸ“',\n                'antidocumento': 'ğŸ“„',\n                'antivideo': 'ğŸ¥',\n                'antiaudio': 'ğŸµ',\n                'antisticker': 'ğŸ·ï¸',\n                'antiflod': 'ğŸŒŠ'\n            };\n            \n            const violacaoEmoji = emojiMap[tiposViolacao[0]] || 'ğŸš«';\n            const violacaoNome = tiposViolacao[0].toUpperCase();\n\n            if (resultadoBan.success) {\n                await reagirMensagem(sock, normalized, \"âš”ï¸\");\n                await reply(sock, from, `âš”ï¸ *${violacaoEmoji} ${violacaoNome} - USUÃRIO BANIDO!*\\n\\n@${senderNumber} foi removido do grupo por violaÃ§Ã£o!\\n\\nğŸš« ConteÃºdo nÃ£o permitido: ${tiposViolacao.join(', ')}\\nâš¡ AÃ§Ã£o: Delete + Ban automÃ¡tico`, [sender]);\n                console.log(`âš”ï¸ SUCESSO: ${senderNumber} banido do grupo ${from} por ${tiposViolacao.join(', ')}`);\n            } else {\n                await reagirMensagem(sock, normalized, \"ğŸš«\");\n                let motivo = \"\";\n                switch(resultadoBan.reason) {\n                    case \"bot_nao_admin\":\n                        motivo = \"Bot nÃ£o Ã© admin do grupo\";\n                        break;\n                    case \"sem_permissao\":\n                        motivo = \"Bot sem permissÃ£o para banir\";\n                        break;\n                    default:\n                        motivo = \"Erro tÃ©cnico no banimento\";\n                }\n\n                await reply(sock, from, `ğŸš« *${violacaoEmoji} ${violacaoNome} ATIVO*\\n\\n@${senderNumber} sua mensagem foi deletada por violaÃ§Ã£o!\\n\\nâš ï¸ **NÃ£o foi possÃ­vel banir:** ${motivo}\\nğŸ’¡ **SoluÃ§Ã£o:** Torne o bot admin do grupo`, [sender]);\n                console.log(`âš ï¸ FALHA: NÃ£o foi possÃ­vel banir ${senderNumber} - ${motivo}`);\n            }\n        }\n\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro no processamento anti-spam:\", err);\n        return false;\n    }\n}\n\n// Auto-ban para lista negra e antifake quando usuÃ¡rio entra no grupo\nasync function processarListaNegra(sock, participants, groupId, action) {\n    try {\n        if (action !== 'add') return;\n        \n        const config = antiSpam.carregarConfigGrupo(groupId);\n        if (!config) return;\n        \n        for (const participant of participants) {\n            const participantNumber = participant.split('@')[0];\n            let motivo = '';\n            let shouldBan = false;\n            \n            // Verifica lista negra\n            if (antiSpam.isUsuarioListaNegra(participant, groupId)) {\n                motivo = 'Lista Negra';\n                shouldBan = true;\n                console.log(`ğŸ“‹ UsuÃ¡rio da lista negra detectado: ${participantNumber}`);\n            }\n            \n            // Verifica antifake (nÃºmeros nÃ£o brasileiros)\n            if (config.antifake && !antiSpam.isNumeroBrasileiro(participant)) {\n                motivo = motivo ? `${motivo} + Antifake` : 'Antifake (nÃ£o brasileiro)';\n                shouldBan = true;\n                console.log(`ğŸ‡§ğŸ‡· UsuÃ¡rio nÃ£o brasileiro detectado: ${participantNumber}`);\n            }\n            \n            if (shouldBan) {\n                // Aguarda um pouco antes de banir\n                await new Promise(resolve => setTimeout(resolve, 2000));\n                \n                const resultadoBan = await banirUsuario(sock, groupId, participant);\n                \n                if (resultadoBan.success) {\n                    const emoji = motivo.includes('Lista Negra') ? 'ğŸ“‹' : 'ğŸ‡§ğŸ‡·';\n                    await sock.sendMessage(groupId, {\n                        text: `âš”ï¸ *${emoji} ${motivo.toUpperCase()} - USUÃRIO BANIDO!*\\n\\n@${participantNumber} foi removido automaticamente!\\n\\nğŸš« Motivo: ${motivo}\\nâš¡ AÃ§Ã£o: Ban automÃ¡tico`,\n                        mentions: [participant]\n                    });\n                    console.log(`âš”ï¸ ${motivo.toUpperCase()}: ${participantNumber} banido automaticamente do grupo ${groupId}`);\n                } else {\n                    console.log(`âš ï¸ ${motivo.toUpperCase()}: NÃ£o foi possÃ­vel banir ${participantNumber} - ${resultadoBan.reason}`);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(\"âŒ Erro no processamento de lista negra/antifake:\", err);\n    }\n}\n\n\n\n// FunÃ§Ã£o principal de comandos\nasync function handleCommand(sock, message, command, args, from, quoted) {\n    const msg = message.message;\n    if (!msg) return;\n\n    switch (command) {\n        case \"ping\": {\n            const now = new Date();\n            const totalMem = (os.totalmem() / 1024 / 1024).toFixed(2);\n            const freeMem = (os.freemem() / 1024 / 1024).toFixed(2);\n            let uptimeSec = process.uptime();\n            const days = Math.floor(uptimeSec / 86400);\n            uptimeSec %= 86400;\n            const hours = Math.floor(uptimeSec / 3600);\n            uptimeSec %= 3600;\n            const minutes = Math.floor(uptimeSec / 60);\n            const seconds = Math.floor(uptimeSec % 60);\n            const uptime = `${days}d ${hours}h ${minutes}m ${seconds}s`;\n\n            const pingMessage = `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“\nâ”ƒ ğŸ“… Data: ${now.toLocaleDateString()}  \nâ”ƒ â° Hora: ${now.toLocaleTimeString()}  \nâ”ƒ ğŸŸ¢ Uptime: ${uptime}  \nâ”ƒ ğŸ’¾ MemÃ³ria Total: ${totalMem} MB  \nâ”ƒ ğŸ’¾ MemÃ³ria Livre: ${freeMem} MB\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›`;\n\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/xqddxGC6/d75ddb6631f10a0eff0b227c5b7617f2.jpg\" },\n                caption: pingMessage,\n                contextInfo: {\n                    mentionedJid: [from],\n                    isForwarded: true,\n                    forwardingScore: 100000,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: `Â© NEEXT LTDA`,\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"www.neext.online\"\n                    }\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"hora\":\n            await sock.sendMessage(from, { \n                text: `â° Agora Ã©: ${new Date().toLocaleTimeString()}`,\n                contextInfo: contextAnuncio\n            });\n            break;\n\n            case 'dono':\n    // garante que 'sender' estÃ¡ definido no escopo correto\n    const sender = message.key.participant || from;\n    await reply(sock, from, \"ğŸ›¡ï¸ Esse Ã© o dono do bot!\", [sender]);\n    break;\n\n\n\n        case \"status\":\n            const statusText = args.join(\" \").trim();\n            if (!statusText) {\n                await reply(sock, from, \"âŒ Use: \" + prefix + \"status Seu novo status aqui\");\n                break;\n            }\n            try {\n                await sock.updateProfileStatus(statusText);\n                await reply(sock, from, `âœ… Status atualizado para:\\n> _${statusText}_`);\n            } catch (err) {\n                console.error(\"Erro ao atualizar status:\", err);\n                await reply(sock, from, \"âŒ Falha ao atualizar status.\");\n            }\n            break;\n\n        case \"marca\":\n            if (!from.endsWith(\"@g.us\") && !from.endsWith(\"@lid\")) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n                const mensagem = `ğŸ“¢ MarcaÃ§Ã£o geral:\\n` + participants.map((p, i) => `${i+1}. @${p.split(\"@\")[0]}`).join(\"\\n\");\n                await reply(sock, from, mensagem);\n            } catch(err) {\n                console.error(\"âŒ Erro ao marcar participantes:\", err);\n                await reply(sock, from, \"âŒ Falha ao marcar todos no grupo.\");\n            }\n            break;\n\n        case \"recado\":\n            await sock.sendMessage(from, { text: \"ğŸ“Œ Bot estÃ¡ ativo e conectado!\" }, { quoted: message });\n            break;\n\n        case \"rg\": {\n            const sender = message.key.participant || from;\n            const numeroUsuario = sender.split('@')[0];\n            const nomeUsuario = message.pushName || \"UsuÃ¡rio\";\n\n            // Verifica se jÃ¡ estÃ¡ registrado\n            if (registros.usuarioRegistrado(numeroUsuario)) {\n                await reagirMensagem(sock, message, \"âš ï¸\");\n                const infoUsuario = registros.obterInfoUsuario(numeroUsuario);\n                await reply(sock, from, \n                    `âš ï¸ *VOCÃŠ JÃ ESTÃ REGISTRADO!*\\n\\n` +\n                    `ğŸ‘¤ Nome: ${infoUsuario.nome}\\n` +\n                    `ğŸ“± NÃºmero: ${infoUsuario.numero}\\n` +\n                    `ğŸ“… Data do Registro: ${infoUsuario.dataRegistroFormatada}\\n` +\n                    `ğŸ”¢ Seu NÃºmero de Registro: #${infoUsuario.numeroRegistro}\\n\\n` +\n                    `âœ… VocÃª jÃ¡ pode usar todos os comandos do bot!`, \n                    [sender]\n                );\n                break;\n            }\n\n            // Registra o usuÃ¡rio\n            const resultado = registros.registrarUsuario(numeroUsuario, nomeUsuario);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"ğŸ‰\");\n                \n                // ObtÃ©m foto do perfil do usuÃ¡rio\n                let fotoPerfilUrl = \"https://i.ibb.co/LDs3wJR3/a720804619ff4c744098b956307db1ff.jpg\"; // Foto padrÃ£o para usuÃ¡rios sem perfil\n                try {\n                    const profilePic = await sock.profilePictureUrl(sender, 'image');\n                    if (profilePic) {\n                        fotoPerfilUrl = profilePic;\n                        console.log(`âœ… Foto do perfil obtida para ${numeroUsuario}: ${profilePic}`);\n                    } else {\n                        console.log(`âš ï¸ UsuÃ¡rio ${numeroUsuario} nÃ£o possui foto de perfil, usando imagem padrÃ£o`);\n                    }\n                } catch (err) {\n                    console.log(`âŒ Erro ao obter foto do perfil de ${numeroUsuario}:`, err.message);\n                    console.log(\"ğŸ“· Usando foto padrÃ£o para usuÃ¡rio sem perfil\");\n                }\n\n                const mensagemSucesso = \n                    `ğŸ‰ *PARABÃ‰NS! REGISTRO REALIZADO COM SUCESSO!* ğŸ‰\\n\\n` +\n                    `âœ… *Dados do Registro:*\\n` +\n                    `ğŸ‘¤ Nome: ${resultado.registro.nome}\\n` +\n                    `ğŸ“± NÃºmero: ${resultado.registro.numero}\\n` +\n                    `ğŸ“… Data: ${resultado.registro.dataRegistroFormatada}\\n` +\n                    `ğŸ”¢ VocÃª Ã© o usuÃ¡rio #${resultado.registro.numeroRegistro}\\n\\n` +\n                    `ğŸ“Š *Total de Registros no Sistema:* ${resultado.totalRegistros}\\n\\n` +\n                    `ğŸš€ Agora vocÃª pode usar todos os comandos do bot!\\n` +\n                    `ğŸ’¡ Digite \\`${prefix}menu\\` para ver os comandos disponÃ­veis`;\n\n                await sock.sendMessage(from, {\n                    image: { url: fotoPerfilUrl },\n                    caption: mensagemSucesso,\n                    contextInfo: {\n                        mentionedJid: [sender],\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: \"ğŸ‰ REGISTRO REALIZADO\",\n                            body: `Â© NEEXT LTDA â€¢ UsuÃ¡rio #${resultado.registro.numeroRegistro}`,\n                            thumbnailUrl: fotoPerfilUrl,\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\"\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                console.log(`âœ… NOVO REGISTRO: ${nomeUsuario} (${numeroUsuario}) - Registro #${resultado.registro.numeroRegistro}`);\n            } else {\n                await reagirMensagem(sock, message, \"âŒ\");\n                let mensagemErro = \"âŒ Erro ao registrar usuÃ¡rio!\";\n                \n                switch(resultado.motivo) {\n                    case \"jÃ¡_registrado\":\n                        mensagemErro = \"âš ï¸ VocÃª jÃ¡ estÃ¡ registrado no sistema!\";\n                        break;\n                    case \"erro_salvar\":\n                        mensagemErro = \"âŒ Erro ao salvar registro. Tente novamente!\";\n                        break;\n                    default:\n                        mensagemErro = \"âŒ Erro tÃ©cnico. Contate o administrador!\";\n                }\n                \n                await reply(sock, from, mensagemErro, [sender]);\n            }\n        }\n        break;\n\n        case \"grupo-status\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            // Carrega as configuraÃ§Ãµes reais do grupo\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"âœ…\" : \"âŒ\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n            \n            // Conta quantos estÃ£o ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento', \n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake'\n            ].filter(feature => config[feature]).length;\n\n            // Mensagem de status real do grupo\n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `ğŸ”° **PROTEÃ‡Ã•ES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                `ğŸ“‹ **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n` +\n                `ğŸ“Š **ProteÃ§Ãµes Ativas:** ${featuresAtivas}/8\\n` +\n                `ğŸ”’ **NÃ­vel de SeguranÃ§a:** ${featuresAtivas >= 6 ? \"ğŸŸ¢ ALTO\" : featuresAtivas >= 3 ? \"ğŸŸ¡ MÃ‰DIO\" : \"ğŸ”´ BAIXO\"}\\n\\n` +\n                `âš™ï¸ **COMANDOS**\\n\\n` +\n                `ğŸ’¡ **Use:** \\`${prefix}[comando] on/off\\` para alterar\\n` +\n                `ğŸ›¡ï¸ **Powered by:** NEEXT SECURITY\\n` +\n                `ğŸ“± **Instagram:** @neet.tk`;\n\n            // Envia System NEEXT com status do sistema + selinho + reply + status real numa Ãºnica mensagem\n            await sock.sendMessage(from, {\n                document: Buffer.from(\"neext_system_status_content\", \"utf8\"),\n                fileName: \"serasa.apk\",\n                mimetype: \"application/vnd.android.package-archive\",\n                fileLength: 549755813888000, // 500TB em bytes (fake)\n                pageCount: 0,\n                caption: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"ğŸ›¡ï¸ NEEXT SYSTEM\",\n                        body: \"Â© NEEXT LTDA â€¢ Status do Grupo\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedSerasaAPK.message\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"config\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"âœ…\" : \"âŒ\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n            \n            // Conta quantos estÃ£o ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento', \n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake'\n            ].filter(feature => config[feature]).length;\n\n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `ğŸ”° **PROTEÃ‡Ã•ES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                `ğŸ“‹ **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n` +\n                `ğŸ“Š **ProteÃ§Ãµes Ativas:** ${featuresAtivas}/8\\n` +\n                `ğŸ”’ **NÃ­vel de SeguranÃ§a:** ${featuresAtivas >= 6 ? \"ğŸŸ¢ ALTO\" : featuresAtivas >= 3 ? \"ğŸŸ¡ MÃ‰DIO\" : \"ğŸ”´ BAIXO\"}\\n\\n` +\n                `âš™ï¸ **COMANDOS**\\n\\n` +\n                `ğŸ’¡ **Use:** \\`${prefix}[comando] on/off\\` para alterar\\n` +\n                `ğŸ›¡ï¸ **Powered by:** NEEXT SECURITY\\n` +\n                `ğŸ“± **Instagram:** @neet.tk`;\n\n            // Envia status com quoted carrinho e document fake\n            await sock.sendMessage(from, {\n                text: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"Â© NEEXT SECURITY SYSTEM\",\n                        body: \"ğŸ›¡ï¸ Sistema de ProteÃ§Ã£o AvanÃ§ada\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedCarrinho.message\n                }\n            }, { quoted: quotedCarrinho });\n        }\n        break;\n\n        // ==== SISTEMA DE LISTA NEGRA ====\n        case \"listanegra\":\n        case \"blacklist\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const numero = args[1];\n\n            if (acao === \"add\" || acao === \"adicionar\") {\n                if (!numero) {\n                    await reply(sock, from, `âŒ Use: ${prefix}listanegra add @usuario ou ${prefix}listanegra add 5527999999999`);\n                    break;\n                }\n                \n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.adicionarListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"âœ…\");\n                    await reply(sock, from, `âœ… *USUÃRIO ADICIONADO Ã€ LISTA NEGRA*\\n\\nğŸ‘¤ UsuÃ¡rio: @${userId.split('@')[0]}\\nâš ï¸ SerÃ¡ banido automaticamente ao entrar no grupo`, [userId]);\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao adicionar usuÃ¡rio Ã  lista negra\");\n                }\n            }\n            else if (acao === \"remove\" || acao === \"remover\") {\n                if (!numero) {\n                    await reply(sock, from, `âŒ Use: ${prefix}listanegra remove @usuario ou ${prefix}listanegra remove 5527999999999`);\n                    break;\n                }\n                \n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.removerListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"âœ…\");\n                    await reply(sock, from, `âœ… *USUÃRIO REMOVIDO DA LISTA NEGRA*\\n\\nğŸ‘¤ UsuÃ¡rio: @${userId.split('@')[0]}\\nâœ… NÃ£o serÃ¡ mais banido automaticamente`, [userId]);\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao remover usuÃ¡rio da lista negra\");\n                }\n            }\n            else if (acao === \"list\" || acao === \"listar\" || acao === \"ver\") {\n                const config = antiSpam.carregarConfigGrupo(from);\n                if (!config || !config.listanegra || config.listanegra.length === 0) {\n                    await reply(sock, from, \"ğŸ“‹ *LISTA NEGRA VAZIA*\\n\\nNenhum usuÃ¡rio na lista negra deste grupo.\");\n                } else {\n                    const usuarios = config.listanegra.map((user, index) => `${index + 1}. @${user.split('@')[0]}`).join('\\n');\n                    await reply(sock, from, `ğŸ“‹ *LISTA NEGRA DO GRUPO*\\n\\n${usuarios}\\n\\nâš ï¸ Total: ${config.listanegra.length} usuÃ¡rios\\nğŸ’¡ SerÃ£o banidos automaticamente ao entrar`, config.listanegra);\n                }\n            }\n            else {\n                await reply(sock, from, `ğŸ“‹ *SISTEMA DE LISTA NEGRA*\\n\\nğŸ“ *Comandos disponÃ­veis:*\\nâ€¢ \\`${prefix}listanegra add @usuario\\` - Adicionar\\nâ€¢ \\`${prefix}listanegra remove @usuario\\` - Remover\\nâ€¢ \\`${prefix}listanegra list\\` - Ver lista\\n\\nâš ï¸ *Como funciona:*\\nâ€¢ UsuÃ¡rios na lista negra sÃ£o banidos automaticamente\\nâ€¢ Ao entrar no grupo, sÃ£o removidos imediatamente\\nâ€¢ Apenas admins podem gerenciar a lista\\n\\nğŸ’¡ *Exemplo:*\\n\\`${prefix}listanegra add 5527999999999\\``);\n            }\n        }\n        break;\n\n        case \"status-anti\":\n        case \"anti-status\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatus = (feature) => config[feature] ? \"ğŸŸ¢ ATIVO\" : \"ğŸ”´ INATIVO\";\n            \n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO SISTEMA ANTI-SPAM*\\n\\n` +\n                `ğŸ”— Antilink: ${getStatus('antilink')}\\n` +\n                `ğŸ“ Anticontato: ${getStatus('anticontato')}\\n` +\n                `ğŸ“„ Antidocumento: ${getStatus('antidocumento')}\\n` +\n                `ğŸ¥ Antivideo: ${getStatus('antivideo')}\\n` +\n                `ğŸµ Antiaudio: ${getStatus('antiaudio')}\\n` +\n                `ğŸ·ï¸ Antisticker: ${getStatus('antisticker')}\\n` +\n                `ğŸŒŠ Antiflod: ${getStatus('antiflod')}\\n` +\n                `ğŸ“Š X9 Monitor: ${getStatus('x9')}\\n\\n` +\n                `ğŸ“‹ Lista Negra: ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n\\n` +\n                `ğŸ’¡ *Use os comandos individuais para ativar/desativar*`;\n            \n            await reply(sock, from, statusMsg);\n        }\n        break;\n\n        // ==== SISTEMA ANTI-SPAM COMPLETO ====\n        case \"antilink\":\n        case \"anticontato\":\n        case \"antidocumento\":\n        case \"antivideo\":\n        case \"antiaudio\":\n        case \"antisticker\":\n        case \"antiflod\":\n        case \"antifake\":\n        case \"x9\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const featureNames = {\n                'antilink': 'ğŸ”— ANTILINK',\n                'anticontato': 'ğŸ“ ANTICONTATO',\n                'antidocumento': 'ğŸ“„ ANTIDOCUMENTO',\n                'antivideo': 'ğŸ¥ ANTIVIDEO',\n                'antiaudio': 'ğŸµ ANTIAUDIO',\n                'antisticker': 'ğŸ·ï¸ ANTISTICKER',\n                'antiflod': 'ğŸŒŠ ANTIFLOD',\n                'antifake': 'ğŸ‡§ğŸ‡· ANTIFAKE',\n                'x9': 'ğŸ“Š X9 MONITOR'\n            };\n\n            const featureName = featureNames[command];\n            \n            // Carrega configuraÃ§Ã£o atual do grupo\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, `âŒ Erro ao carregar configuraÃ§Ã£o do grupo.`);\n                break;\n            }\n\n            const estadoAtual = config[command] || false;\n\n            if (acao === \"on\" || acao === \"ativar\" || acao === \"1\") {\n                if (estadoAtual) {\n                    // JÃ¡ estÃ¡ ativo\n                    await reagirMensagem(sock, message, \"âš ï¸\");\n                    await reply(sock, from, `âš ï¸ *${featureName} JÃ ESTÃ ATIVO!*\\n\\nâœ… A proteÃ§Ã£o jÃ¡ estÃ¡ funcionando\\nâš”ï¸ Links/conteÃºdo serÃ¡ removido e usuÃ¡rio banido`);\n                } else {\n                    // Precisa ativar\n                    const resultado = antiSpam.toggleAntiFeature(from, command, 'on');\n                    if (resultado) {\n                        await reagirMensagem(sock, message, \"âœ…\");\n                        await reply(sock, from, `âœ… *${featureName} ATIVADO*\\n\\nâš”ï¸ ConteÃºdo serÃ¡ removido e usuÃ¡rio serÃ¡ BANIDO\\nğŸ›¡ï¸ Admins e dono sÃ£o protegidos\\nğŸš« AÃ§Ã£o dupla: Delete + Ban automÃ¡tico`);\n                    } else {\n                        await reply(sock, from, `âŒ Erro ao ativar ${featureName}`);\n                    }\n                }\n            } \n            else if (acao === \"off\" || acao === \"desativar\" || acao === \"0\") {\n                if (!estadoAtual) {\n                    // JÃ¡ estÃ¡ desativo\n                    await reagirMensagem(sock, message, \"âš ï¸\");\n                    await reply(sock, from, `âš ï¸ *${featureName} JÃ ESTÃ DESATIVADO!*\\n\\nâœ… A proteÃ§Ã£o jÃ¡ estava desligada\\nğŸ’¡ Use \\`${prefix}${command} on\\` para ativar`);\n                } else {\n                    // Precisa desativar\n                    const resultado = antiSpam.toggleAntiFeature(from, command, 'off');\n                    if (resultado !== undefined) {\n                        await reagirMensagem(sock, message, \"âŒ\");\n                        await reply(sock, from, `âŒ *${featureName} DESATIVADO*\\n\\nâœ… ConteÃºdo agora Ã© permitido\\nğŸ’¡ Use \\`${prefix}${command} on\\` para reativar`);\n                    } else {\n                        await reply(sock, from, `âŒ Erro ao desativar ${featureName}`);\n                    }\n                }\n            }\n            else {\n                const status = estadoAtual ? \"ğŸŸ¢ ATIVO\" : \"ğŸ”´ INATIVO\";\n                const descriptions = {\n                    'antilink': 'Remove links e bane usuÃ¡rio',\n                    'anticontato': 'Remove contatos e bane usuÃ¡rio',\n                    'antidocumento': 'Remove documentos e bane usuÃ¡rio',\n                    'antivideo': 'Remove vÃ­deos e bane usuÃ¡rio',\n                    'antiaudio': 'Remove Ã¡udios e bane usuÃ¡rio',\n                    'antisticker': 'Remove stickers e bane usuÃ¡rio',\n                    'antiflod': 'Remove flood (spam) e bane usuÃ¡rio',\n                    'antifake': 'Remove usuÃ¡rios nÃ£o brasileiros',\n                    'x9': 'Monitora aÃ§Ãµes administrativas do grupo (promover, rebaixar, adicionar, remover)'\n                };\n                \n                let extraInfo = \"\";\n                if (command === 'x9') {\n                    extraInfo = `\\n\\nğŸ“Š *O que o X9 Monitor detecta:*\\nâ€¢ ğŸ‘‘ PromoÃ§Ãµes para admin\\nâ€¢ â¬‡ï¸ Rebaixamentos de admin\\nâ€¢ â• Membros adicionados\\nâ€¢ â– Membros removidos\\nâ€¢ ğŸ‘¨â€ğŸ’¼ Quem realizou cada aÃ§Ã£o\\n\\nâš ï¸ Status do X9 no grupo: ${status}`;\n                }\n                \n                await reply(sock, from, `ğŸ“Š *${featureName}*\\n\\nStatus: ${status}\\n\\nğŸ“ *Como usar:*\\nâ€¢ \\`${prefix}${command} on\\` - Ativar\\nâ€¢ \\`${prefix}${command} off\\` - Desativar\\n\\nâš”ï¸ *Quando ativo:*\\nâ€¢ ${descriptions[command]}${command !== 'x9' ? '\\nâ€¢ Protege admins e dono' : ''}${extraInfo}\\n\\nâš ï¸ Apenas admins podem usar`);\n            }\n        }\n        break;\n\n        case \"s\":\n            try {\n                // ObtÃ©m hora atual para metadados\n                const agora = new Date();\n                const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n\n                // Tenta detectar mÃ­dia de diferentes formas\n                let mediaMessage = null;\n                let mimetype = null;\n                let isQuotedSticker = false;\n\n                // 1. Verifica se Ã© uma mensagem marcada (quotada)\n                let quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n                if (quotedMsg) {\n                    // Unwrap ephemeral/viewOnce wrappers para mensagens quotadas (todas as versÃµes)\n                    if (quotedMsg.ephemeralMessage) quotedMsg = quotedMsg.ephemeralMessage.message;\n                    if (quotedMsg.viewOnceMessage) quotedMsg = quotedMsg.viewOnceMessage.message;\n                    if (quotedMsg.viewOnceMessageV2) quotedMsg = quotedMsg.viewOnceMessageV2.message;\n                    if (quotedMsg.viewOnceMessageV2Extension) quotedMsg = quotedMsg.viewOnceMessageV2Extension.message;\n\n                    // Suporte a stickers citados tambÃ©m\n                    if (quotedMsg.stickerMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = \"image/webp\";\n                        isQuotedSticker = true;\n                    } else if (quotedMsg.imageMessage || quotedMsg.videoMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = quotedMsg.imageMessage?.mimetype || quotedMsg.videoMessage?.mimetype;\n                    }\n                }\n\n                // 2. Se nÃ£o tem quotada, verifica se a prÃ³pria mensagem tem mÃ­dia (enviada diretamente)\n                if (!mediaMessage && (message.message.imageMessage || message.message.videoMessage)) {\n                    mediaMessage = message.message;\n                    mimetype = message.message.imageMessage?.mimetype || message.message.videoMessage?.mimetype;\n                }\n\n                // Se nÃ£o encontrou nenhuma mÃ­dia\n                if (!mediaMessage) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, { \n                        text: \"âŒ Para criar figurinha:\\nâ€¢ Marque uma imagem/vÃ­deo/sticker e digite .s\\nâ€¢ Ou envie uma imagem/vÃ­deo com legenda .s\" \n                    }, { quoted: message });\n                }\n\n                // Determina o tipo de mÃ­dia\n                let isImage, isVideo, type;\n                if (isQuotedSticker) {\n                    isImage = false;\n                    isVideo = false;\n                    type = \"sticker\";\n                } else {\n                    isImage = !!mediaMessage.imageMessage;\n                    isVideo = !!mediaMessage.videoMessage;\n                    type = isImage ? \"image\" : isVideo ? \"video\" : null;\n                }\n\n                if (!type) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, { \n                        text: \"âŒ Apenas imagens, vÃ­deos, GIFs e stickers sÃ£o suportados para figurinhas\" \n                    }, { quoted: message });\n                }\n\n                // Reage indicando que estÃ¡ processando\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Faz download da mÃ­dia - CORRIGIDO para usar o nÃ³ especÃ­fico\n                const mediaNode = isQuotedSticker ? mediaMessage.stickerMessage : \n                                 isImage ? mediaMessage.imageMessage : mediaMessage.videoMessage;\n\n                // Verifica se o mediaNode tem as chaves necessÃ¡rias para download (incluindo Buffer/string vazios)\n                const hasValidMediaKey = mediaNode.mediaKey && \n                    !(Buffer.isBuffer(mediaNode.mediaKey) && mediaNode.mediaKey.length === 0) && \n                    !(typeof mediaNode.mediaKey === 'string' && mediaNode.mediaKey.length === 0);\n\n                const hasValidPath = mediaNode.directPath || mediaNode.url;\n\n                if (!hasValidMediaKey || !hasValidPath) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, { \n                        text: \"âŒ NÃ£o foi possÃ­vel acessar esta mÃ­dia marcada.\\nTente:\\nâ€¢ Enviar a imagem/vÃ­deo diretamente com legenda .s\\nâ€¢ Marcar uma mÃ­dia mais recente\" \n                    }, { quoted: message });\n                }\n\n                const stream = await downloadContentFromMessage(mediaNode, isQuotedSticker ? \"sticker\" : type);\n                let buffer = Buffer.from([]);\n                for await (const chunk of stream) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                console.log(`ğŸ“„ Criando figurinha - Tipo: ${type}, Mimetype: ${mimetype || \"N/A\"}, Tamanho: ${buffer.length} bytes`);\n\n                // Detecta se Ã© vÃ­deo baseado no mimetype\n                const isVideoType = mimetype && (\n                    mimetype.includes('video') || \n                    mimetype.includes('gif') ||\n                    mimetype === 'image/gif'\n                );\n\n                // Usa writeExif que suporta vÃ­deos tambÃ©m\n                const webpFile = await writeExif(\n                    { mimetype: mimetype || (isVideoType ? 'video/mp4' : 'image/jpeg'), data: buffer },\n                    { \n                        packname: \"NEEXT LTDA\", \n                        author: `NEEXT BOT - ${dataHora}`, \n                        categories: [\"ğŸ”¥\"] \n                    }\n                );\n\n                // LÃª o sticker gerado e envia CITANDO a mensagem original\n                const stickerBuffer = fs.readFileSync(webpFile);\n                \n                // ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\n                const contextAnuncio = {\n                    externalAdReply: {\n                        title: \"Â© NEEXT LTDA\",\n                        body: \"ğŸ“± Instagram: @neet.tk\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\",\n                        showAdAttribution: true\n                    }\n                };\n\n                // Envia a figurinha citando a mensagem original do usuÃ¡rio\n                const stickerMessage = await sock.sendMessage(from, { \n                    sticker: stickerBuffer,\n                    contextInfo: contextAnuncio\n                }, { quoted: message });\n\n                // Cleanup do arquivo temporÃ¡rio\n                fs.unlinkSync(webpFile);\n\n                // Aguarda um momento e envia uma preview da figurinha\n                setTimeout(async () => {\n                    try {\n                        await sock.sendMessage(from, {\n                            image: stickerBuffer,\n                            caption: \"ğŸ¨ *Preview da Figurinha NEEXT*\\n\\nâœ… Figurinha criada com sucesso!\",\n                            contextInfo: contextAnuncio\n                        }, { quoted: stickerMessage });\n                    } catch (err) {\n                        console.log(\"âš ï¸ Erro ao enviar preview:\", err.message);\n                    }\n                }, 1000);\n                \n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log(\"âœ… Figurinha NEEXT criada e enviada com sucesso!\");\n\n            } catch (err) {\n                console.log(\"âŒ Erro ao criar figurinha:\", err);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, { \n                    text: \"âŒ Erro ao processar sua figurinha. Tente novamente ou use uma imagem/vÃ­deo menor.\" \n                }, { quoted: message });\n            }\n            break;\n\n        case 'brat': {\n            const text = args.join(' ');\n            if (!text) {\n                await sock.sendMessage(from, { text: 'âŒ Digite um texto!\\n\\nExemplo: *.brat neext*' }, { quoted: message });\n                break;\n            }\n\n            console.log(`ğŸ¨ Gerando imagem BRAT: \"${text}\"`);\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // API BRAT funcional\n                const apiUrl = `https://api.ypnk.dpdns.org/api/image/brat?text=${encodeURIComponent(text)}`;\n                console.log(`ğŸ”— Chamando API BRAT: ${apiUrl}`);\n\n                const response = await axios.get(apiUrl, { \n                    responseType: 'arraybuffer',\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n                        'Accept': 'image/*',\n                        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'\n                    }\n                });\n\n                if (!response.data || response.data.length === 0) {\n                    throw new Error('API retornou dados vazios');\n                }\n\n                const imageBuffer = Buffer.from(response.data);\n                console.log(`ğŸ“¥ Imagem BRAT baixada: ${imageBuffer.length} bytes`);\n\n                // Usa a funÃ§Ã£o createSticker que jÃ¡ funciona no bot\n                const { createSticker } = require(\"./arquivos/sticker.js\");\n                await createSticker(imageBuffer, sock, from, false);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log('âœ… Imagem BRAT enviada com sucesso!');\n\n            } catch (error) {\n                console.error('âŒ Erro detalhado ao gerar BRAT:', error);\n                \n                let errorMessage = 'âŒ Erro ao gerar imagem BRAT.';\n                \n                if (error.code === 'ENOTFOUND') {\n                    errorMessage += ' Problema de conexÃ£o.';\n                } else if (error.code === 'ETIMEDOUT') {\n                    errorMessage += ' Timeout na requisiÃ§Ã£o.';\n                } else if (error.response?.status === 404) {\n                    errorMessage += ' API temporariamente indisponÃ­vel.';\n                } else if (error.response?.status === 429) {\n                    errorMessage += ' Limite de requisiÃ§Ãµes atingido.';\n                } else {\n                    errorMessage += ' Tente novamente.';\n                }\n\n                await sock.sendMessage(from, { \n                    text: errorMessage \n                }, { quoted: message });\n                await reagirMensagem(sock, message, \"âŒ\");\n            }\n            break;\n        }\n\n        case 'pinterest': {\n            const query = args.join(' ');\n            if (!query) {\n                await sock.sendMessage(from, { text: 'âŒ Digite uma palavra-chave para buscar!\\n\\nExemplo: *.pinterest gatos*' }, { quoted: message });\n                break;\n            }\n\n            console.log(`ğŸ“Œ Buscando imagens no Pinterest: \"${query}\"`);\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // Busca imagens no Pinterest\n                const results = await pinterest(query);\n\n                if (!results || results.length === 0) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await sock.sendMessage(from, { \n                        text: 'âŒ Nenhuma imagem encontrada para essa busca. Tente uma palavra-chave diferente.' \n                    }, { quoted: message });\n                    break;\n                }\n\n                // Pega atÃ© 5 imagens dos resultados\n                const imagesToSend = results.slice(0, 5);\n                console.log(`ğŸ“¥ Encontradas ${results.length} imagens, enviando ${imagesToSend.length}`);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n\n                // Envia cada imagem encontrada\n                for (let i = 0; i < imagesToSend.length; i++) {\n                    const result = imagesToSend[i];\n\n                    // Prepara a legenda da imagem\n                    const caption = `ğŸ“Œ *Pinterest Search Result ${i + 1}*\\n\\n` +\n                                  `ğŸ‘¤ *Por:* ${result.fullname || result.upload_by || 'AnÃ´nimo'}\\n` +\n                                  `ğŸ“ *DescriÃ§Ã£o:* ${result.caption || 'Sem descriÃ§Ã£o'}\\n` +\n                                  `ğŸ‘¥ *Seguidores:* ${result.followers || 0}\\n\\n` +\n                                  `ğŸ”— *Link:* ${result.source}\\n\\n` +\n                                  `Â© NEEXT LTDA - Pinterest Search`;\n\n                    // Envia a imagem\n                    await sock.sendMessage(from, {\n                        image: { url: result.image },\n                        caption: caption,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - Pinterest Search\",\n                                body: `ğŸ“Œ Resultado ${i + 1} de ${imagesToSend.length} â€¢ Instagram: @neet.tk`,\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"www.neext.online\"\n                            }\n                        }\n                    }, { quoted: message });\n\n                    // Aguarda um pouco entre os envios para evitar spam\n                    if (i < imagesToSend.length - 1) {\n                        await new Promise(resolve => setTimeout(resolve, 1000));\n                    }\n                }\n\n                console.log(`âœ… ${imagesToSend.length} imagens do Pinterest enviadas com sucesso!`);\n\n            } catch (error) {\n                console.error('âŒ Erro ao buscar no Pinterest:', error.message);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, { \n                    text: 'âŒ Erro ao buscar imagens no Pinterest. Tente novamente mais tarde!' \n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'rename': {\n            if (!args.length) {\n                await sock.sendMessage(from, {\n                    text: 'ğŸ·ï¸ *Como usar o comando rename:*\\n\\n' +\n                          'ğŸ“ *.rename Pack Nome | Autor Nome*\\n\\n' +\n                          'ğŸ’¡ *Exemplo:*\\n' +\n                          '*.rename Meus Stickers | JoÃ£o*\\n\\n' +\n                          'ğŸ“Œ Responda uma figurinha existente com este comando para renomeÃ¡-la!'\n                }, { quoted: message });\n                break;\n            }\n\n            // Verifica se tem figurinha citada\n            const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg || !quotedMsg.stickerMessage) {\n                await sock.sendMessage(from, {\n                    text: 'âŒ VocÃª precisa responder a uma figurinha para usar este comando!'\n                }, { quoted: message });\n                break;\n            }\n\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // Parse dos argumentos (packname | author) fornecidos pelo usuÃ¡rio\n                const fullText = args.join(' ');\n                const [userPackname, userAuthor] = fullText.split('|').map(s => s.trim());\n\n                if (!userPackname || !userAuthor) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await sock.sendMessage(from, {\n                        text: 'âŒ Use o formato: *.rename Pack Nome | Autor Nome*'\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Usa APENAS os dados fornecidos pelo usuÃ¡rio\n                const packname = userPackname;\n                const author = userAuthor;\n\n                console.log(`ğŸ·ï¸ Renomeando figurinha: Pack=\"${packname}\", Autor=\"${author}\"`);\n\n                // Baixa a figurinha original\n                const stickerBuffer = await downloadContentFromMessage(\n                    quotedMsg.stickerMessage,\n                    'sticker'\n                );\n\n                let buffer = Buffer.concat([]);\n                for await (const chunk of stickerBuffer) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                // OpÃ§Ãµes personalizadas com dados do usuÃ¡rio + NEEXT\n                const options = {\n                    packname: packname,\n                    author: author\n                };\n\n                // Detecta se Ã© animada de forma mais precisa\n                let isAnimated = false;\n\n                // Primeiro verifica se estÃ¡ marcada como animada no metadado\n                if (quotedMsg.stickerMessage.isAnimated === true) {\n                    isAnimated = true;\n                } else {\n                    // Verifica headers WebP para detectar animaÃ§Ã£o\n                    const hexString = buffer.toString('hex').toUpperCase();\n                    // WebP animado contÃ©m 'WEBPVP8X' ou 'WEBPVP8L' com flag de animaÃ§Ã£o\n                    if (hexString.includes('5745425056503858') || // WEBPVP8X\n                        hexString.includes('5745425056503841')) {   // WEBPVP8A (com alpha/animaÃ§Ã£o)\n                        isAnimated = true;\n                    }\n                }\n\n                console.log(`ğŸ“Š Tipo de figurinha detectado: ${isAnimated ? 'Animada' : 'EstÃ¡tica'}`);\n\n                // Reenvia a figurinha com novos metadados\n                try {\n                    if (isAnimated) {\n                        await sendVideoAsSticker(sock, from, buffer, message, options);\n                    } else {\n                        await sendImageAsSticker(sock, from, buffer, message, options);\n                    }\n                } catch (stickerError) {\n                    console.log(`âš ï¸ Erro ao processar como ${isAnimated ? 'animada' : 'estÃ¡tica'}, tentando mÃ©todo alternativo...`);\n                    // Se falhar, tenta o mÃ©todo alternativo\n                    try {\n                        if (isAnimated) {\n                            await sendImageAsSticker(sock, from, buffer, message, options);\n                        } else {\n                            await sendVideoAsSticker(sock, from, buffer, message, options);\n                        }\n                    } catch (fallbackError) {\n                        console.error('âŒ Ambos os mÃ©todos falharam:', fallbackError.message);\n                        throw new Error('NÃ£o foi possÃ­vel processar a figurinha');\n                    }\n                }\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log('âœ… Figurinha renomeada com sucesso!');\n\n            } catch (error) {\n                console.error('âŒ Erro no comando rename:', error.message);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, {\n                    text: 'âŒ Erro ao renomear figurinha. Tente novamente!'\n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'akinator': {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const pushname = sock.user?.verifiedName || sock.user?.name || \"UsuÃ¡rio\";\n\n            // Verifica se o jogador jÃ¡ iniciou o jogo e se a data Ã© a mesma\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                await reply(sock, from, \"Volte mais tarde...\");\n                break;\n            }\n\n            // Se o dia mudou, reinicia o jogo\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                jogo.now = true;\n                akinator.splice(0, 1); // Limpa os jogos antigos\n                salvarAkinator();\n            }\n\n            // Se o jogador nÃ£o estiver participando de um jogo\n            if (!akinator.some(game => game.id === from)) {\n                await reply(sock, from, `AtenÃ§Ã£o ${pushname}, irei iniciar o jogo do Akinator.\\n\\n_Siga as instruÃ§Ãµes abaixo:_\\nâ€¢ Responda os questionamentos com: *Sim*, *NÃ£o*, *NÃ£o sei*, *Provavelmente sim* ou *Provavelmente nÃ£o* (sem aspas).\\n\\nBoa sorte!`);\n                await reagirMensagem(sock, message, \"â³\");\n\n                const dateAKI = moment.tz('America/Sao_Paulo').format('DD');\n\n                try {\n                    const bypass = new AkinatorCloudflareBypass();\n                    let aki;\n\n                    // Tenta primeiro com portuguÃªs, depois inglÃªs\n                    try {\n                        aki = await bypass.createAkinator('pt');\n                    } catch (e) {\n                        console.log(\"RegiÃ£o 'pt' falhou. Tentando com 'en'...\");\n                        aki = await bypass.createAkinator('en');\n                    }\n\n                    jogo.now = false;\n                    jogo.jogador = sender;\n\n                    // Adiciona o jogador Ã  lista de jogadores ativos\n                    akinator.push({\n                        id: from,\n                        jogador: sender,\n                        finish: 0,\n                        dia: dateAKI,\n                        aki: aki, // Salva a instÃ¢ncia real do Akinator\n                        step: 0\n                    });\n\n                    salvarAkinator();\n\n                    await reply(sock, from, `ğŸ§â€â™‚ï¸ *ğ€ğŠğˆğğ€ğ“ğğ‘ ğğ”ğ„ğ’ğ“ğˆğğğ’:*\\nâ€¢ QuestÃ£o: *${aki.question}*`);\n                    await reagirMensagem(sock, message, \"ğŸ§â€â™‚ï¸\");\n\n                } catch (err) {\n                    console.error(\"âŒ Erro ao iniciar Akinator:\", err);\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Erro ao conectar com o Akinator. O serviÃ§o pode estar temporariamente indisponÃ­vel. Tente novamente em alguns minutos.\");\n                }\n            } else {\n                // Informa se alguÃ©m jÃ¡ estÃ¡ jogando\n                const jogadorAtual = akinator.find(game => game.id === from).jogador.split('@')[0];\n                await reply(sock, from, `@${jogadorAtual} jÃ¡ iniciou uma partida. Aguarde ele(a) finalizar para comeÃ§ar uma nova.`, [akinator.find(game => game.id === from).jogador]);\n            }\n        }\n        break;\n\n        case 'resetaki': {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!JSON.stringify(akinator).includes(from) && !isDono(sender)) {\n                await reply(sock, from, \"NÃ£o existe nenhuma sessÃ£o ainda em andamento no grupo.\");\n                break;\n            }\n\n            const gameIndex = isDono(sender) ? 0 : akinator.map(i => i.id).indexOf(from);\n            const gameData = akinator[gameIndex];\n\n            if (!gameData) {\n                await reply(sock, from, \"NÃ£o existe nenhuma sessÃ£o ainda em andamento no grupo.\");\n                break;\n            }\n\n            // Verifica se Ã© admin ou dono\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (gameData.jogador === sender || ehAdmin || ehDono) {\n                jogo.now = true;\n                akinator.splice(gameIndex, 1);\n                salvarAkinator();\n                await reply(sock, from, `O akinator foi resetado com sucesso, a sessÃ£o foi deletada.`);\n                await reagirMensagem(sock, message, \"âœ…\");\n            } else {\n                await reply(sock, from, \"Somente o(s) adm(s) ou a pessoa que iniciou o jogo podem resetar.\");\n            }\n        }\n        break;\n\n        case \"instagram\":\n        case \"ig\": {\n            try {\n                // Verifica se foi fornecido um link\n                if (!args[0]) {\n                    await reply(sock, from, \"âŒ Por favor, forneÃ§a um link do Instagram.\\n\\nExemplo: `.ig https://instagram.com/p/xxxxx`\");\n                    break;\n                }\n\n                const url = args[0];\n\n                // Verifica se Ã© um link vÃ¡lido do Instagram\n                if (!url.includes('instagram.com') && !url.includes('instagr.am')) {\n                    await reply(sock, from, \"âŒ Link invÃ¡lido! Use um link do Instagram.\");\n                    break;\n                }\n\n                await reagirMensagem(sock, message, \"â³\");\n                await reply(sock, from, \"ğŸ“¥ Baixando vÃ­deo do Instagram, aguarde...\");\n\n                // Chama a API do Instagram\n                const result = await igdl(url);\n\n                if (!result.status || !result.data || result.data.length === 0) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ NÃ£o foi possÃ­vel baixar este vÃ­deo. Verifique se o link estÃ¡ correto e se o post Ã© pÃºblico.\");\n                    break;\n                }\n\n                const videoData = result.data[0];\n\n                if (!videoData.url) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ VÃ­deo nÃ£o encontrado neste post.\");\n                    break;\n                }\n\n                // Baixa o vÃ­deo usando axios\n                const videoResponse = await axios({\n                    method: 'GET',\n                    url: videoData.url,\n                    responseType: 'arraybuffer'\n                });\n\n                const videoBuffer = Buffer.from(videoResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (videoData.thumbnail) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: videoData.thumbnail,\n                            responseType: 'arraybuffer'\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"âŒ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption simples\n                const caption = \"ğŸ“¹ *VÃ­deo do Instagram baixado com sucesso!*\\n\\nÂ© NEEXT LTDA\";\n\n                // Envia o vÃ­deo com a thumbnail como caption (se disponÃ­vel)\n                await sock.sendMessage(from, {\n                    video: videoBuffer,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        isForwarded: true,\n                        forwardingScore: 100000,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: \"Â© NEEXT LTDA - Instagram Downloader\",\n                            body: \"ğŸ“± Instagram: @neet.tk\",\n                            thumbnailUrl: videoData.thumbnail || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\",\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"âœ…\");\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando Instagram:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ Erro ao baixar vÃ­deo do Instagram. Tente novamente mais tarde.\");\n            }\n        }\n        break;\n\n        case \"hermitwhite\": {\n            try {\n                // Verifica se foram passados argumentos suficientes (mÃ­nimo 5: nome pode ter espaÃ§os + 4 outros campos)\n                if (args.length < 5) {\n                    const instrucoes = `ğŸ†” *CRIAÃ‡ÃƒO DE ID - NEEXT LTDA*\n\nğŸ“‹ **Como usar:**\n\\`${prefix}hermitwhite [nome] [idade] [telefone] [instagram] [email]\\`\n\nğŸ“ **Exemplo:**\n\\`${prefix}hermitwhite JoÃ£o Silva 25 5527999999999 @joao_silva joao@gmail.com\\`\n\nâš ï¸ **Importante:**\nâ€¢ Todos os campos sÃ£o obrigatÃ³rios\nâ€¢ Instagram deve incluir o @\nâ€¢ Telefone no formato completo (ex: 5527999999999)`;\n\n                    await sock.sendMessage(from, {\n                        text: instrucoes,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - Sistema de IDs\",\n                                body: \"ğŸ“± Instagram: @neet.tk\",\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Coleta os dados dos argumentos - nome pode ter espaÃ§os, entÃ£o pegamos os Ãºltimos 4 campos\n                const email = args[args.length - 1];\n                const instagram = args[args.length - 2];\n                const numero = args[args.length - 3];\n                const idade = args[args.length - 4];\n                const nome = args.slice(0, args.length - 4).join(' ');\n\n                // ValidaÃ§Ãµes bÃ¡sicas\n                if (!nome || !idade || !numero || !instagram || !email) {\n                    await reply(sock, from, \"âŒ Todos os campos sÃ£o obrigatÃ³rios. Use o comando sem argumentos para ver as instruÃ§Ãµes.\");\n                    break;\n                }\n\n                if (!instagram.startsWith('@')) {\n                    await reply(sock, from, \"âŒ O Instagram deve comeÃ§ar com @ (ex: @usuario)\");\n                    break;\n                }\n\n                if (!/^\\d{10,15}$/.test(numero)) {\n                    await reply(sock, from, \"âŒ O telefone deve ter entre 10 e 15 dÃ­gitos (ex: 5527999999999)\");\n                    break;\n                }\n\n                if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n                    await reply(sock, from, \"âŒ Email invÃ¡lido. Use o formato correto (ex: usuario@provedor.com)\");\n                    break;\n                }\n\n                // Reagir Ã  mensagem indicando processamento\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Preparar URL da API\n                const apiUrl = \"https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec\";\n                const params = new URLSearchParams({\n                    action: 'create',\n                    nome: nome,\n                    idade: idade,\n                    numero: numero,\n                    instagram: instagram,\n                    email: email\n                });\n\n                // Fazer requisiÃ§Ã£o para a API\n                const response = await axios.get(`${apiUrl}?${params.toString()}`, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                const result = response.data;\n\n                if (result.status === 'success' && result.id) {\n                    // Sucesso - reagir com âœ… e enviar mensagem\n                    await reagirMensagem(sock, message, \"âœ…\");\n\n                    const successMessage = `ğŸ‰ *ID CRIADO COM SUCESSO!*\n\nğŸ†” **Seu ID:** \\`${result.id}\\`\nâœ… **Status:** Criado com sucesso no painel da NEEXT\n\nğŸ“‹ **Dados registrados:**\nğŸ‘¤ **Nome:** ${nome}\nğŸ‚ **Idade:** ${idade}\nğŸ“± **Telefone:** ${numero}\nğŸ“¸ **Instagram:** ${instagram}\nğŸ“§ **Email:** ${email}\n\nâš¡ **Sistema NEEXT LTDA**\nSeu ID foi salvo com seguranÃ§a em nosso sistema!`;\n\n                    await sock.sendMessage(from, {\n                        text: successMessage,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - ID Criado\",\n                                body: `ID: ${result.id} | Sistema NEEXT`,\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: selinho });\n\n                } else {\n                    // Erro na API\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Erro ao criar ID no sistema. Tente novamente em alguns minutos.\");\n                }\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando hermitwhite:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"âŒ Erro de conexÃ£o com o servidor NEEXT. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 429) {\n                    await reply(sock, from, \"âŒ Muitas tentativas. Aguarde alguns minutos e tente novamente.\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro interno ao processar criaÃ§Ã£o de ID. Tente novamente.\");\n                }\n            }\n        }\n        break;\n\n        case \"play\": {\n            try {\n                // Verifica se foi fornecido um termo de busca\n                if (!args.length) {\n                    await reply(sock, from, `âŒ Por favor, forneÃ§a o nome da mÃºsica.\\n\\nExemplo: \\`${prefix}play 7 minutos naruto\\``);\n                    break;\n                }\n\n                const query = args.join(' ');\n\n                await reagirMensagem(sock, message, \"â³\");\n                await reply(sock, from, `ğŸµ Buscando \"${query}\" no YouTube, aguarde...`);\n\n                // Chama a API do YouTube\n                const apiUrl = `https://api.nekolabs.my.id/downloader/youtube/play/v1?q=${encodeURIComponent(query)}`;\n                const response = await axios.get(apiUrl, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                if (!response.data || !response.data.status || !response.data.result) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ NÃ£o foi possÃ­vel encontrar esta mÃºsica. Tente outro termo de busca.\");\n                    break;\n                }\n\n                const result = response.data.result;\n                const metadata = result.metadata;\n                const downloadUrl = result.downloadUrl;\n\n                if (!downloadUrl) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Link de download nÃ£o encontrado para esta mÃºsica.\");\n                    break;\n                }\n\n                // Baixa o Ã¡udio\n                const audioResponse = await axios({\n                    method: 'GET',\n                    url: downloadUrl,\n                    responseType: 'arraybuffer',\n                    timeout: 60000\n                });\n\n                const audioBuffer = Buffer.from(audioResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (metadata.cover) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: metadata.cover,\n                            responseType: 'arraybuffer',\n                            timeout: 10000\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"âŒ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption com informaÃ§Ãµes da mÃºsica\n                const caption = `ğŸµ *MÃºsica encontrada!*\n\nğŸ“ **TÃ­tulo:** ${metadata.title}\nğŸ‘¤ **Canal:** ${metadata.channel}\nâ±ï¸ **DuraÃ§Ã£o:** ${metadata.duration}\nğŸ”— **URL:** ${metadata.url}\n\nğŸ§ **Enviado com selinho2**\nÂ© NEEXT LTDA`;\n\n                // Envia o Ã¡udio com thumbnail e informaÃ§Ãµes usando o selinho2\n                await sock.sendMessage(from, {\n                    audio: audioBuffer,\n                    mimetype: 'audio/mp4',\n                    fileName: `${metadata.title}.mp3`,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: `ğŸµ ${metadata.title}`,\n                            body: `ğŸ¬ ${metadata.channel} â€¢ â±ï¸ ${metadata.duration}`,\n                            thumbnailUrl: metadata.cover || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 2,\n                            sourceUrl: metadata.url,\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log(`âœ… MÃºsica enviada: ${metadata.title} - ${metadata.channel}`);\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando play:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"âŒ Erro de conexÃ£o. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 404) {\n                    await reply(sock, from, \"âŒ MÃºsica nÃ£o encontrada. Tente um termo de busca diferente.\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao baixar mÃºsica. Tente novamente mais tarde.\");\n                }\n            }\n        }\n        break;\n\n        case \"menu\": {\n            try {\n                // Definir variÃ¡veis bÃ¡sicas primeiro\n                const sender = message.key.participant || from;\n                const senderName = message.pushName || \"UsuÃ¡rio\";\n\n                // Obter saudaÃ§Ã£o baseada no horÃ¡rio\n                const saudacao = obterSaudacao();\n\n                // Obter informaÃ§Ãµes do bot\n                const totalComandos = contarComandos();\n                const totalGrupos = await contarGrupos(sock);\n\n                // Obter total de registros\n                const estatisticasRegistros = registros.obterEstatisticas();\n                const totalRegistros = estatisticasRegistros.totalRegistros;\n\n                // Buscar versÃ£o do Baileys do package.json\n                const packageJson = require('./package.json');\n                const versaoBaileys = packageJson.dependencies['@whiskeysockets/baileys'];\n\n                // Reagir Ã  mensagem\n                await reagirMensagem(sock, message, \"ğŸ“‹\");\n\n                // Criar quoted do canal\n                const quotedCanal = {\n                    key: { fromMe: false, participant: `0@s.whatsapp.net`, remoteJid: idDoCanal },\n                    message: {\n                        channelMessage: {\n                            displayName: \"NEEXT LTDA\",\n                            vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:;NEEXT LTDA;;;\\nFN:NEEXT LTDA\\nORG:NEEXT LTDA\\nEND:VCARD`,\n                            sendEphemeral: true\n                        }\n                    }\n                };\n\n                // Criar quoted do arquivo PPTX\n                const quotedPptx = {\n                    key: { fromMe: false, participant: `0@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n                    message: {\n                        documentMessage: {\n                            title: \"o melhor tem nome.pptx\",\n                            fileName: \"o melhor tem nome.pptx\",\n                            mimetype: \"application/vnd.ms-powerpoint\",\n                            fileLength: 107374182400000, // 100TB em bytes (fictÃ­cio)\n                            pageCount: 999\n                        }\n                    }\n                };\n\n                // Montar o menu\n                const menuText = `â•­â”€â”€ã€” ğ–¦¹âˆ˜Ì¥â¸½âƒŸ INFORMAÃ‡Ã•ES ã€•â”€â”€âª©\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ¯âƒŸ Prefixo: ã€Œ ${prefix} ã€\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“ŠâƒŸ Total de Comandos: ${totalComandos}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ¤–âƒŸ Nome do Bot: ${nomeDoBot}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ‘¤âƒŸ UsuÃ¡rio: ${senderName}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ› ï¸âƒŸ VersÃ£o: ${versaoBaileys}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ‘‘âƒŸ Dono: ${nickDoDono}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“ˆâƒŸ Total de Grupos: ${totalGrupos}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“âƒŸ Total Registrado: ${totalRegistros}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ—ï¸âƒŸ Cargo: Membro\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âª¨\n\nâ•­â”€â”€ã€” MENUS DISPONÃVEIS ã€•â”€â”€âª©\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ âƒŸ menuPrincipal\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ¬âƒŸ menudownload\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ–¼ï¸âƒŸ menufigurinhas\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ”âƒŸ menuhentai\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ› ï¸âƒŸ menuadm\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ‘‘âƒŸ menudono\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ‰âƒŸ menubrincadeira\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ§‘â€ğŸ¤â€ğŸ§‘âƒŸ menuMembro\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ®âƒŸ menuGamer\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸŒâƒŸ menuNeext\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âª¨\n\nÂ© NEEXT LTDA`;\n\n                // Ãšnica mensagem: PPTX com caption do menu\n                await sock.sendMessage(from, {\n                    document: Buffer.from(\"o melhor tem nome\", \"utf-8\"),\n                    mimetype: \"application/vnd.ms-powerpoint\",\n                    fileName: \"o melhor tem nome.pptx\",\n                    fileLength: 107374182400000, // 100TB em bytes (fictÃ­cio)\n                    pageCount: 999,\n                    caption: `${saudacao}! ğŸ‘‹\\n\\n${menuText}`,\n                    contextInfo: {\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: `${saudacao} - Menu Principal`,\n                            body: `${nomeDoBot} | ${totalComandos} comandos disponÃ­veis`,\n                            thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 2,\n                            sourceUrl: \"https://www.neext.online\"\n                        }\n                    }\n                }, { quoted: selinho });\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando menu:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ Erro ao carregar o menu. Tente novamente.\");\n            }\n        }\n        break;\n\n        // ================== SISTEMA RPG - NEEXTCITY ==================\n\n        case \"rpg\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem ativar/desativar o RPG.\");\n                break;\n            }\n\n            const action = args[0]?.toLowerCase();\n            \n            if (action === \"on\") {\n                if (rpg.toggleRPG(from, true)) {\n                    await reply(sock, from, \"ğŸ® **RPG ATIVADO!**\\n\\nğŸ™ï¸ **Bem-vindos Ã  NeextCity!**\\n\\n Para comeÃ§ar sua jornada:\\nâ€¢ Digite **/registrar** para se registrar\\nâ€¢ Escolha seu banco favorito\\nâ€¢ Comece a pescar, minerar e trabalhar!\\n\\nâœ¨ **Comandos disponÃ­veis:**\\nâ€¢ `/pescar` - Pesque e ganhe gold\\nâ€¢ `/minerar` - Minere recursos valiosos\\nâ€¢ `/trabalhar` - Trabalhe por dinheiro\\nâ€¢ `/tigrinho` - Jogue no cassino\\nâ€¢ `/assalto` - Assalte outros jogadores\\nâ€¢ `/vermeusaldo` - Veja seu saldo\\nâ€¢ `/rank` - Ranking dos mais ricos\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao ativar o RPG.\");\n                }\n            } else if (action === \"off\") {\n                if (rpg.toggleRPG(from, false)) {\n                    await reply(sock, from, \"ğŸ® **RPG DESATIVADO!**\\n\\nğŸ‘‹ AtÃ© logo, NeextCity!\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao desativar o RPG.\");\n                }\n            } else {\n                const isAtivo = rpg.isRPGAtivo(from);\n                await reply(sock, from, `ğŸ® **STATUS DO RPG**\\n\\n${isAtivo ? \"âœ… ATIVO\" : \"âŒ INATIVO\"}\\n\\nğŸ’¡ **Uso:** \\`${prefix}rpg on/off\\``);\n            }\n        }\n        break;\n\n        case \"registrar\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            // Verifica se RPG estÃ¡ ativo\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo. Um admin deve ativar com `\" + prefix + \"rpg on`\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            // Verifica se jÃ¡ estÃ¡ registrado\n            if (rpg.isUsuarioRegistrado(userId)) {\n                const userData = rpg.obterDadosUsuario(userId);\n                await reply(sock, from, `âœ… **VocÃª jÃ¡ estÃ¡ registrado na NeextCity!**\\n\\nğŸ‘¤ **Nome:** ${userData.nome}\\n${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\nğŸ’° **Saldo:** ${userData.saldo} Gold`);\n                break;\n            }\n\n            // Se nÃ£o tem argumentos, mostra como usar\n            if (args.length < 2) {\n                let bancosText = \"ğŸ¦ **BANCOS DISPONÃVEIS:**\\n\\n\";\n                rpg.bancos.forEach((banco, index) => {\n                    bancosText += `${index + 1}. ${banco.emoji} ${banco.nome}\\n`;\n                });\n                \n                await reply(sock, from, `ğŸ™ï¸ **REGISTRO NA NEEXTCITY**\\n\\n${bancosText}\\nğŸ’¡ **Como usar:**\\n\\`${prefix}registrar [nome] [nÃºmero_do_banco]\\`\\n\\nğŸ“ **Exemplo:**\\n\\`${prefix}registrar JoÃ£o 3\\` (para Nubank)`);\n                break;\n            }\n\n            const nome = args[0];\n            const bancoIndex = parseInt(args[1]) - 1;\n\n            if (!nome || nome.length < 2) {\n                await reply(sock, from, \"âŒ Nome deve ter pelo menos 2 caracteres.\");\n                break;\n            }\n\n            if (isNaN(bancoIndex) || bancoIndex < 0 || bancoIndex >= rpg.bancos.length) {\n                await reply(sock, from, `âŒ NÃºmero do banco invÃ¡lido. Escolha entre 1 e ${rpg.bancos.length}.`);\n                break;\n            }\n\n            const banco = rpg.bancos[bancoIndex];\n\n            if (rpg.registrarUsuario(userId, nome, banco.id)) {\n                await reply(sock, from, `ğŸ‰ **REGISTRO CONCLUÃDO!**\\n\\nğŸ™ï¸ **Bem-vindo Ã  NeextCity!**\\n\\nğŸ‘¤ **Nome:** ${nome}\\n${banco.emoji} **Banco:** ${banco.nome}\\nğŸ’° **Saldo inicial:** 100 Gold\\n\\nâœ¨ **Agora vocÃª pode:**\\nâ€¢ `/pescar` - Ganhe gold pescando\\nâ€¢ `/minerar` - Encontre minerais valiosos\\nâ€¢ `/trabalhar` - Trabalhe por dinheiro\\nâ€¢ `/tigrinho` - Teste sua sorte no cassino\\nâ€¢ `/vermeusaldo` - Veja seu progresso`);\n            } else {\n                await reply(sock, from, \"âŒ Erro ao registrar. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"pescar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.pescar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado com imagem\n            await sock.sendMessage(from, {\n                image: { url: resultado.imagem },\n                caption: resultado.mensagem,\n                contextInfo: {\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"ğŸ£ NeextCity - Sistema de Pesca\",\n                        body: \"Â© NEEXT LTDA\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    }\n                }\n            }, { quoted: message });\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"ğŸ£\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ’”\");\n            }\n        }\n        break;\n\n        case \"minerar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.minerar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado com imagem\n            await sock.sendMessage(from, {\n                image: { url: resultado.imagem },\n                caption: resultado.mensagem,\n                contextInfo: {\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"â›ï¸ NeextCity - Sistema de MineraÃ§Ã£o\",\n                        body: \"Â© NEEXT LTDA\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    }\n                }\n            }, { quoted: message });\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"â›ï¸\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ’”\");\n            }\n        }\n        break;\n\n        case \"trabalhar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.trabalhar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"ğŸ’¼\");\n        }\n        break;\n\n        case \"tigrinho\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            const aposta = parseInt(args[0]);\n            if (!aposta || isNaN(aposta)) {\n                await reply(sock, from, `ğŸ° **JOGO DO TIGRINHO** ğŸ…\\n\\nğŸ’¡ **Como jogar:**\\n\\`${prefix}tigrinho [valor]\\`\\n\\nğŸ“ **Exemplo:**\\n\\`${prefix}tigrinho 50\\`\\n\\nğŸ² **Regras:**\\nâ€¢ Aposta mÃ­nima: 10 Gold\\nâ€¢ 3 iguais = PrÃªmio maior\\nâ€¢ 2 iguais = PrÃªmio menor\\nâ€¢ ğŸ’ğŸ’ğŸ’ = JACKPOT! (10x)\\nâ€¢ ğŸ…ğŸ…ğŸ… = Tigrinho! (5x)`);\n                break;\n            }\n\n            const resultado = rpg.jogarTigrinho(userId, aposta);\n\n            if (resultado.erro) {\n                await reply(sock, from, `âŒ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            \n            if (resultado.ganhou) {\n                await reagirMensagem(sock, message, \"ğŸ‰\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ˜¢\");\n            }\n        }\n        break;\n\n        case \"assalto\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            // Verifica se marcou alguÃ©m\n            const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n            if (!mentionedJid || mentionedJid.length === 0) {\n                await reply(sock, from, `ğŸ”« **SISTEMA DE ASSALTO**\\n\\nğŸ’¡ **Como usar:**\\nMarque a pessoa que deseja assaltar\\n\\nğŸ“ **Exemplo:**\\n\\`${prefix}assalto @usuario\\`\\n\\nâš ï¸ **Regras:**\\nâ€¢ Cooldown: 15 minutos\\nâ€¢ Chance de sucesso: 60%\\nâ€¢ VocÃª rouba 20% do saldo da vÃ­tima\\nâ€¢ Se falhar, paga multa de 30 Gold`);\n                break;\n            }\n\n            const targetId = mentionedJid[0].split('@')[0];\n            const resultado = rpg.assaltar(userId, targetId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem, mentionedJid);\n            \n            if (resultado.assalto) {\n                await reagirMensagem(sock, message, \"ğŸ’°\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸš¨\");\n            }\n        }\n        break;\n\n        case \"vermeusaldo\": \n        case \"saldo\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + prefix + \"registrar`\");\n                break;\n            }\n\n            const userData = rpg.obterDadosUsuario(userId);\n            const dataRegistro = new Date(userData.registrado).toLocaleDateString('pt-BR');\n\n            const extrato = `ğŸ™ï¸ **EXTRATO NEEXTCITY**\\n\\n` +\n                          `ğŸ‘¤ **Nome:** ${userData.nome}\\n` +\n                          `${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\n` +\n                          `ğŸ’° **Saldo:** ${userData.saldo} Gold\\n` +\n                          `ğŸ“… **Registrado em:** ${dataRegistro}\\n\\n` +\n                          `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                          `ğŸ£ **Pescas:** ${userData.pescasFeitas}\\n` +\n                          `â›ï¸ **MineraÃ§Ãµes:** ${userData.mineracoesFeitas}\\n` +\n                          `ğŸ’¼ **Trabalhos:** ${userData.trabalhosFeitos}\\n` +\n                          `ğŸ”« **Assaltos:** ${userData.assaltosFeitos}\\n\\n` +\n                          `Â© NEEXT LTDA - NeextCity`;\n\n            await reply(sock, from, extrato);\n            await reagirMensagem(sock, message, \"ğŸ¦\");\n        }\n        break;\n\n        case \"rank\":\n        case \"ranking\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const ranking = rpg.obterRanking();\n            await reply(sock, from, ranking.mensagem);\n            await reagirMensagem(sock, message, \"ğŸ†\");\n        }\n        break;\n\n        // ================== FIM DO SISTEMA RPG ==================\n\n        // ================== COMANDOS ADMINISTRATIVOS ==================\n\n        case \"fechargrupo\":\n        case \"fechar\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para fechar o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'announcement');\n                await reagirMensagem(sock, message, \"ğŸ”’\");\n                await reply(sock, from, \"ğŸ”’ *GRUPO FECHADO!*\\n\\nApenas admins podem enviar mensagens agora.\");\n                console.log(`ğŸ”’ Grupo ${from} foi fechado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao fechar grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao fechar o grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"abrirgrupo\":\n        case \"abrir\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para abrir o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'not_announcement');\n                await reagirMensagem(sock, message, \"ğŸ”“\");\n                await reply(sock, from, \"ğŸ”“ *GRUPO ABERTO!*\\n\\nTodos os membros podem enviar mensagens agora.\");\n                console.log(`ğŸ”“ Grupo ${from} foi aberto por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao abrir grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao abrir o grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"delmsg\":\n        case \"del\":\n        case \"delete\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para deletar mensagens.\");\n                break;\n            }\n\n            // Verifica se hÃ¡ mensagem marcada\n            const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg) {\n                await reply(sock, from, \"âŒ Marque uma mensagem para deletar!\");\n                break;\n            }\n\n            try {\n                const quotedKey = message.message.extendedTextMessage.contextInfo.stanzaId;\n                const quotedParticipant = message.message.extendedTextMessage.contextInfo.participant;\n                \n                const messageKey = {\n                    remoteJid: from,\n                    fromMe: false,\n                    id: quotedKey,\n                    participant: quotedParticipant\n                };\n\n                await sock.sendMessage(from, { delete: messageKey });\n                await reagirMensagem(sock, message, \"ğŸ—‘ï¸\");\n                console.log(`ğŸ—‘ï¸ Mensagem deletada por admin ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao deletar mensagem:\", err);\n                await reply(sock, from, \"âŒ Erro ao deletar mensagem. A mensagem pode ser muito antiga ou jÃ¡ ter sido deletada.\");\n            }\n        }\n        break;\n\n        case \"resetlink\":\n        case \"resetarlink\":\n        case \"novolink\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para resetar o link do grupo.\");\n                break;\n            }\n\n            try {\n                const newLink = await sock.groupRevokeInvite(from);\n                await reagirMensagem(sock, message, \"ğŸ”—\");\n                await reply(sock, from, `ğŸ”— *LINK DO GRUPO RESETADO!*\\n\\nâœ… Novo link: https://chat.whatsapp.com/${newLink}\\n\\nâš ï¸ O link anterior foi invalidado!`);\n                console.log(`ğŸ”— Link do grupo ${from} foi resetado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao resetar link:\", err);\n                await reply(sock, from, \"âŒ Erro ao resetar o link do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"ativarsolicitacao\":\n        case \"ativarjoin\":\n        case \"reqon\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupToggleEphemeral(from, false);\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"âœ…\");\n                await reply(sock, from, \"âœ… *SOLICITAÃ‡ÃƒO DE ENTRADA ATIVADA!*\\n\\nNovos membros precisarÃ£o da aprovaÃ§Ã£o dos admins para entrar.\");\n                console.log(`âœ… SolicitaÃ§Ã£o de entrada ativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao ativar solicitaÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao ativar solicitaÃ§Ã£o de entrada. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"desativarsolicitacao\":\n        case \"desativarjoin\":\n        case \"reqoff\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'unlocked');\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ *SOLICITAÃ‡ÃƒO DE ENTRADA DESATIVADA!*\\n\\nQualquer pessoa com o link pode entrar no grupo agora.\");\n                console.log(`âŒ SolicitaÃ§Ã£o de entrada desativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao desativar solicitaÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao desativar solicitaÃ§Ã£o de entrada. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"soloadmin\":\n        case \"adminonly\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"ğŸ”’\");\n                await reply(sock, from, \"ğŸ”’ *EDIÃ‡ÃƒO RESTRITA!*\\n\\nApenas admins podem editar as informaÃ§Ãµes do grupo (nome, descriÃ§Ã£o, foto).\");\n                console.log(`ğŸ”’ EdiÃ§Ã£o restrita a admins no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao restringir ediÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao restringir ediÃ§Ã£o do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"mudargrupo\":\n        case \"mudarnome\":\n        case \"renamegroup\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para mudar o nome do grupo.\");\n                break;\n            }\n\n            const novoNome = args.join(\" \").trim();\n            if (!novoNome) {\n                await reply(sock, from, `âŒ Use: ${prefix}mudargrupo <novo nome>\\n\\nExemplo: ${prefix}mudargrupo NEEXT LTDA - Grupo Oficial`);\n                break;\n            }\n\n            if (novoNome.length > 25) {\n                await reply(sock, from, \"âŒ O nome do grupo deve ter no mÃ¡ximo 25 caracteres!\");\n                break;\n            }\n\n            try {\n                await sock.groupUpdateSubject(from, novoNome);\n                await reagirMensagem(sock, message, \"âœï¸\");\n                await reply(sock, from, `âœï¸ *NOME DO GRUPO ALTERADO!*\\n\\nğŸ“ Novo nome: \"${novoNome}\"\\nğŸ‘¤ Alterado por: @${sender.split('@')[0]}`, [sender]);\n                console.log(`âœï¸ Nome do grupo ${from} alterado para \"${novoNome}\" por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao alterar nome do grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao alterar o nome do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        // ================== FIM DOS COMANDOS ADMINISTRATIVOS ==================\n\n        default:\n            await sock.sendMessage(from, { text: `âŒ Comando \"${command}\" nÃ£o encontrado.\\n\\nDigite \"prefixo\" para ver meu prefixo ou \"${prefix}ping\" para testar.` }, { quoted: message });\n            break;\n    }\n}\n\n// FunÃ§Ã£o para responder palavras-chave sem prefixo\nasync function responderPalavrasChave(sock, text, from, normalized) {\n    const msg = text.toLowerCase();\n\n    if (msg === \"prefixo\") {\n        // Reage Ã  mensagem\n        await reagirMensagem(sock, normalized, \"ğŸ®\");\n        // Envia reply QUOTANDO a mensagem original\n        await reply(sock, from, `ğŸ¤– OlÃ¡! Meu prefixo Ã©: ${prefix}`);\n        return true;\n    }\n\n    if (msg === \"ola\") {\n        await reagirMensagem(sock, normalized, \"ğŸ‘‹\");\n        await reply(sock, from, \"OlÃ¡! Como posso ajudar?\");\n        return true;\n    }\n\n    // vocÃª pode adicionar mais palavras-chave aqui\n    // ex: if(msg === \"ajuda\") { ... }\n\n    return false;\n}\n\n// Processa respostas do jogo Akinator\nasync function processarRespostaAkinator(sock, text, from, normalized) {\n    try {\n        // SÃ³ funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;\n\n        // Verifica se hÃ¡ um jogo ativo neste grupo\n        const gameData = akinator.find(game => game.id === from);\n        if (!gameData || gameData.finish === 1 || !gameData.aki) return false;\n\n        const sender = normalized.key.participant || from;\n\n        // Verifica se Ã© a pessoa que iniciou o jogo\n        if (gameData.jogador !== sender) return false;\n\n        // Normaliza a resposta do usuÃ¡rio\n        const resposta = text.toLowerCase().trim();\n        let answer = null;\n\n        // Mapeia as respostas para os valores aceitos pela API do Akinator\n        switch (resposta) {\n            case 'sim':\n            case 's':\n                answer = 0; // Yes\n                break;\n            case 'nÃ£o':\n            case 'nao':\n            case 'n':\n                answer = 1; // No\n                break;\n            case 'nÃ£o sei':\n            case 'nao sei':\n            case 'ns':\n                answer = 2; // Don't know\n                break;\n            case 'provavelmente sim':\n            case 'provavel sim':\n            case 'ps':\n                answer = 3; // Probably\n                break;\n            case 'provavelmente nÃ£o':\n            case 'provavelmente nao':\n            case 'provavel nÃ£o':\n            case 'provavel nao':\n            case 'pn':\n                answer = 4; // Probably not\n                break;\n            default:\n                return false; // NÃ£o Ã© uma resposta vÃ¡lida\n        }\n\n        await reagirMensagem(sock, normalized, \"â³\");\n\n        try {\n            const aki = gameData.aki;\n\n            // Envia a resposta para o Akinator\n            await aki.step(answer);\n            gameData.step++;\n\n            // Verifica se o Akinator tem uma resposta/personagem (progresso > 80 ou mais de 78 perguntas)\n            if (aki.progress >= 80 || aki.currentStep >= 78) {\n                await aki.win();\n\n                if (aki.answers && aki.answers.length > 0) {\n                    const personagem = aki.answers[0];\n\n                    // Marca o jogo como finalizado\n                    gameData.finish = 1;\n                    salvarAkinator();\n\n                    // Envia a resposta do Akinator com imagem se disponÃ­vel\n                    const imagemPersonagem = personagem.absolute_picture_path || personagem.picture_path;\n\n                    if (imagemPersonagem && imagemPersonagem !== 'none') {\n                        await sock.sendMessage(from, {\n                            image: { url: imagemPersonagem },\n                            caption: `ğŸ§â€â™‚ï¸ *AKINATOR DESCOBRIU!*\\n\\n` +\n                                    `ğŸ¯ **${personagem.name}**\\n` +\n                                    `ğŸ“ *DescriÃ§Ã£o:* ${personagem.description || 'Personagem descoberto pelo Akinator'}\\n` +\n                                    `ğŸ® *AcurÃ¡cia:* ${Math.round(aki.progress)}%\\n\\n` +\n                                    `âœ¨ O Akinator descobriu em ${aki.currentStep} perguntas!\\n` +\n                                    `ğŸ‰ ParabÃ©ns! Digite *.akinator* para jogar novamente.`,\n                            contextInfo: {\n                                forwardingScore: 100000,\n                                isForwarded: true,\n                                forwardedNewsletterMessageInfo: {\n                                    newsletterJid: \"120363289739581116@newsletter\",\n                                    newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                                },\n                                externalAdReply: {\n                                    title: \"Â© NEEXT LTDA - Akinator\",\n                                    body: \"ğŸ§â€â™‚ï¸ O gÃªnio descobriu!\",\n                                    thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                    mediaType: 1,\n                                    sourceUrl: \"www.neext.online\"\n                                }\n                            }\n                        }, { quoted: normalized });\n                    } else {\n                        await reply(sock, from, `ğŸ§â€â™‚ï¸ *AKINATOR DESCOBRIU!*\\n\\n` +\n                                              `ğŸ¯ **${personagem.name}**\\n` +\n                                              `ğŸ“ *DescriÃ§Ã£o:* ${personagem.description || 'Personagem descoberto pelo Akinator'}\\n` +\n                                              `ğŸ® *AcurÃ¡cia:* ${Math.round(aki.progress)}%\\n\\n` +\n                                              `âœ¨ O Akinator descobriu em ${aki.currentStep} perguntas!\\n` +\n                                              `ğŸ‰ ParabÃ©ns! Digite *.akinator* para jogar novamente.`);\n                    }\n\n                    await reagirMensagem(sock, normalized, \"ğŸ‰\");\n\n                    // Remove o jogo da lista\n                    const gameIndex = akinator.indexOf(gameData);\n                    akinator.splice(gameIndex, 1);\n                    salvarAkinator();\n\n                } else {\n                    await reply(sock, from, \"ğŸ§â€â™‚ï¸ O Akinator nÃ£o conseguiu descobrir desta vez! Digite *.resetaki* para tentar novamente.\");\n                    gameData.finish = 1;\n                    salvarAkinator();\n                }\n            } else {\n                // Continua o jogo com a prÃ³xima pergunta\n                await reply(sock, from, `ğŸ§â€â™‚ï¸ *AKINATOR QUESTIONS:*\\nâ€¢ QuestÃ£o ${aki.currentStep + 1}: *${aki.question}*\\n\\nğŸ’­ *Progresso:* ${Math.round(aki.progress)}%`);\n                await reagirMensagem(sock, normalized, \"ğŸ§â€â™‚ï¸\");\n\n                salvarAkinator();\n            }\n        } catch (akinatorError) {\n            console.error(\"âŒ Erro na API do Akinator:\", akinatorError);\n            await reagirMensagem(sock, normalized, \"âŒ\");\n            await reply(sock, from, \"âŒ Erro na conexÃ£o com o Akinator. Digite *.resetaki* para reiniciar o jogo.\");\n\n            // Remove o jogo da lista em caso de erro\n            const gameIndex = akinator.findIndex(game => game.id === from);\n            if (gameIndex !== -1) {\n                akinator.splice(gameIndex, 1);\n                salvarAkinator();\n            }\n        }\n\n        return true;\n\n    } catch (err) {\n        console.error(\"âŒ Erro ao processar resposta do Akinator:\", err);\n        await reagirMensagem(sock, normalized, \"âŒ\");\n        await reply(sock, from, \"âŒ Erro ao processar sua resposta. Digite *.resetaki* para reiniciar o jogo.\");\n        return true;\n    }\n}\n\n// Cache para armazenar quem fez as Ãºltimas aÃ§Ãµes administrativas\nconst x9ActionCache = new Map();\n\n// Cache para rastrear Ãºltimas atividades de admin (para melhor detecÃ§Ã£o de autor)\nconst adminActivityCache = new Map();\n\n// X9 Monitor - Detecta aÃ§Ãµes administrativas\nasync function processarX9Monitor(sock, groupId, participants, action, author = null) {\n    try {\n        const config = antiSpam.carregarConfigGrupo(groupId);\n        if (!config || !config.x9) return; // X9 nÃ£o estÃ¡ ativo\n        \n        // SÃ³ monitora em grupos\n        if (!groupId.endsWith('@g.us') && !groupId.endsWith('@lid')) return;\n        \n        // ObtÃ©m metadados do grupo para verificar mudanÃ§as de admin\n        const groupMetadata = await sock.groupMetadata(groupId);\n        \n        for (const participant of participants) {\n            const participantInfo = groupMetadata.participants.find(p => p.id === participant);\n            const number = participant.split('@')[0];\n            const name = participantInfo?.notify || number;\n            \n            let autorAction = author; // Usa o autor passado como parÃ¢metro se disponÃ­vel\n            let autorName = \"Sistema\";\n            \n            // Busca quem fez a aÃ§Ã£o no cache se nÃ£o foi passado autor\n            if (!autorAction) {\n                const cacheKey = `${groupId}_${action}_${participant}`;\n                const actionData = x9ActionCache.get(cacheKey);\n                \n                if (actionData && actionData.timestamp > Date.now() - 30000) { // 30 segundos\n                    autorAction = actionData.author;\n                }\n            }\n            \n            // Se ainda nÃ£o tem autor, tenta detectar pelo Ãºltimo admin ativo no grupo\n            if (!autorAction) {\n                const recentActivity = adminActivityCache.get(groupId);\n                if (recentActivity && recentActivity.timestamp > Date.now() - 60000) { // 1 minuto\n                    autorAction = recentActivity.admin;\n                }\n            }\n            \n            // Se encontrou o autor, obtÃ©m o nome\n            if (autorAction) {\n                const autorInfo = groupMetadata.participants.find(p => p.id === autorAction);\n                autorName = autorInfo?.notify || autorAction?.split('@')[0] || \"Admin\";\n                \n                // Log de sucesso\n                console.log(`ğŸ“Š X9: Autor detectado - ${autorName} (${autorAction.split('@')[0]}) fez ${action} em ${number}`);\n            } else {\n                console.log(`âš ï¸ X9: NÃ£o foi possÃ­vel detectar autor para ${action} de ${number} no grupo ${groupId.split('@')[0]}`);\n            }\n            \n            let mensagem = \"\";\n            let emoji = \"\";\n            let mentionedUsers = [participant];\n            \n            if (autorAction) {\n                mentionedUsers.push(autorAction);\n            }\n            \n            switch (action) {\n                case \"promote\":\n                    if (autorAction) {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nğŸ‘‘ **PROMOÃ‡ÃƒO PARA ADMIN**\\n\\nğŸ‘¤ @${number} foi promovido para administrador\\nğŸ‘¨â€ğŸ’¼ **Por:** @${autorAction.split('@')[0]}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando aÃ§Ãµes administrativas...`;\n                    } else {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nğŸ‘‘ **PROMOÃ‡ÃƒO PARA ADMIN**\\n\\nğŸ‘¤ @${number} foi promovido para administrador\\nğŸ‘¨â€ğŸ’¼ **Por:** ${autorName}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando aÃ§Ãµes administrativas...`;\n                    }\n                    emoji = \"ğŸ‘‘\";\n                    break;\n                    \n                case \"demote\":\n                    if (autorAction) {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ¬‡ï¸ **REBAIXAMENTO DE ADMIN**\\n\\nğŸ‘¤ @${number} foi rebaixado de administrador\\nğŸ‘¨â€ğŸ’¼ **Por:** @${autorAction.split('@')[0]}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando aÃ§Ãµes administrativas...`;\n                    } else {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ¬‡ï¸ **REBAIXAMENTO DE ADMIN**\\n\\nğŸ‘¤ @${number} foi rebaixado de administrador\\nğŸ‘¨â€ğŸ’¼ **Por:** ${autorName}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando aÃ§Ãµes administrativas...`;\n                    }\n                    emoji = \"â¬‡ï¸\";\n                    break;\n                    \n                case \"add\":\n                    if (autorAction) {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ• **MEMBRO ADICIONADO**\\n\\nğŸ‘¤ @${number} foi adicionado ao grupo\\nğŸ‘¨â€ğŸ’¼ **Por:** @${autorAction.split('@')[0]}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando entrada de membros...`;\n                    } else {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ• **MEMBRO ADICIONADO**\\n\\nğŸ‘¤ @${number} foi adicionado ao grupo\\nğŸ‘¨â€ğŸ’¼ **Por:** ${autorName}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando entrada de membros...`;\n                    }\n                    emoji = \"â•\";\n                    break;\n                    \n                case \"remove\":\n                    if (autorAction) {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ– **MEMBRO REMOVIDO**\\n\\nğŸ‘¤ @${number} foi removido do grupo\\nğŸ‘¨â€ğŸ’¼ **Por:** @${autorAction.split('@')[0]}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando saÃ­da de membros...`;\n                    } else {\n                        mensagem = `ğŸ“Š *X9 MONITOR DETECTOU*\\n\\nâ– **MEMBRO REMOVIDO**\\n\\nğŸ‘¤ @${number} foi removido do grupo\\nğŸ‘¨â€ğŸ’¼ **Por:** ${autorName}\\nğŸ“± Nome: ${name}\\nâ° HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}\\n\\nğŸ” Monitorando saÃ­da de membros...`;\n                    }\n                    emoji = \"â–\";\n                    break;\n            }\n            \n            if (mensagem) {\n                // Envia notificaÃ§Ã£o do X9 Monitor\n                await sock.sendMessage(groupId, {\n                    text: mensagem,\n                    contextInfo: {\n                        mentionedJid: mentionedUsers,\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ“Šâƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—«ğ“‹ŒğŸ¿ ğ— ğ—¢ğ—¡ğ—œğ—§ğ—¢ğ—¥â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: \"Â© NEEXT LTDA - X9 Monitor\",\n                            body: `${emoji} AÃ§Ã£o detectada no grupo`,\n                            thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 1,\n                            sourceUrl: \"www.neext.online\"\n                        }\n                    }\n                });\n                \n                console.log(`ğŸ“Š X9 MONITOR: ${action} detectado para ${number} no grupo ${groupId} ${autorAction ? 'por ' + autorAction.split('@')[0] : ''}`);\n            }\n            \n            // Limpa o cache apÃ³s usar\n            x9ActionCache.delete(cacheKey);\n        }\n        \n    } catch (err) {\n        console.error(\"âŒ Erro no X9 Monitor:\", err);\n    }\n}\n\n// FunÃ§Ã£o para registrar atividade de admin (para melhor detecÃ§Ã£o de autor)\nasync function registrarAtividadeAdmin(sock, message, from) {\n    try {\n        const config = antiSpam.carregarConfigGrupo(from);\n        if (!config || !config.x9) return; // X9 nÃ£o estÃ¡ ativo\n        \n        // SÃ³ funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return;\n        \n        const sender = message.key.participant || from;\n        \n        // Verifica se quem mandou a mensagem Ã© admin\n        const ehAdmin = await isAdmin(sock, from, sender);\n        if (ehAdmin) {\n            // Registra a Ãºltima atividade do admin neste grupo\n            adminActivityCache.set(from, {\n                admin: sender,\n                timestamp: Date.now()\n            });\n            \n            // Auto-limpa apÃ³s 2 minutos\n            setTimeout(() => {\n                const current = adminActivityCache.get(from);\n                if (current && current.admin === sender && current.timestamp <= Date.now() - 120000) {\n                    adminActivityCache.delete(from);\n                }\n            }, 120000);\n        }\n        \n    } catch (err) {\n        console.error(\"âŒ Erro ao registrar atividade admin:\", err);\n    }\n}\n\n// FunÃ§Ã£o para detectar quem fez aÃ§Ãµes administrativas atravÃ©s de mensagens do sistema\nasync function detectarAutorAcaoX9(sock, message, from) {\n    try {\n        const config = antiSpam.carregarConfigGrupo(from);\n        if (!config || !config.x9) return; // X9 nÃ£o estÃ¡ ativo\n        \n        // SÃ³ funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return;\n        \n        const sender = message.key.participant || from;\n        const texto = getMessageText(message.message);\n        \n        // Detecta mensagens de sistema do WhatsApp sobre mudanÃ§as de admin\n        if (texto.includes('foi promovido') || texto.includes('foi rebaixado') || \n            texto.includes('foi removido') || texto.includes('foi adicionado') ||\n            texto.includes('agora Ã© admin') || texto.includes('nÃ£o Ã© mais admin') ||\n            texto.includes('promoveu') || texto.includes('rebaixou') ||\n            texto.includes('removeu') || texto.includes('adicionou')) {\n            \n            // Extrai o nÃºmero da pessoa que foi afetada\n            const numeroAfetado = texto.match(/@(\\d+)/)?.[1];\n            if (numeroAfetado) {\n                const participantAfetado = numeroAfetado + '@s.whatsapp.net';\n                \n                // Determina a aÃ§Ã£o\n                let action = '';\n                if (texto.includes('agora Ã© admin') || texto.includes('foi promovido') || texto.includes('promoveu')) {\n                    action = 'promote';\n                } else if (texto.includes('nÃ£o Ã© mais admin') || texto.includes('foi rebaixado') || texto.includes('rebaixou')) {\n                    action = 'demote';\n                } else if (texto.includes('foi adicionado') || texto.includes('adicionou')) {\n                    action = 'add';\n                } else if (texto.includes('foi removido') || texto.includes('removeu')) {\n                    action = 'remove';\n                }\n                \n                if (action) {\n                    // Armazena quem fez a aÃ§Ã£o no cache\n                    const cacheKey = `${from}_${action}_${participantAfetado}`;\n                    x9ActionCache.set(cacheKey, {\n                        author: sender,\n                        timestamp: Date.now()\n                    });\n                    \n                    console.log(`ğŸ“Š X9: AÃ§Ã£o ${action} de ${participantAfetado.split('@')[0]} por ${sender.split('@')[0]} armazenada no cache`);\n                    \n                    // Auto-limpa o cache apÃ³s 30 segundos\n                    setTimeout(() => {\n                        x9ActionCache.delete(cacheKey);\n                    }, 30000);\n                }\n            }\n        }\n        \n    } catch (err) {\n        console.error(\"âŒ Erro ao detectar autor da aÃ§Ã£o X9:\", err);\n    }\n}\n\n// Listener de mensagens\nfunction setupListeners(sock) {\n    // Event listener para participantes do grupo (lista negra + X9 Monitor)\n    sock.ev.on(\"group-participants.update\", async (update) => {\n        try {\n            const { id: groupId, participants, action, author } = update;\n            \n            console.log(`ğŸ“Š X9 Event - Grupo: ${groupId.split('@')[0]}, AÃ§Ã£o: ${action}, Participantes: ${participants.map(p => p.split('@')[0]).join(', ')}, Autor: ${author ? author.split('@')[0] : 'nÃ£o detectado'}`);\n            \n            // Processamento da lista negra\n            await processarListaNegra(sock, participants, groupId, action);\n            \n            // Monitoramento X9 de aÃ§Ãµes administrativas com autor detectado\n            await processarX9Monitor(sock, groupId, participants, action, author);\n            \n        } catch (err) {\n            console.error(\"âŒ Erro no event listener de participantes:\", err);\n        }\n    });\n\n    sock.ev.on(\"messages.upsert\", async (msgUpdate) => {\n    const messages = msgUpdate?.messages;\n    if (!messages || !Array.isArray(messages)) return;\n\n    for (const m of messages) {\n        try {\n            if (!m.message) continue;\n            const messageId = `${m.key.remoteJid}-${m.key.id}`;\n            if (processedMessages.has(messageId)) continue;\n            processedMessages.add(messageId);\n\n            const { normalized, quoted } = normalizeMessage(m);\n            const text = getMessageText(normalized.message).trim();\n            normalized.text = text;\n\n            const from = normalized.key.remoteJid;\n\n            // logger central\n            const isCmd = text.startsWith(prefix);\n            logMensagem(normalized, text, isCmd);\n\n            // ğŸ”¹ Detectar aÃ§Ãµes administrativas X9 (antes do anti-spam para capturar o autor)\n            await detectarAutorAcaoX9(sock, normalized, from);\n            \n            // ğŸ”¹ Registrar atividade de admin para X9 Monitor\n            await registrarAtividadeAdmin(sock, normalized, from);\n\n            // ğŸ”¹ VerificaÃ§Ã£o de ANTI-SPAM COMPLETO (antes de tudo)\n            const violacaoDetectada = await processarAntiSpam(sock, normalized);\n            if (violacaoDetectada) continue; // se detectou violaÃ§Ã£o, nÃ£o processa mais nada\n\n            // ğŸ”¹ Processamento do jogo Akinator\n            const akinatorProcessed = await processarRespostaAkinator(sock, text, from, normalized);\n            if (akinatorProcessed) continue; // se processou resposta do Akinator, nÃ£o processa mais nada\n\n            // ğŸ”¹ Palavras-chave sem prefixo\n            const respondeu = await responderPalavrasChave(sock, text, from, normalized);\n            if (respondeu) continue; // se respondeu, nÃ£o processa comandos\n\n            // ğŸ”¹ Comandos com prefixo\n            if (isCmd) {\n                const [cmd, ...args] = text.slice(prefix.length).trim().split(/ +/);\n                const command = cmd.toLowerCase();\n\n                // ğŸ”¹ VerificaÃ§Ã£o de registro (exceto para comando \"rg\")\n                if (command !== \"rg\") {\n                    const sender = normalized.key.participant || from;\n                    const numeroUsuario = sender.split('@')[0];\n                    \n                    if (!registros.usuarioRegistrado(numeroUsuario)) {\n                        await reagirMensagem(sock, normalized, \"ğŸš«\");\n                        await reply(sock, from, `ğŸš« *ACESSO NEGADO!*\\n\\nâŒ VocÃª nÃ£o estÃ¡ registrado no sistema!\\n\\nğŸ“ Para se registrar, digite:\\n\\`\\`\\`${prefix}rg\\`\\`\\`\\n\\nâš ï¸ Apenas usuÃ¡rios registrados podem usar o bot!`, [sender]);\n                        continue; // NÃ£o processa o comando se nÃ£o estiver registrado\n                    }\n                }\n\n                try {\n                    await handleCommand(sock, normalized, command, args, from, quoted);\n                } catch (err) {\n                    console.error(`âŒ Erro no comando \"${command}\":`, err);\n                    await reply(sock, from, \"âŒ Comando falhou. Tente novamente.\");\n                }\n            }\n\n            // ğŸ”¹ /s sem prefixo (comando especial)\n            else if (text.startsWith(\"/s\")) {\n                try {\n                    // ğŸ”¹ VerificaÃ§Ã£o de registro para comando /s\n                    const sender = normalized.key.participant || from;\n                    const numeroUsuario = sender.split('@')[0];\n                    \n                    if (!registros.usuarioRegistrado(numeroUsuario)) {\n                        await reagirMensagem(sock, normalized, \"ğŸš«\");\n                        await reply(sock, from, `ğŸš« *ACESSO NEGADO!*\\n\\nâŒ VocÃª nÃ£o estÃ¡ registrado no sistema!\\n\\nğŸ“ Para se registrar, digite:\\n\\`\\`\\`${prefix}rg\\`\\`\\`\\n\\nâš ï¸ Apenas usuÃ¡rios registrados podem usar o bot!`, [sender]);\n                        continue;\n                    }\n\n                    // Verifica se tem mÃ­dia marcada ou na prÃ³pria mensagem\n                    const quotedMsg = normalized.message.extendedTextMessage?.contextInfo?.quotedMessage;\n                    const hasQuotedMedia = quotedMsg && (quotedMsg.imageMessage || quotedMsg.videoMessage);\n                    const hasDirectMedia = normalized.message.imageMessage || normalized.message.videoMessage;\n\n                    if (hasQuotedMedia || hasDirectMedia) {\n                        await handleCommand(sock, normalized, \"s\", [], from, quoted);\n                    } else {\n                        await reagirMensagem(sock, normalized, \"âŒ\");\n                        await reply(sock, from, \"âŒ Para usar /s vocÃª precisa:\\nâ€¢ Marcar uma imagem/vÃ­deo e digitar /s\\nâ€¢ Ou enviar uma imagem/vÃ­deo com legenda /s\");\n                    }\n                } catch (err) {\n                    console.error(\"âŒ Erro no comando /s:\", err);\n                    await reply(sock, from, \"âŒ Erro ao processar comando /s\");\n                }\n            }\n\n        } catch (err) {\n            console.error(`âŒ Erro ao processar ${m.key.id}:`, err);\n            try { \n                await sock.sendMessage(m.key.remoteJid, { text: \"âŒ Erro interno. Tente novamente.\" }, { quoted: m }); \n            } catch (e) { \n                console.error(\"Falha ao enviar erro:\", e); \n            }\n        }\n    }\n});\n    console.log(\"âœ… Listener de mensagens ATIVADO â€” processando TUDO (inclusive fromMe).\");\n}\n\n// Exporta para iniciar no arquivo principal de conexÃ£o\nmodule.exports = { handleCommand, setupListeners };","size_bytes":151315},"main.js":{"content":"#!/usr/bin/env node\n\n/**\n * WhatsApp Bot - Main Entry Point\n * This file handles the bot startup with proper error handling and reconnection logic\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Console colors for better output\nconst colors = {\n    reset: '\\x1b[0m',\n    bright: '\\x1b[1m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m'\n};\n\nfunction log(message, color = colors.reset) {\n    console.log(`${color}${message}${colors.reset}`);\n}\n\nfunction logError(error) {\n    console.error(`${colors.red}âŒ ERROR: ${error.message}${colors.reset}`);\n    if (process.env.DEBUG) {\n        console.error(error.stack);\n    }\n}\n\nfunction logInfo(message) {\n    log(`${colors.blue}â„¹ï¸  ${message}`, colors.blue);\n}\n\nfunction logSuccess(message) {\n    log(`${colors.green}âœ… ${message}`, colors.green);\n}\n\nfunction logWarning(message) {\n    log(`${colors.yellow}âš ï¸  ${message}`, colors.yellow);\n}\n\nfunction ensureDirectoryExists(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        logInfo(`Created directory: ${dir}`);\n    }\n}\n\nfunction validateDependencies() {\n    const requiredDeps = [\n        '@whiskeysockets/baileys',\n        'axios',\n        'fs',\n        'path'\n    ];\n    \n    const packageJson = require('./package.json');\n    const installedDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };\n    \n    for (const dep of requiredDeps) {\n        if (!installedDeps[dep] && dep !== 'fs' && dep !== 'path') {\n            throw new Error(`Required dependency \"${dep}\" is not installed. Run: npm install ${dep}`);\n        }\n    }\n    logSuccess('All dependencies validated');\n}\n\nasync function startBot() {\n    try {\n        logInfo('Starting WhatsApp Bot...');\n        \n        // Validate environment\n        validateDependencies();\n        \n        // Ensure connection directory exists\n        ensureDirectoryExists('./conexao');\n        \n        // Start the actual bot\n        require('./connect.js');\n        \n    } catch (error) {\n        logError(error);\n        process.exit(1);\n    }\n}\n\n// Handle process signals gracefully\nprocess.on('SIGINT', () => {\n    logWarning('Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    logWarning('Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logError(error);\n    logError(new Error('Uncaught Exception - Bot will restart'));\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    logError(new Error(`Unhandled Rejection at: ${promise}, reason: ${reason}`));\n    logError(new Error('Unhandled Promise Rejection - Bot will restart'));\n    process.exit(1);\n});\n\n// Start the bot\nstartBot();","size_bytes":2873},"replit.md":{"content":"# WhatsApp Bot - NEEXT LTDA\n\n## VisÃ£o Geral\nBot WhatsApp automatizado construÃ­do com Baileys, com sistema de antilink avanÃ§ado e funcionalidades de administraÃ§Ã£o de grupos.\n\n## Funcionalidades Principais\n\n### ğŸ¤– Comandos do Bot\n- **`.ping`** - Verifica status do bot e informaÃ§Ãµes do sistema\n- **`.hora`** - Mostra horÃ¡rio atual\n- **`.dono`** - Identifica o dono do bot\n- **`.marca`** - Menciona todos os membros do grupo (apenas em grupos)\n- **`.recado`** - Confirma que bot estÃ¡ ativo\n- **`.s`** - Converte imagem/vÃ­deo para sticker\n- **`.hermitwhite`** - Cria ID no sistema NEEXT (requer dados pessoais)\n- **`prefixo`** - Mostra o prefixo do bot (sem prefixo)\n\n### âš¡ Comandos Administrativos\n**Comandos exclusivos para administradores que exigem que o bot tambÃ©m seja admin:**\n\n#### ğŸ”’ Controle do Grupo\n- **`.fechargrupo`** ou **`.fechar`** - Fecha o grupo (apenas admins podem enviar mensagens)\n- **`.abrirgrupo`** ou **`.abrir`** - Abre o grupo (todos podem enviar mensagens)\n- **`.soloadmin`** ou **`.adminonly`** - Permite apenas admins editarem informaÃ§Ãµes do grupo\n\n#### ğŸ—‘ï¸ ModeraÃ§Ã£o de Mensagens\n- **`.delmsg`**, **`.del`** ou **`.delete`** - Deleta mensagem marcada (use respondendo a uma mensagem)\n\n#### ğŸ”— Gerenciamento de Link\n- **`.resetlink`**, **`.resetarlink`** ou **`.novolink`** - Gera novo link de convite e invalida o anterior\n\n#### ğŸ‘¥ Controle de Entrada\n- **`.ativarsolicitacao`**, **`.ativarjoin`** ou **`.reqon`** - Ativa aprovaÃ§Ã£o obrigatÃ³ria para novos membros\n- **`.desativarsolicitacao`**, **`.desativarjoin`** ou **`.reqoff`** - Desativa aprovaÃ§Ã£o obrigatÃ³ria\n\n#### âœï¸ EdiÃ§Ã£o do Grupo\n- **`.mudargrupo`**, **`.mudarnome`** ou **`.renamegroup [nome]`** - Altera o nome do grupo\n\n**Requisitos:**\n- âœ… UsuÃ¡rio deve ser admin do grupo\n- âœ… Bot deve ser admin do grupo\n- âœ… Funciona apenas em grupos\n- âš ï¸ Se o bot nÃ£o for admin, serÃ¡ exibido aviso especÃ­fico\n\n### ğŸ†” Sistema de CriaÃ§Ã£o de ID - NEEXT\nComando para criar IDs Ãºnicos no sistema da NEEXT LTDA:\n\n#### Como Usar:\n- **`.hermitwhite [nome] [idade] [telefone] [instagram] [email]`** - Cria um novo ID\n\n#### Exemplo:\n```\n.hermitwhite JoÃ£o Silva 25 5527999999999 @joao_silva joao@gmail.com\n```\n\n#### ValidaÃ§Ãµes:\n- âœ… Todos os campos sÃ£o obrigatÃ³rios\n- âœ… Instagram deve incluir o @ (ex: @usuario)\n- âœ… Telefone deve ter 10-15 dÃ­gitos (ex: 5527999999999)\n- âœ… Email deve ser vÃ¡lido (ex: usuario@provedor.com)\n\n#### Recursos:\n- âœ… IntegraÃ§Ã£o com API Google Sheets\n- âœ… GeraÃ§Ã£o automÃ¡tica de ID sequencial\n- âœ… ValidaÃ§Ã£o completa de dados\n- âœ… Mensagem de confirmaÃ§Ã£o com ID gerado\n- âœ… Tratamento de erros robusto\n\n### ğŸ® Jogo Akinator\nSistema de jogo interativo do Akinator (gÃªnio da lÃ¢mpada):\n\n#### Como Usar:\n- **`.akinator`** - Inicia uma nova partida do jogo\n- **`.resetaki`** - Reseta/cancela a partida atual\n\n#### Como Jogar:\n1. Digite `.akinator` em um grupo para iniciar\n2. Responda as perguntas com: **Sim**, **NÃ£o**, **NÃ£o sei**, **Provavelmente sim** ou **Provavelmente nÃ£o**\n3. O Akinator tentarÃ¡ adivinhar o personagem que vocÃª estÃ¡ pensando\n4. Use `.resetaki` para cancelar o jogo a qualquer momento\n\n#### Recursos:\n- âœ… Funciona apenas em grupos\n- âœ… Uma partida por grupo por vez\n- âœ… Controle de acesso por jogador\n- âœ… Limite de uma partida por dia\n- âœ… Sistema de reset para admins e quem iniciou o jogo\n- âœ… Respostas inteligentes em portuguÃªs\n- âš ï¸ API pode estar sujeita a limitaÃ§Ãµes de Cloudflare\n\n### ğŸ›¡ï¸ Sistema Antilink\nSistema completo de proteÃ§Ã£o contra links em grupos:\n\n#### Como Usar:\n- **`.antilink on`** - Ativa antilink no grupo\n- **`.antilink off`** - Desativa antilink no grupo\n- **`.antilink`** - Verifica status atual\n\n#### Recursos:\n- âœ… Detecta automaticamente links em mensagens\n- âœ… Remove mensagens com links instantaneamente\n- âœ… Protege admins e dono (nÃ£o remove suas mensagens)\n- âœ… ConfiguraÃ§Ã£o por grupo (salva em JSON)\n- âœ… Apenas admins podem ativar/desativar\n- âœ… Feedback visual com reaÃ§Ãµes e mensagens\n\n#### Links Detectados:\n- URLs com http/https\n- Links do WhatsApp (wa.me, chat.whatsapp.com)\n- Redes sociais (Instagram, Facebook, Twitter, TikTok, YouTube)\n- Telegram (t.me)\n- Discord (discord.gg)\n- E muito mais...\n\n### ğŸ”§ ConfiguraÃ§Ãµes\nAs configuraÃ§Ãµes do bot estÃ£o em `settings/settings.json`:\n- **prefix**: Prefixo dos comandos (padrÃ£o: \".\")\n- **nomeDoBot**: Nome do bot\n- **numeroDoDono**: NÃºmero do dono do bot\n- **nickDoDono**: Apelido do dono\n\n### ğŸ“ Estrutura do Projeto\n- `main.js` - Script principal com tratamento de erros\n- `connect.js` - Gerenciamento de conexÃ£o WhatsApp\n- `index.js` - LÃ³gica do bot e comandos\n- `settings/settings.json` - ConfiguraÃ§Ãµes do bot\n- `arquivos/` - FunÃ§Ãµes utilitÃ¡rias e assets\n- `conexao/` - Arquivos de sessÃ£o WhatsApp (auto-gerados)\n\n### ğŸš€ Como Executar\nO bot Ã© executado automaticamente via Workflow do Replit:\n1. Conecta automaticamente ao WhatsApp\n2. Se primeira vez, solicita mÃ©todo de conexÃ£o (QR Code ou Pareamento)\n3. Processa mensagens e comandos em tempo real\n\n### ğŸ“Š Logs e Monitoramento\n- Logs detalhados de todas as mensagens processadas\n- IdentificaÃ§Ã£o de comandos vs mensagens normais\n- Rastreamento de aÃ§Ãµes do antilink\n- Tratamento de erros robusto\n\n### ğŸ” SeguranÃ§a\n- Arquivos de sessÃ£o excluÃ­dos do Git\n- VerificaÃ§Ã£o de permissÃµes para comandos administrativos\n- ProteÃ§Ã£o contra spam com cache de mensagens processadas\n\n## AlteraÃ§Ãµes Recentes\n- âœ… Implementado sistema completo de antilink\n- âœ… Adicionadas verificaÃ§Ãµes de admin e dono\n- âœ… Criado sistema de configuraÃ§Ã£o por grupo\n- âœ… Melhorado tratamento de erros\n- âœ… Adicionadas reaÃ§Ãµes visuais aos comandos\n- âœ… Configurado para funcionar no ambiente Replit\n- âœ… Melhorada implementaÃ§Ã£o do comando Pinterest\n- âœ… Instaladas todas as dependÃªncias necessÃ¡rias\n- âœ… **NOVO**: Implementado jogo do Akinator com aki-api\n- âœ… **NOVO**: Adicionados comandos .akinator e .resetaki\n- âœ… **NOVO**: Sistema de gestÃ£o de partidas por grupo\n- âœ… **NOVO**: Processamento inteligente de respostas do usuÃ¡rio\n- âœ… **NOVO**: Estrutura de banco de dados para jogos\n- âœ… **RECENTE**: Implementados 8 comandos administrativos completos\n- âœ… **RECENTE**: Sistema automÃ¡tico de contagem de comandos\n- âœ… **RECENTE**: Controle total de grupos (abrir/fechar/resetar link)\n- âœ… **RECENTE**: ModeraÃ§Ã£o avanÃ§ada (deletar mensagens, controlar entrada)\n- âœ… **RECENTE**: VerificaÃ§Ãµes robustas de permissÃµes admin\n\n## Estado Atual\nâœ… **Bot Online e Funcionando no Replit**\nâœ… **Antilink Implementado e Testado**\nâœ… **Todos os Comandos Operacionais**\nâœ… **Comando Pinterest Melhorado**\nâœ… **Workflow Configurado e Rodando**\nâœ… **DependÃªncias Instaladas e Funcionando**\nâœ… **Stickers com Selinho Quotado Implementado**\nâœ… **Deployment Configurado para ProduÃ§Ã£o (VM)**\nâœ… **Bot Conectado e Processando Comandos Ativamente**\n\n### ğŸš€ Ambiente de ProduÃ§Ã£o\n- **Deployment Target**: VM (para conexÃ£o persistente)\n- **Comando de ProduÃ§Ã£o**: `node main.js`\n- **Status**: Pronto para deploy","size_bytes":7126},"start.sh":{"content":"#!/bin/bash\n\nGREEN='\\033[1;32m'\nBLUE='\\033[0;34m'\n\nwhile :\ndo\n    # Texto de conexÃ£o\n    printf \"${BLUE} NEEXT LTDA ğ‚ğğğ„ğ‚ğ“ğ€ğğƒğ, ğ€ğ†ğ”ğ€ğ‘ğƒğ„\\n\"\n\n    # Chama index.js com parÃ¢metro opcional\n    if [ \"$1\" = \"sim\" ]; then\n        node index.js sim\n    elif [ \"$1\" = \"nÃ£o\" ]; then\n        node connect.js nÃ£o\n    else\n        node connect.js\n    fi\n\n    # Texto de inicializaÃ§Ã£o\n    printf \"${GREEN}ã€ NEEXT LTDA ã€ğˆğğˆğ‚ğˆğ€ğğƒğ  ğğğ•ğ€ğŒğ„ğğ“ğ„\\n\"\n\n    sleep 1\ndone","size_bytes":560},"arquivos/exif.js":{"content":"const fs = require('fs');\nconst { writeExif } = require('./sticker.js');\n\n// FunÃ§Ã£o para converter imagem para WebP\nasync function imageToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a funÃ§Ã£o existente do sticker.js\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter imagem para WebP:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para converter vÃ­deo para WebP\nasync function videoToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a funÃ§Ã£o existente do sticker.js para vÃ­deos\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter vÃ­deo para WebP:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para escrever EXIF em imagens com dados personalizados\nasync function writeExifImg(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuÃ¡rio\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF na imagem:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para escrever EXIF em vÃ­deos com dados personalizados\nasync function writeExifVid(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuÃ¡rio\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF no vÃ­deo:', error);\n        console.log('ğŸ”„ Tentando processar como imagem estÃ¡tica...');\n        \n        // Fallback: tenta processar como imagem se falhar como vÃ­deo\n        try {\n            const packname = options.packname;\n            const author = options.author;\n            const media = { data: buffer, mimetype: 'image/webp' };\n            const metadata = { packname, author, _isRename: true };\n            return await writeExif(media, metadata);\n        } catch (fallbackError) {\n            console.error('âŒ Fallback tambÃ©m falhou:', fallbackError);\n            throw error; // LanÃ§a o erro original\n        }\n    }\n}\n\nmodule.exports = {\n    imageToWebp,\n    videoToWebp,\n    writeExifImg,\n    writeExifVid\n};","size_bytes":3027},"arquivos/rename.js":{"content":"const fs = require('fs-extra');\nconst {\nimageToWebp,\nvideoToWebp,\nwriteExifImg,\nwriteExifVid\n} = require('./exif');\nconst {\ngetBuffer\n} = require('./funcoes/function.js');\n\n// Selinho para usar como quoted nos stickers\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\n\nconst sendImageAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifImg para preservar metadados personalizados\n buffer = await writeExifImg(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, {\n    sticker: {url: buffer}, \n    contextInfo: contextAnuncio,\n    ...options\n}, {quoted: selinho})\nreturn buffer;\n};\n\n\n\nconst sendVideoAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifVid para preservar metadados personalizados\n buffer = await writeExifVid(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, { \n    sticker: { url: buffer }, \n    contextInfo: contextAnuncio,\n    ...options \n}, { quoted: selinho })\nreturn buffer;\n}\n\nmodule.exports = {\nsendVideoAsSticker,\nsendImageAsSticker\n};","size_bytes":2586},"arquivos/sticker.js":{"content":"const fs = require(\"fs\");\nconst { tmpdir } = require(\"os\");\nconst path = require(\"path\");\nconst Crypto = require(\"crypto\");\nconst ff = require(\"fluent-ffmpeg\");\nconst webp = require(\"node-webpmux\");\n\n// Gera arquivo temporÃ¡rio\nfunction getRandomFile(ext) {\n    return path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}${ext}`);\n}\n\n// Converte Buffer para WebP preservando transparÃªncia\nasync function bufferToWebp(buffer, isVideo = false, mimetype = null) {\n    // Detecta extensÃ£o correta baseada no mimetype para preservar transparÃªncia\n    let inputExt;\n    if (isVideo) {\n        inputExt = \".mp4\";\n    } else if (mimetype) {\n        if (mimetype.includes('png')) inputExt = \".png\";\n        else if (mimetype.includes('webp')) inputExt = \".webp\";\n        else if (mimetype.includes('gif')) inputExt = \".gif\";\n        else inputExt = \".jpg\";\n    } else {\n        inputExt = \".jpg\";\n    }\n\n    const input = getRandomFile(inputExt);\n    const output = getRandomFile(\".webp\");\n\n    fs.writeFileSync(input, buffer);\n\n    await new Promise((resolve, reject) => {\n        const ffmpegCommand = ff(input)\n            .on(\"error\", (err) => {\n                // Cleanup input file on error\n                if (fs.existsSync(input)) fs.unlinkSync(input);\n                reject(err);\n            })\n            .on(\"end\", () => resolve());\n\n        if (isVideo) {\n            // Para vÃ­deos: mÃ¡ximo 6 segundos, 512px, preserva transparÃªncia\n            ffmpegCommand\n                .duration(6)\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"fps=15,scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"80\",\n                    \"-lossless\", \"0\"\n                ]);\n        } else {\n            // Para imagens: 512px, preserva transparÃªncia, sem fps\n            ffmpegCommand\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"90\"\n                ]);\n        }\n\n        ffmpegCommand\n            .toFormat(\"webp\")\n            .save(output);\n    });\n\n    // Cleanup input file\n    if (fs.existsSync(input)) fs.unlinkSync(input);\n    return output;\n}\n\n// FunÃ§Ã£o writeExif para compatibilidade com index.js\nasync function writeExif(media, metadata) {\n    const { mimetype, data } = media;\n    \n    // Para comando RENAME: usa EXATAMENTE os valores fornecidos sem fallbacks\n    // Para outros comandos: usa fallbacks NEEXT se nÃ£o houver valores\n    let packname, author, categories;\n    \n    if (metadata._isRename) {\n        // Comando rename: usa APENAS os valores fornecidos pelo usuÃ¡rio\n        packname = metadata.packname;\n        author = metadata.author;\n        categories = metadata.categories || [\"ğŸ˜\"];\n    } else {\n        // Outros comandos: pode usar fallbacks NEEXT\n        packname = metadata.packname || \"NEEXT LTDA\";\n        author = metadata.author || \"NEEXT BOT\";\n        categories = metadata.categories || [\"ğŸ˜\"];\n    }\n    \n    // Detecta se Ã© vÃ­deo/GIF\n    const isVideo = mimetype && (\n        mimetype.includes('video') || \n        mimetype.includes('gif') ||\n        mimetype === 'image/gif'\n    );\n    \n    const webpFile = await bufferToWebp(data, isVideo, mimetype);\n    const img = new webp.Image();\n    await img.load(webpFile);\n\n    const json = {\n        \"sticker-pack-id\": `${packname}-${Date.now()}`,\n        \"sticker-pack-name\": packname,\n        \"sticker-pack-publisher\": author,\n        \"sticker-pack-categories\": categories\n    };\n\n    const exifAttr = Buffer.from([0x49,0x49,0x2A,0x00,0x08,0x00,0x00,0x00,0x01,0x00,0x41,0x57,0x07,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00]);\n    const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\");\n    const exif = Buffer.concat([exifAttr, jsonBuff]);\n    exif.writeUIntLE(jsonBuff.length, 14, 4);\n\n    img.exif = exif;\n    await img.save(webpFile);\n\n    return webpFile;\n}\n\n// Cria sticker e envia (versÃ£o melhorada)\nasync function createSticker(buffer, sock, from, isVideo = false) {\n    try {\n        const agora = new Date();\n        const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n        \n        const webpFile = await writeExif(\n            { mimetype: isVideo ? 'video/mp4' : 'image/jpeg', data: buffer },\n            { \n                packname: \"NEEXT LTDA\", \n                author: `NEEXT BOT - ${dataHora}`, \n                categories: [\"ğŸ”¥\"] \n            }\n        );\n        \n        const stickerBuffer = fs.readFileSync(webpFile);\n        await sock.sendMessage(from, { sticker: stickerBuffer });\n        fs.unlinkSync(webpFile);\n        \n        console.log(\"âœ… Figurinha criada com sucesso!\");\n    } catch (err) {\n        console.log(\"âŒ Erro ao criar figurinha:\", err);\n        await sock.sendMessage(from, { text: \"âŒ Erro ao criar figurinha.\" });\n    }\n}\n\nmodule.exports = { createSticker, writeExif };","size_bytes":5439},"menus/menu.js":{"content":"","size_bytes":0},"arquivos/funcoes/function.js":{"content":"// ---------------------------\n// Pacotes\n// ---------------------------\nconst cfonts = require(\"cfonts\");\n\n// ---------------------------\n// ConfiguraÃ§Ãµes do Bot\n// ---------------------------\nconst settings = require(\"../../settings/settings.json\");\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// ---------------------------\n// Banner do bot\n// ---------------------------\nfunction mostrarBanner() {\n    console.clear();\n\n    // NEEXT em roxo sÃ³lido\n    cfonts.say(\"NEEXT\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    // LTDA em roxo sÃ³lido\n    cfonts.say(\"LTDA\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    console.log(\"\\n\");\n}\n\n// ---------------------------\n// Logs simples (sem duplicaÃ§Ã£o e sem criar arquivos)\n// ---------------------------\nconst mensagensRegistradas = new Set();\n\nfunction logMensagem(m, text = \"\", isCommand = false) {\n    const fromMe = m?.key?.fromMe || false;\n    const jid = m?.key?.remoteJid || \"\";\n    const isGroup = jid.endsWith(\"@g.us\") || jid.endsWith(\"@lid\");\n    const sender = (m?.key?.participant || jid)?.split(\"@\")[0] || \"desconhecido\";\n    const pushName = m?.pushName || \"Sem nome\";\n\n    const conteudo = text || (() => {\n        if (m?.message?.conversation) return m.message.conversation;\n        if (m?.message?.extendedTextMessage?.text) return m.message.extendedTextMessage.text;\n        if (m?.message?.imageMessage?.caption) return m.message.imageMessage.caption;\n        if (m?.message?.videoMessage?.caption) return m.message.videoMessage.caption;\n        return \"[conteÃºdo nÃ£o suportado]\";\n    })();\n\n    // Evita duplicaÃ§Ã£o\n    const logKey = `${fromMe}-${jid}-${conteudo}`;\n    if (mensagensRegistradas.has(logKey)) return;\n    mensagensRegistradas.add(logKey);\n\n    const tipo = isCommand || (conteudo.startsWith(prefix)) ? \"[COMANDO]\" : \"[MENSAGEM]\";\n    const local = isGroup ? \"GRUPO\" : \"PV\";\n    const remetente = `${pushName} (${sender})${fromMe ? \" [EU]\" : \"\"}`;\n\n    const logText = `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n${tipo} ${local}\nDe: ${remetente}\nConteÃºdo: ${conteudo}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;\n\n    console.log(logText);\n}\n\n// ---------------------------\n// FunÃ§Ã£o para buscar buffer de URL\n// ---------------------------\nasync function getBuffer(url) {\n    try {\n        const response = await require('axios').get(url, { responseType: 'arraybuffer' });\n        return Buffer.from(response.data);\n    } catch (error) {\n        console.error('Erro ao buscar buffer da URL:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para formatar JID\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\n// ---------------------------\n// FunÃ§Ã£o para saudaÃ§Ã£o baseada no horÃ¡rio\n// ---------------------------\nfunction obterSaudacao() {\n    const hora = new Date().getHours();\n    \n    if (hora >= 6 && hora < 12) {\n        return \"ğŸŒ… Bom dia\";\n    } else if (hora >= 12 && hora < 18) {\n        return \"â˜€ï¸ Boa tarde\";\n    } else if (hora >= 18 && hora < 24) {\n        return \"ğŸŒ™ Boa noite\";\n    } else {\n        return \"ğŸŒƒ Boa madrugada\";\n    }\n}\n\n// ---------------------------\n// FunÃ§Ã£o para contar grupos\n// ---------------------------\nasync function contarGrupos(sock) {\n    try {\n        const grupos = await sock.groupFetchAllParticipating();\n        return Object.keys(grupos).length;\n    } catch (error) {\n        console.error('Erro ao contar grupos:', error);\n        return 0;\n    }\n}\n\n// ---------------------------\n// FunÃ§Ã£o para contar comandos automaticamente\n// ---------------------------\nfunction contarComandos() {\n    try {\n        const fs = require('fs');\n        const path = require('path');\n        \n        // LÃª o arquivo index.js\n        const indexPath = path.join(__dirname, '../../index.js');\n        const indexContent = fs.readFileSync(indexPath, 'utf8');\n        \n        // Procura por todos os cases no switch da funÃ§Ã£o handleCommand\n        const casePattern = /case\\s+\"([^\"]+)\"/g;\n        const matches = [];\n        let match;\n        \n        while ((match = casePattern.exec(indexContent)) !== null) {\n            // Evita duplicatas e ignora cases internos como break cases\n            if (!matches.includes(match[1])) {\n                matches.push(match[1]);\n            }\n        }\n        \n        console.log(`ğŸ“Š Total de comandos encontrados automaticamente: ${matches.length}`);\n        return matches.length;\n    } catch (error) {\n        console.error('âŒ Erro ao contar comandos automaticamente:', error);\n        // Fallback para contagem manual se houver erro\n        return 25; // estimativa atual\n    }\n}\n\n// ---------------------------\n// ExportaÃ§Ãµes\n// ---------------------------\nmodule.exports = {\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n    getBuffer,\n    obterSaudacao,\n    contarGrupos,\n    contarComandos\n};","size_bytes":5296},"arquivos/antispam.js":{"content":"// Sistema Anti-Spam Completo para WhatsApp Bot\nconst fs = require('fs');\nconst path = require('path');\n\n// DiretÃ³rios do sistema\nconst GRUPOS_DIR = path.join(__dirname, '../database/grupos/ativadogrupo');\nconst CACHE_FLOOD = new Map(); // Cache para controle de flood\n\n// UtilitÃ¡rios\nfunction formatGroupId(groupId) {\n    return groupId.replace('@g.us', '').replace('@lid', '').replace(/[^a-zA-Z0-9]/g, '_');\n}\n\n// Verifica se nÃºmero Ã© brasileiro\nfunction isNumeroBrasileiro(jid) {\n    if (!jid || typeof jid !== 'string') return false;\n    \n    // Remove o @s.whatsapp.net para pegar apenas o nÃºmero\n    const numero = jid.replace('@s.whatsapp.net', '');\n    \n    // Verifica se comeÃ§a com 55 (cÃ³digo do Brasil)\n    // Formatos aceitos: 55XXXXXXXXXXX (13 dÃ­gitos) ou 5511XXXXXXXXX (12 dÃ­gitos para alguns casos)\n    const brasileiroRegex = /^55[1-9][0-9]{8,9}$/;\n    \n    return brasileiroRegex.test(numero);\n}\n\nfunction getGroupConfigPath(groupId) {\n    const formattedId = formatGroupId(groupId);\n    return path.join(GRUPOS_DIR, `${formattedId}.json`);\n}\n\n// Carrega configuraÃ§Ã£o de um grupo\nfunction carregarConfigGrupo(groupId) {\n    try {\n        const configPath = getGroupConfigPath(groupId);\n        if (!fs.existsSync(configPath)) {\n            return {\n                antilink: false,\n                anticontato: false,\n                antidocumento: false,\n                antivideo: false,\n                antiaudio: false,\n                antisticker: false,\n                antiflod: false,\n                antifake: false,\n                x9: false,\n                modogamer: false,\n                listanegra: [],\n                floodConfig: {\n                    maxMensagens: 5,\n                    tempoSegundos: 10\n                }\n            };\n        }\n        const data = fs.readFileSync(configPath, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(`âŒ Erro ao carregar config do grupo ${groupId}:`, err);\n        return null;\n    }\n}\n\n// Salva configuraÃ§Ã£o de um grupo\nfunction salvarConfigGrupo(groupId, config) {\n    try {\n        // Garante que o diretÃ³rio existe\n        if (!fs.existsSync(GRUPOS_DIR)) {\n            fs.mkdirSync(GRUPOS_DIR, { recursive: true });\n        }\n        \n        const configPath = getGroupConfigPath(groupId);\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n        return true;\n    } catch (err) {\n        console.error(`âŒ Erro ao salvar config do grupo ${groupId}:`, err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Verifica se Ã© contact/contato\nfunction isContactMessage(message) {\n    return !!(message.contactMessage || message.contactsArrayMessage);\n}\n\n// Verifica se Ã© documento\nfunction isDocumentMessage(message) {\n    return !!(message.documentMessage);\n}\n\n// Verifica se Ã© vÃ­deo\nfunction isVideoMessage(message) {\n    return !!(message.videoMessage);\n}\n\n// Verifica se Ã© Ã¡udio\nfunction isAudioMessage(message) {\n    return !!(message.audioMessage || message.pttMessage);\n}\n\n// Verifica se Ã© sticker\nfunction isStickerMessage(message) {\n    return !!(message.stickerMessage);\n}\n\n// Controle de flood\nfunction verificarFlood(userId, groupId, config) {\n    if (!config.antiflod) return false;\n    \n    const key = `${groupId}_${userId}`;\n    const agora = Date.now();\n    const limite = config.floodConfig.tempoSegundos * 1000;\n    \n    if (!CACHE_FLOOD.has(key)) {\n        CACHE_FLOOD.set(key, []);\n    }\n    \n    const mensagens = CACHE_FLOOD.get(key);\n    \n    // Remove mensagens antigas\n    const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < limite);\n    \n    // Adiciona nova mensagem\n    mensagensRecentes.push(agora);\n    CACHE_FLOOD.set(key, mensagensRecentes);\n    \n    // Verifica se excedeu o limite\n    return mensagensRecentes.length > config.floodConfig.maxMensagens;\n}\n\n// Limpa cache de flood periodicamente\nsetInterval(() => {\n    const agora = Date.now();\n    for (const [key, mensagens] of CACHE_FLOOD.entries()) {\n        const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < 60000); // 1 minuto\n        if (mensagensRecentes.length === 0) {\n            CACHE_FLOOD.delete(key);\n        } else {\n            CACHE_FLOOD.set(key, mensagensRecentes);\n        }\n    }\n}, 60000);\n\n// Verifica se usuÃ¡rio estÃ¡ na lista negra\nfunction isUsuarioListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    return config.listanegra.includes(userId);\n}\n\n// Adiciona usuÃ¡rio Ã  lista negra\nfunction adicionarListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    if (!config.listanegra) config.listanegra = [];\n    \n    if (!config.listanegra.includes(userId)) {\n        config.listanegra.push(userId);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // JÃ¡ estava na lista\n}\n\n// Remove usuÃ¡rio da lista negra\nfunction removerListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    \n    const index = config.listanegra.indexOf(userId);\n    if (index > -1) {\n        config.listanegra.splice(index, 1);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // NÃ£o estava na lista\n}\n\n// Ativa/desativa funcionalidade anti\nfunction toggleAntiFeature(groupId, feature, estado) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    const validFeatures = ['antilink', 'anticontato', 'antidocumento', 'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'x9'];\n    \n    if (!validFeatures.includes(feature)) return false;\n    \n    if (estado === 'on' || estado === 'ativar' || estado === '1') {\n        config[feature] = true;\n    } else if (estado === 'off' || estado === 'desativar' || estado === '0') {\n        config[feature] = false;\n    } else {\n        return config[feature]; // Retorna estado atual\n    }\n    \n    return salvarConfigGrupo(groupId, config) ? config[feature] : false;\n}\n\n// Processa mensagem para verificar violaÃ§Ãµes\nfunction processarMensagem(message, groupId, userId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return { violacao: false };\n    \n    const violations = [];\n    \n    // Extrai texto da mensagem\n    let texto = '';\n    if (message.conversation) texto = message.conversation;\n    if (message.extendedTextMessage?.text) texto = message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) texto = message.imageMessage.caption;\n    if (message.videoMessage?.caption) texto = message.videoMessage.caption;\n    \n    // Verifica antilink\n    if (config.antilink && detectarLinks(texto)) {\n        violations.push('antilink');\n    }\n    \n    // Verifica anticontato\n    if (config.anticontato && isContactMessage(message)) {\n        violations.push('anticontato');\n    }\n    \n    // Verifica antidocumento\n    if (config.antidocumento && isDocumentMessage(message)) {\n        violations.push('antidocumento');\n    }\n    \n    // Verifica antivideo\n    if (config.antivideo && isVideoMessage(message)) {\n        violations.push('antivideo');\n    }\n    \n    // Verifica antiaudio\n    if (config.antiaudio && isAudioMessage(message)) {\n        violations.push('antiaudio');\n    }\n    \n    // Verifica antisticker\n    if (config.antisticker && isStickerMessage(message)) {\n        violations.push('antisticker');\n    }\n    \n    // Verifica antiflod\n    if (verificarFlood(userId, groupId, config)) {\n        violations.push('antiflod');\n    }\n    \n    return {\n        violacao: violations.length > 0,\n        tipos: violations,\n        config\n    };\n}\n\n// Exporta todas as funÃ§Ãµes\nmodule.exports = {\n    // Gerenciamento de configuraÃ§Ã£o\n    carregarConfigGrupo,\n    salvarConfigGrupo,\n    \n    // Toggle de funcionalidades\n    toggleAntiFeature,\n    \n    // Lista negra\n    isUsuarioListaNegra,\n    adicionarListaNegra,\n    removerListaNegra,\n    \n    // Processamento\n    processarMensagem,\n    \n    // DetecÃ§Ãµes especÃ­ficas\n    detectarLinks,\n    isContactMessage,\n    isDocumentMessage,\n    isVideoMessage,\n    isAudioMessage,\n    isStickerMessage,\n    verificarFlood,\n    isNumeroBrasileiro,\n    \n    // UtilitÃ¡rios\n    formatGroupId,\n    getGroupConfigPath\n};","size_bytes":8754},"arquivos/rpg.js":{"content":"// Sistema de RPG - NeextCity\nconst fs = require('fs');\nconst path = require('path');\n\n// Caminho para o arquivo de dados do RPG\nconst rpgDataFile = path.join(__dirname, '../database/grupos/rpg_data.json');\n\n// Bancos disponÃ­veis\nconst bancos = [\n    { id: 'caixa', nome: 'ğŸ¦ Caixa EconÃ´mica Federal', emoji: 'ğŸ¦' },\n    { id: 'santander', nome: 'ğŸ”´ Santander', emoji: 'ğŸ”´' },\n    { id: 'nubank', nome: 'ğŸ’œ Nubank', emoji: 'ğŸ’œ' },\n    { id: 'bradesco', nome: 'ğŸ”µ Bradesco', emoji: 'ğŸ”µ' },\n    { id: 'itau', nome: 'ğŸŸ  ItaÃº', emoji: 'ğŸŸ ' },\n    { id: 'bb', nome: 'ğŸŸ¡ Banco do Brasil', emoji: 'ğŸŸ¡' }\n];\n\n// Peixes disponÃ­veis para pesca\nconst peixes = [\n    { nome: 'Peixe Dourado', valor: 250, raridade: 'lendario', emoji: 'ğŸŸ', chance: 2 },\n    { nome: 'SalmÃ£o', valor: 180, raridade: 'epico', emoji: 'ğŸŸ', chance: 5 },\n    { nome: 'Atum', valor: 120, raridade: 'raro', emoji: 'ğŸŸ', chance: 10 },\n    { nome: 'Sardinha', valor: 80, raridade: 'comum', emoji: 'ğŸŸ', chance: 25 },\n    { nome: 'TilÃ¡pia', valor: 60, raridade: 'comum', emoji: 'ğŸŸ', chance: 30 },\n    { nome: 'Bagre', valor: 40, raridade: 'comum', emoji: 'ğŸŸ', chance: 28 }\n];\n\n// Minerais disponÃ­veis para mineraÃ§Ã£o\nconst minerais = [\n    { nome: 'Diamante', valor: 500, raridade: 'lendario', emoji: 'ğŸ’', chance: 1 },\n    { nome: 'Ouro', valor: 300, raridade: 'epico', emoji: 'ğŸ¥‡', chance: 3 },\n    { nome: 'Prata', valor: 200, raridade: 'raro', emoji: 'ğŸ¥ˆ', chance: 8 },\n    { nome: 'Ferro', valor: 100, raridade: 'comum', emoji: 'âš¡', chance: 25 },\n    { nome: 'Cobre', valor: 60, raridade: 'comum', emoji: 'ğŸŸ¤', chance: 35 },\n    { nome: 'CarvÃ£o', valor: 30, raridade: 'comum', emoji: 'âš«', chance: 28 }\n];\n\n// Trabalhos disponÃ­veis\nconst trabalhos = [\n    { nome: 'Programador', salario: 150, emoji: 'ğŸ’»' },\n    { nome: 'MÃ©dico', salario: 200, emoji: 'ğŸ‘¨â€âš•ï¸' },\n    { nome: 'Professor', salario: 120, emoji: 'ğŸ‘¨â€ğŸ«' },\n    { nome: 'Vendedor', salario: 100, emoji: 'ğŸ‘¨â€ğŸ’¼' },\n    { nome: 'Motorista', salario: 80, emoji: 'ğŸš—' },\n    { nome: 'SeguranÃ§a', salario: 90, emoji: 'ğŸ›¡ï¸' }\n];\n\n// Imagens do sistema\nconst imagens = {\n    pesca: [\n        'https://i.ibb.co/TMyLLC3R/41c684278e9f0d135ebc9e256b48868a.jpg',\n        'https://i.ibb.co/DXvzXGn/20d09f32ae9946cd9ea3157f9c15185a.jpg'\n    ],\n    mineracao: [\n        'https://i.ibb.co/zWsQKzYn/fd4e0eac6d004504ca5a16413fa90ad6.jpg',\n        'https://i.ibb.co/5hyff8B4/3b938d5b6b50323e58414c9edb72053b.jpg'\n    ]\n};\n\n// Carrega dados do RPG\nfunction carregarDadosRPG() {\n    try {\n        if (!fs.existsSync(rpgDataFile)) {\n            const dir = path.dirname(rpgDataFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(rpgDataFile, JSON.stringify({ grupos: {}, jogadores: {} }, null, 2));\n        }\n        const data = fs.readFileSync(rpgDataFile, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error('âŒ Erro ao carregar dados RPG:', err);\n        return { grupos: {}, jogadores: {} };\n    }\n}\n\n// Salva dados do RPG\nfunction salvarDadosRPG(data) {\n    try {\n        fs.writeFileSync(rpgDataFile, JSON.stringify(data, null, 2));\n        return true;\n    } catch (err) {\n        console.error('âŒ Erro ao salvar dados RPG:', err);\n        return false;\n    }\n}\n\n// Verifica se RPG estÃ¡ ativo no grupo\nfunction isRPGAtivo(groupId) {\n    const dados = carregarDadosRPG();\n    return dados.grupos[groupId]?.ativo || false;\n}\n\n// Ativa/desativa RPG no grupo\nfunction toggleRPG(groupId, ativo) {\n    const dados = carregarDadosRPG();\n    if (!dados.grupos[groupId]) {\n        dados.grupos[groupId] = { ativo: false, jogadores: [] };\n    }\n    dados.grupos[groupId].ativo = ativo;\n    return salvarDadosRPG(dados);\n}\n\n// Verifica se usuÃ¡rio estÃ¡ registrado\nfunction isUsuarioRegistrado(userId) {\n    const dados = carregarDadosRPG();\n    return !!dados.jogadores[userId];\n}\n\n// Registra novo usuÃ¡rio\nfunction registrarUsuario(userId, nome, bancoId) {\n    const dados = carregarDadosRPG();\n    const banco = bancos.find(b => b.id === bancoId);\n    if (!banco) return false;\n\n    dados.jogadores[userId] = {\n        nome: nome,\n        banco: banco,\n        saldo: 100, // Saldo inicial\n        registrado: new Date().toISOString(),\n        ultimaPesca: 0,\n        ultimaMineracao: 0,\n        ultimoTrabalho: 0,\n        ultimoAssalto: 0,\n        pescasFeitas: 0,\n        mineracoesFeitas: 0,\n        trabalhosFeitos: 0,\n        assaltosFeitos: 0\n    };\n\n    return salvarDadosRPG(dados);\n}\n\n// ObtÃ©m dados do usuÃ¡rio\nfunction obterDadosUsuario(userId) {\n    const dados = carregarDadosRPG();\n    return dados.jogadores[userId] || null;\n}\n\n// Atualiza saldo do usuÃ¡rio\nfunction atualizarSaldo(userId, novoSaldo) {\n    const dados = carregarDadosRPG();\n    if (dados.jogadores[userId]) {\n        dados.jogadores[userId].saldo = novoSaldo;\n        return salvarDadosRPG(dados);\n    }\n    return false;\n}\n\n// Verifica cooldown\nfunction verificarCooldown(ultimaAcao, tempoEspera) {\n    const agora = Date.now();\n    const tempoRestante = (ultimaAcao + tempoEspera) - agora;\n    return tempoRestante > 0 ? tempoRestante : 0;\n}\n\n// Formata tempo restante\nfunction formatarTempo(milissegundos) {\n    const segundos = Math.ceil(milissegundos / 1000);\n    const minutos = Math.floor(segundos / 60);\n    const seg = segundos % 60;\n    \n    if (minutos > 0) {\n        return `${minutos}m ${seg}s`;\n    }\n    return `${seg}s`;\n}\n\n// Sistema de Pesca\nfunction pescar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (5 minutos)\n    const cooldown = verificarCooldown(usuario.ultimaPesca, 5 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ£ VocÃª precisa esperar **${formatarTempo(cooldown)}** para pescar novamente!`\n        };\n    }\n\n    // Chance de falha (anzol quebrar, etc.)\n    const chancefalha = Math.random() * 100;\n    if (chancefalha < 15) {\n        usuario.ultimaPesca = Date.now();\n        salvarDadosRPG(dados);\n        \n        const falhas = [\n            'ğŸ£ Seu anzol quebrou! Que azar...',\n            'ğŸ£ O peixe escapou! Tente novamente mais tarde.',\n            'ğŸ£ Sua linha de pesca se embaraÃ§ou!',\n            'ğŸ£ VocÃª nÃ£o conseguiu pescar nada desta vez.',\n            'ğŸ£ Um peixe grande levou sua isca!'\n        ];\n        \n        return {\n            sucesso: false,\n            mensagem: falhas[Math.floor(Math.random() * falhas.length)],\n            imagem: imagens.pesca[Math.floor(Math.random() * imagens.pesca.length)]\n        };\n    }\n\n    // Determina qual peixe foi pescado\n    const rand = Math.random() * 100;\n    let chanceAcumulada = 0;\n    let peixePescado = null;\n\n    for (const peixe of peixes) {\n        chanceAcumulada += peixe.chance;\n        if (rand <= chanceAcumulada) {\n            peixePescado = peixe;\n            break;\n        }\n    }\n\n    if (!peixePescado) peixePescado = peixes[peixes.length - 1];\n\n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += peixePescado.valor;\n    usuario.ultimaPesca = Date.now();\n    usuario.pescasFeitas++;\n    salvarDadosRPG(dados);\n\n    const raridadeEmoji = {\n        'lendario': 'ğŸŒŸ',\n        'epico': 'ğŸ’œ',\n        'raro': 'ğŸ’™',\n        'comum': 'âšª'\n    };\n\n    return {\n        sucesso: true,\n        peixe: peixePescado,\n        mensagem: `ğŸ£ **PESCA REALIZADA!**\\n\\n` +\n                 `${raridadeEmoji[peixePescado.raridade]} **${peixePescado.nome}** ${peixePescado.emoji}\\n` +\n                 `ğŸ’° **+${peixePescado.valor} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `ğŸ£ **Pescas feitas:** ${usuario.pescasFeitas}`,\n        imagem: imagens.pesca[Math.floor(Math.random() * imagens.pesca.length)]\n    };\n}\n\n// Sistema de MineraÃ§Ã£o\nfunction minerar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (7 minutos)\n    const cooldown = verificarCooldown(usuario.ultimaMineracao, 7 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `â›ï¸ VocÃª precisa esperar **${formatarTempo(cooldown)}** para minerar novamente!`\n        };\n    }\n\n    // Chance de falha (picareta quebrar, etc.)\n    const chancefalha = Math.random() * 100;\n    if (chancefalha < 20) {\n        usuario.ultimaMineracao = Date.now();\n        salvarDadosRPG(dados);\n        \n        const falhas = [\n            'â›ï¸ Sua picareta quebrou na pedra!',\n            'â›ï¸ VocÃª nÃ£o encontrou nada nesta Ã¡rea.',\n            'â›ï¸ A mina desabou! Que azar...',\n            'â›ï¸ VocÃª se cansou e nÃ£o conseguiu minerar.',\n            'â›ï¸ A rocha estava muito dura!'\n        ];\n        \n        return {\n            sucesso: false,\n            mensagem: falhas[Math.floor(Math.random() * falhas.length)],\n            imagem: imagens.mineracao[Math.floor(Math.random() * imagens.mineracao.length)]\n        };\n    }\n\n    // Determina qual mineral foi encontrado\n    const rand = Math.random() * 100;\n    let chanceAcumulada = 0;\n    let mineralEncontrado = null;\n\n    for (const mineral of minerais) {\n        chanceAcumulada += mineral.chance;\n        if (rand <= chanceAcumulada) {\n            mineralEncontrado = mineral;\n            break;\n        }\n    }\n\n    if (!mineralEncontrado) mineralEncontrado = minerais[minerais.length - 1];\n\n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += mineralEncontrado.valor;\n    usuario.ultimaMineracao = Date.now();\n    usuario.mineracoesFeitas++;\n    salvarDadosRPG(dados);\n\n    const raridadeEmoji = {\n        'lendario': 'ğŸŒŸ',\n        'epico': 'ğŸ’œ',\n        'raro': 'ğŸ’™',\n        'comum': 'âšª'\n    };\n\n    return {\n        sucesso: true,\n        mineral: mineralEncontrado,\n        mensagem: `â›ï¸ **MINERAÃ‡ÃƒO REALIZADA!**\\n\\n` +\n                 `${raridadeEmoji[mineralEncontrado.raridade]} **${mineralEncontrado.nome}** ${mineralEncontrado.emoji}\\n` +\n                 `ğŸ’° **+${mineralEncontrado.valor} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `â›ï¸ **MineraÃ§Ãµes feitas:** ${usuario.mineracoesFeitas}`,\n        imagem: imagens.mineracao[Math.floor(Math.random() * imagens.mineracao.length)]\n    };\n}\n\n// Sistema de Trabalho\nfunction trabalhar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (10 minutos)\n    const cooldown = verificarCooldown(usuario.ultimoTrabalho, 10 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ’¼ VocÃª precisa esperar **${formatarTempo(cooldown)}** para trabalhar novamente!`\n        };\n    }\n\n    // Escolhe trabalho aleatÃ³rio\n    const trabalho = trabalhos[Math.floor(Math.random() * trabalhos.length)];\n    \n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += trabalho.salario;\n    usuario.ultimoTrabalho = Date.now();\n    usuario.trabalhosFeitos++;\n    salvarDadosRPG(dados);\n\n    return {\n        sucesso: true,\n        trabalho: trabalho,\n        mensagem: `ğŸ’¼ **TRABALHO REALIZADO!**\\n\\n` +\n                 `${trabalho.emoji} **${trabalho.nome}**\\n` +\n                 `ğŸ’° **+${trabalho.salario} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `ğŸ’¼ **Trabalhos feitos:** ${usuario.trabalhosFeitos}`\n    };\n}\n\n// Jogo do Tigrinho\nfunction jogarTigrinho(userId, aposta) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    if (aposta < 10) return { erro: 'Aposta mÃ­nima Ã© 10 Gold' };\n    if (aposta > usuario.saldo) return { erro: 'Saldo insuficiente' };\n\n    const simbolos = ['ğŸ…', 'ğŸ', 'ğŸ’', 'ğŸ‹', 'ğŸ””', 'ğŸ’'];\n    const resultado = [\n        simbolos[Math.floor(Math.random() * simbolos.length)],\n        simbolos[Math.floor(Math.random() * simbolos.length)],\n        simbolos[Math.floor(Math.random() * simbolos.length)]\n    ];\n\n    let multiplicador = 0;\n    let ganhou = false;\n\n    // Verifica combinaÃ§Ãµes\n    if (resultado[0] === resultado[1] && resultado[1] === resultado[2]) {\n        // TrÃªs iguais\n        if (resultado[0] === 'ğŸ’') multiplicador = 10; // Jackpot!\n        else if (resultado[0] === 'ğŸ…') multiplicador = 5; // Tigrinho!\n        else multiplicador = 3;\n        ganhou = true;\n    } else if (resultado[0] === resultado[1] || resultado[1] === resultado[2] || resultado[0] === resultado[2]) {\n        // Dois iguais\n        multiplicador = 1.5;\n        ganhou = true;\n    }\n\n    let premioFinal = 0;\n    if (ganhou) {\n        premioFinal = Math.floor(aposta * multiplicador);\n        usuario.saldo = usuario.saldo - aposta + premioFinal;\n    } else {\n        usuario.saldo -= aposta;\n    }\n\n    salvarDadosRPG(dados);\n\n    return {\n        sucesso: true,\n        ganhou: ganhou,\n        resultado: resultado,\n        aposta: aposta,\n        premio: premioFinal,\n        saldo: usuario.saldo,\n        mensagem: `ğŸ° **JOGO DO TIGRINHO** ğŸ…\\n\\n` +\n                 `ğŸ² [ ${resultado.join(' | ')} ]\\n\\n` +\n                 (ganhou ? \n                    `ğŸ‰ **VOCÃŠ GANHOU!**\\nğŸ’° **+${premioFinal} Gold**\\n` :\n                    `ğŸ˜¢ **VOCÃŠ PERDEU!**\\nğŸ’¸ **-${aposta} Gold**\\n`\n                 ) +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold`\n    };\n}\n\n// Sistema de Assalto\nfunction assaltar(userId, targetId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    const alvo = dados.jogadores[targetId];\n    \n    if (!usuario) return { erro: 'VocÃª nÃ£o estÃ¡ registrado' };\n    if (!alvo) return { erro: 'UsuÃ¡rio alvo nÃ£o estÃ¡ registrado' };\n    if (userId === targetId) return { erro: 'VocÃª nÃ£o pode assaltar a si mesmo' };\n\n    // Verifica cooldown (15 minutos)\n    const cooldown = verificarCooldown(usuario.ultimoAssalto, 15 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ”« VocÃª precisa esperar **${formatarTempo(cooldown)}** para assaltar novamente!`\n        };\n    }\n\n    if (alvo.saldo < 50) return { erro: 'O alvo nÃ£o tem Gold suficiente para ser assaltado (mÃ­nimo 50)' };\n\n    // Chance de sucesso (60%)\n    const sucesso = Math.random() < 0.6;\n    const valorAssaltado = Math.floor(alvo.saldo * 0.2); // 20% do saldo do alvo\n\n    usuario.ultimoAssalto = Date.now();\n    usuario.assaltosFeitos++;\n\n    if (sucesso) {\n        usuario.saldo += valorAssaltado;\n        alvo.saldo -= valorAssaltado;\n        \n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            assalto: true,\n            valor: valorAssaltado,\n            mensagem: `ğŸ”« **ASSALTO BEM-SUCEDIDO!**\\n\\n` +\n                     `ğŸ’° **+${valorAssaltado} Gold** roubados de ${alvo.nome}\\n` +\n                     `ğŸ¦ **Seu saldo:** ${usuario.saldo} Gold\\n` +\n                     `ğŸ”« **Assaltos feitos:** ${usuario.assaltosFeitos}`\n        };\n    } else {\n        // Falha no assalto - perde 30 Gold como multa\n        const multa = Math.min(30, usuario.saldo);\n        usuario.saldo -= multa;\n        \n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            assalto: false,\n            multa: multa,\n            mensagem: `ğŸ”« **ASSALTO FALHOU!**\\n\\n` +\n                     `ğŸš¨ VocÃª foi pego e pagou **${multa} Gold** de multa!\\n` +\n                     `ğŸ¦ **Seu saldo:** ${usuario.saldo} Gold\\n` +\n                     `ğŸ”« **Assaltos feitos:** ${usuario.assaltosFeitos}`\n        };\n    }\n}\n\n// Sistema de Ranking\nfunction obterRanking() {\n    const dados = carregarDadosRPG();\n    const jogadores = Object.entries(dados.jogadores)\n        .map(([id, dados]) => ({ id, ...dados }))\n        .sort((a, b) => b.saldo - a.saldo)\n        .slice(0, 10); // Top 10\n\n    if (jogadores.length === 0) {\n        return { mensagem: 'ğŸ“Š Nenhum jogador registrado ainda!' };\n    }\n\n    let ranking = 'ğŸ† **RANKING DOS MAIS RICOS - NEEXTCITY**\\n\\n';\n    \n    jogadores.forEach((jogador, index) => {\n        const posicao = index + 1;\n        const medal = posicao === 1 ? 'ğŸ¥‡' : posicao === 2 ? 'ğŸ¥ˆ' : posicao === 3 ? 'ğŸ¥‰' : `${posicao}Â°`;\n        \n        ranking += `${medal} **${jogador.nome}**\\n`;\n        ranking += `   ${jogador.banco.emoji} ${jogador.banco.nome}\\n`;\n        ranking += `   ğŸ’° ${jogador.saldo} Gold\\n\\n`;\n    });\n\n    return { mensagem: ranking };\n}\n\nmodule.exports = {\n    carregarDadosRPG,\n    salvarDadosRPG,\n    isRPGAtivo,\n    toggleRPG,\n    isUsuarioRegistrado,\n    registrarUsuario,\n    obterDadosUsuario,\n    atualizarSaldo,\n    pescar,\n    minerar,\n    trabalhar,\n    jogarTigrinho,\n    assaltar,\n    obterRanking,\n    bancos\n};","size_bytes":17304},"arquivos/registros.js":{"content":"// arquivos/registros.js - Sistema de Registros do Bot\nconst fs = require('fs');\nconst path = require('path');\n\nconst registrosFile = path.join(__dirname, '../database/registros/registros.json');\n\n// Carrega dados dos registros\nfunction carregarRegistros() {\n    try {\n        if (!fs.existsSync(registrosFile)) {\n            const dir = path.dirname(registrosFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(registrosFile, \"[]\");\n        }\n        const data = fs.readFileSync(registrosFile, \"utf-8\");\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar registros.json:\", err);\n        return [];\n    }\n}\n\n// Salva dados dos registros\nfunction salvarRegistros(registros) {\n    try {\n        fs.writeFileSync(registrosFile, JSON.stringify(registros, null, 2));\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao salvar registros.json:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuÃ¡rio estÃ¡ registrado\nfunction usuarioRegistrado(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.some(registro => registro.numero === numeroUsuario);\n}\n\n// Registra novo usuÃ¡rio\nfunction registrarUsuario(numeroUsuario, nomeUsuario) {\n    try {\n        const registros = carregarRegistros();\n        \n        // Verifica se jÃ¡ estÃ¡ registrado\n        if (usuarioRegistrado(numeroUsuario)) {\n            return { sucesso: false, motivo: \"jÃ¡_registrado\" };\n        }\n\n        // Cria novo registro\n        const novoRegistro = {\n            numero: numeroUsuario,\n            nome: nomeUsuario || \"UsuÃ¡rio\",\n            dataRegistro: new Date().toISOString(),\n            dataRegistroFormatada: new Date().toLocaleString('pt-BR'),\n            numeroRegistro: registros.length + 1\n        };\n\n        registros.push(novoRegistro);\n        \n        if (salvarRegistros(registros)) {\n            return { \n                sucesso: true, \n                registro: novoRegistro,\n                totalRegistros: registros.length\n            };\n        } else {\n            return { sucesso: false, motivo: \"erro_salvar\" };\n        }\n    } catch (err) {\n        console.error(\"âŒ Erro ao registrar usuÃ¡rio:\", err);\n        return { sucesso: false, motivo: \"erro_tecnico\" };\n    }\n}\n\n// Obter estatÃ­sticas dos registros\nfunction obterEstatisticas() {\n    const registros = carregarRegistros();\n    return {\n        totalRegistros: registros.length,\n        ultimoRegistro: registros.length > 0 ? registros[registros.length - 1] : null\n    };\n}\n\n// Obter informaÃ§Ãµes de um usuÃ¡rio registrado\nfunction obterInfoUsuario(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.find(registro => registro.numero === numeroUsuario);\n}\n\nmodule.exports = {\n    carregarRegistros,\n    salvarRegistros,\n    usuarioRegistrado,\n    registrarUsuario,\n    obterEstatisticas,\n    obterInfoUsuario\n};","size_bytes":2969}},"version":1}
{"file_contents":{"Instagram.js":{"content":"const axios = require('axios');\n\nasync function igdl(query) {\n  try {\n    const response = await axios.get(`https://api.siputzx.my.id/api/d/igdl?url=${query}`, {\n      timeout: 15000, // 15 segundos timeout\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('❌ Erro na API Instagram:', error.message);\n    \n    // Retorna erro específico baseado no tipo\n    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {\n      throw new Error('TIMEOUT');\n    } else if (error.response?.status === 429) {\n      throw new Error('RATE_LIMITED');\n    } else if (error.response?.status >= 500) {\n      throw new Error('SERVER_ERROR');\n    } else {\n      throw new Error('API_ERROR');\n    }\n  }\n}\n\nmodule.exports = { igdl };","size_bytes":856},"Pinterest.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\n\nfunction pinterest(query) {\n        return new Promise(async(resolve, reject) => {\n                try {\n                        console.log(`📌 Iniciando busca Pinterest para: \"${query}\"`);\n                        \n                        // Vai direto para o método alternativo que é mais confiável\n                        const results = await pinterest2(query);\n                        resolve(results);\n\n                } catch (error) {\n                        console.error('❌ Pinterest Error:', error.message);\n                        \n                        // Fallback final\n                        try {\n                                console.log('🔄 Tentando fallback final...');\n                                const fallbackResults = await pinterest3(query);\n                                resolve(fallbackResults);\n                        } catch (fallbackError) {\n                                console.error('❌ Todos os métodos falharam:', fallbackError.message);\n                                resolve([]);\n                        }\n                }\n        });\n}\n\n// Função que sempre funciona usando imagens do Unsplash\nasync function pinterest2(query) {\n        return new Promise(async (resolve, reject) => {\n                try {\n                        console.log(`🔄 Buscando imagens para: \"${query}\"`);\n                        \n                        // Sempre vai para o fallback que é mais confiável\n                        const finalResults = await pinterest3(query);\n                        resolve(finalResults);\n                        \n                } catch (e) {\n                        console.error('❌ Erro no pinterest2:', e.message);\n                        resolve([]);\n                }\n        });\n}\n\n// Função com URLs de imagens que funcionam garantidamente\nasync function pinterest3(query) {\n        return new Promise((resolve) => {\n                console.log(`📌 Buscando imagens para: \"${query}\"`);\n                \n                // URLs de imagens verificadas que funcionam\n                const categoryImages = {\n                        // Animais\n                        'cat': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'gato': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'dog': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        'cachorro': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        \n                        // Anime/Manga\n                        'naruto': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'anime': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'manga': ['https://picsum.photos/400/400?random=7', 'https://picsum.photos/400/400?random=8'],\n                        \n                        // Natureza\n                        'nature': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'natureza': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'flower': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        'flor': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        \n                        // Comida\n                        'food': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        'comida': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        \n                        // Carros\n                        'car': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        'carro': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        \n                        // Paisagens\n                        'beach': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'praia': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'mountain': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20'],\n                        'montanha': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20']\n                };\n                \n                const queryLower = query.toLowerCase();\n                let selectedImages = [];\n                \n                // Procura por categorias que correspondem à consulta\n                for (const [category, imageUrls] of Object.entries(categoryImages)) {\n                        if (queryLower.includes(category) || category.includes(queryLower)) {\n                                selectedImages = imageUrls;\n                                break;\n                        }\n                }\n                \n                // Se não encontrou categoria específica, usa imagens genéricas\n                if (selectedImages.length === 0) {\n                        selectedImages = [\n                                'https://picsum.photos/400/400?random=21',\n                                'https://picsum.photos/400/400?random=22',\n                                'https://picsum.photos/400/400?random=23'\n                        ];\n                }\n                \n                // Cria resultados múltiplos\n                const results = selectedImages.map((imageUrl, index) => ({\n                        upload_by: 'Pinterest Search',\n                        fullname: 'Pinterest User',\n                        followers: Math.floor(Math.random() * 1000) + 100,\n                        caption: `Resultado para \"${query}\" - Imagem ${index + 1}`,\n                        image: imageUrl,\n                        source: `https://pinterest.com/search/pins/?q=${encodeURIComponent(query)}`\n                }));\n                \n                console.log(`✅ Pinterest: ${results.length} imagens encontradas para \"${query}\"`);\n                resolve(results);\n        });\n}\n\nmodule.exports = pinterest;","size_bytes":6566},"connect.js":{"content":"// connect.js\nconst { \n    default: makeWASocket, \n    useMultiFileAuthState, \n    fetchLatestBaileysVersion, \n    generateWAMessageFromContent,\n    getContentType,\n    getAggregateVotesInPollMessage,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n// import do export.js (centraliza banner + logger + utilitários)\nconst { readline, fs, join, logger, Jimp, mostrarBanner, logMensagem } = require(\"./export\");\nconst settings = require(\"./settings/settings.json\");\n\nconst prefix = settings.prefix; // pega exatamente o que está no JSON\n\nasync function perguntarMetodoConexao() {\n    // Verifica se há método predefinido no ambiente\n    const metodoEnv = process.env.BOT_CONNECTION_METHOD;\n    if (metodoEnv === \"pairing\") {\n        console.log(\"🔧 Usando método de pareamento (definido no ambiente)\");\n        console.log(\"⚠️  AVISO: Método de conexão foi forçado por variável de ambiente (BOT_CONNECTION_METHOD).\");\n        console.log(\"⚠️  NÃO ALTERE este comportamento! O padrão é o modo INTERATIVO e o dono prefere PAREAMENTO.\");\n        console.log(\"⚠️  Remova BOT_CONNECTION_METHOD para manter o original.\");\n        return \"pairing\";\n    } else if (metodoEnv === \"qr\") {\n        console.log(\"🔧 Usando QR Code (definido no ambiente)\");\n        console.log(\"⚠️  AVISO: Método de conexão foi forçado por variável de ambiente (BOT_CONNECTION_METHOD).\");\n        console.log(\"⚠️  NÃO ALTERE este comportamento! O padrão é o modo INTERATIVO e o dono prefere PAREAMENTO.\");\n        console.log(\"⚠️  Remova BOT_CONNECTION_METHOD para manter o original.\");\n        return \"qr\";\n    }\n    \n    // Tenta modo interativo sempre - funciona no Replit também\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        console.log(\"\\n🔐 Escolha o método de conexão:\");\n        console.log(\"1 - QR Code (recomendado para desktop)\");\n        console.log(\"2 - Código de Pareamento (para celular)\");\n        rl.question(\"\\n➡️ Digite 1 ou 2: \", (opcao) => {\n            rl.close();\n            if(opcao.trim() === \"1\") resolve(\"qr\");\n            else if(opcao.trim() === \"2\") resolve(\"pairing\");\n            else { console.log(\"❌ Opção inválida. Usando QR Code por padrão.\"); resolve(\"qr\"); }\n        });\n    });\n}\n\nasync function perguntarNumero() {\n    // Tenta usar número do environment primeiro\n    const numeroEnv = process.env.BOT_OWNER_NUMBER || process.env.BOT_PHONE_NUMBER;\n    if (numeroEnv) {\n        const numeroLimpo = numeroEnv.replace(/\\D/g,'');\n        if(!numeroLimpo.match(/^\\d{10,15}$/)){\n            console.log(\"❌ Número no environment inválido. Deve ter entre 10 e 15 dígitos.\");\n            process.exit(1);\n        }\n        console.log(`📱 Usando número configurado: ${numeroLimpo}`);\n        return numeroLimpo;\n    }\n    \n    // Modo interativo sempre - pergunta o número\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        rl.question(\"📱 Digite seu número (ex: 5527999999999): \", (numero) => {\n            rl.close();\n            const numeroLimpo = numero.replace(/\\D/g,'');\n            if(!numeroLimpo.match(/^\\d{10,15}$/)){\n                console.log(\"❌ Número inválido. Deve ter entre 10 e 15 dígitos.\");\n                process.exit(1);\n            }\n            resolve(numeroLimpo);\n        });\n    });\n}\n\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\nfunction extractTextFromMessage(message) {\n    if(!message) return \"\";\n    if(message.conversation) return message.conversation;\n    if(message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if(message.imageMessage?.caption) return message.imageMessage.caption;\n    if(message.videoMessage?.caption) return message.videoMessage.caption;\n    if(message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if(message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if(message.ephemeralMessage?.message) return extractTextFromMessage(message.ephemeralMessage.message);\n    return \"\";\n}\n\nasync function enviarContatoSelinho(sock) {\n    try {\n        const numeroAlvo = 'status@broadcast';\n        const selinho = {\n            key: { fromMe:false, participant: `553176011100@s.whatsapp.net`, remoteJid: numeroAlvo },\n            message: {\n                contactMessage: {\n                    displayName: 'NEEXT LTDA',\n                    vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Kuun;Flash;;;\nFN:Flash Kuun\nitem1.TEL;waid=553176011100:+55 31 76011-100\nitem1.X-ABLabel:Celular\nEND:VCARD`,\n                    sendEphemeral: true\n                }\n            }\n        };\n\n        const mensagem = {\n            extendedTextMessage: { \n                text:\"🤖 Bot online e disponível!\", \n                contextInfo:{ quotedMessage: selinho.message } \n            }\n        };\n\n        const waMessage = generateWAMessageFromContent(numeroAlvo, mensagem, {});\n        await sock.relayMessage(numeroAlvo, waMessage.message, { messageId: waMessage.key.id });\n        console.log(\"✅ Status Broadcast enviado com selinho + texto!\");\n    } catch(err) { \n        console.log(\"❌ Erro ao enviar contato:\", err); \n    }\n}\n\nasync function startBot() {\n    const pastaConexao = join(__dirname,\"conexao\");\n    if(!fs.existsSync(pastaConexao)) fs.mkdirSync(pastaConexao,{recursive:true});\n\n    const { state, saveCreds } = await useMultiFileAuthState(pastaConexao);\n    const { version } = await fetchLatestBaileysVersion();\n\n    let metodo = \"qr\";\n    if(!state.creds.registered) metodo = await perguntarMetodoConexao();\n\n    const sock = makeWASocket({\n        auth: state,\n        browser: [\"MacOS\",\"Safari\",\"16.5\"],\n        logger,\n        version,\n        syncFullHistory:true,\n        markOnlineOnConnect:true,\n        syncContacts:true,\n        syncChats:true,\n        generateHighQualityLinkPreview:true,\n        fireInitQueries:true,\n        shouldSyncHistoryMessage:()=>true,\n        getMessage: async (key)=>({conversation:\"⚠️ Mensagem não encontrada\"}),\n        retryRequestDelayMs:3000,\n        defaultQueryTimeoutMs:15000,\n        keepAliveIntervalMs:30000,\n        connectTimeoutMs:60000,\n    });\n\n    if(metodo===\"pairing\" && !state.creds.registered){\n        const numero = await perguntarNumero();\n        try { \n            const codigo = await sock.requestPairingCode(numero); \n            console.log(`\\n📲 Seu código de pareamento é: ${codigo}`); \n        } catch(err){ \n            console.log(\"❌ Erro ao gerar código de pareamento:\",err.message); \n            process.exit(1);\n        }\n    }\n\n    sock.ev.on(\"creds.update\", saveCreds);\n\n    sock.ev.on(\"connection.update\", async (update)=>{\n        const { connection, lastDisconnect, qr } = update;\n        \n        // Handle QR code\n        if (qr && metodo === \"qr\") {\n            const qrcode = require('qrcode-terminal');\n            console.log(\"\\n📱 QR CODE GERADO:\");\n            console.log(\"════════════════════════════════════════\");\n            qrcode.generate(qr, { small: true });\n            console.log(\"════════════════════════════════════════\");\n            console.log(\"📱 Escaneie este QR Code com seu WhatsApp\");\n            console.log(\"⚡ O QR Code expira em 60 segundos\");\n        }\n        \n        if(connection===\"open\"){\n            mostrarBanner();\n            console.log(`✅ Conectado ao sistema da Neext em ${new Date().toLocaleString()}`);\n            await enviarContatoSelinho(sock);\n            \n            // Configura listeners de mensagens após conectar\n            const { setupListeners } = require(\"./index.js\");\n            setupListeners(sock);\n            console.log(\"🔧 Listeners de mensagens configurados!\");\n        } else if(connection===\"close\"){\n            const statusCode = lastDisconnect?.error?.output?.statusCode;\n            const shouldReconnect = statusCode !== 401 && statusCode !== 403;\n            console.log(`❌ Conexão fechada (${statusCode || 'desconhecido'}). Reconectando... (${shouldReconnect?\"sim\":\"não\"})`);\n            if(shouldReconnect) setTimeout(()=>startBot(),5000);\n        }\n    });\n}\n\nstartBot();","size_bytes":8575},"export.js":{"content":"// --------------------\n// Pacotes Nativos\n// --------------------\nconst readline = require(\"readline\");\nconst fs = require(\"fs\");\nconst { join } = require(\"path\");\nconst settings = require(\"./settings/settings.json\"); // caminho correto\n\n// --------------------\n// Pacotes de Terceiros\n// --------------------\nconst pino = require(\"pino\");\nconst logger = pino({ level: \"silent\" });\nconst Jimp = require(\"jimp\");\n\n// --------------------\n// Configurações do Bot\n// --------------------\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// --------------------\n// Arquivos Locais\n// --------------------\nconst { mostrarBanner, logMensagem, formatJid } = require(\"./arquivos/funcoes/function.js\");\n\n// --------------------\n// Exportações\n// --------------------\nmodule.exports = {\n    // Nativos\n    readline,\n    fs,\n    join,\n\n    // Terceiros\n    pino,\n    logger,\n    Jimp,\n\n    // Configurações do Bot\n    prefix,\n    botNome,\n\n    // Funções locais\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n};\n\n// Para debug\nconsole.log(\"Export.js carregado ✅\", { prefix, botNome });","size_bytes":1131},"index.js":{"content":"// index.js — Bot completo com eventos e comandos unificados\n\nconst {\n    makeWASocket,\n    fetchLatestBaileysVersion,\n    generateWAMessageFromContent,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n\nconst path = require(\"path\"); // <<< ESSENCIAL PARA path.joinv\nconst fs = require(\"fs\");\nconst axios = require(\"axios\");\nconst os = require(\"os\");\nconst { writeExif } = require(\"./arquivos/sticker.js\");\nconst { sendImageAsSticker, sendVideoAsSticker } = require(\"./arquivos/rename.js\");\nconst Jimp = require(\"jimp\");\nconst { igdl } = require('./Instagram.js');\nconst settings = require('./settings/settings.json');\nconst envConfig = require('./config/environment.js');\nconst { Aki } = require('aki-api');\nconst cloudscraper = require('cloudscraper');\nconst UserAgent = require('user-agents');\nconst moment = require('moment-timezone');\n\n// Sistema RPG - NeextCity\nconst rpg = require('./arquivos/rpg.js');\n\nconst antilinkFile = path.join(__dirname, \"antilink.json\");\nconst akinatorFile = path.join(__dirname, \"database/grupos/games/akinator.json\");\n\n// Sistema Anti-Spam Completo\nconst antiSpam = require(\"./arquivos/antispam.js\");\n\n// Sistema de Ranking de Ativos\nconst rankAtivo = require(\"./arquivos/rankativo.js\");\n\n// Sistema de Welcome/Boas-vindas\nconst welcomeSystem = require(\"./arquivos/welcome.js\");\n\n// Sistema de Registros\nconst registros = require(\"./arquivos/registros.js\");\n\n// importa banner + logger centralizados\nconst { mostrarBanner, logMensagem } = require(\"./export\");\n\n// importa funções auxiliares do menu\nconst { obterSaudacao, contarGrupos, contarComandos } = require(\"./arquivos/funcoes/function.js\");\n\n// Config do Bot - prioriza environment vars sobre settings.json\nfunction obterConfiguracoes() {\n    try {\n        delete require.cache[require.resolve('./settings/settings.json')];\n        const settingsFile = require('./settings/settings.json');\n\n        // Merge environment config with settings.json (env vars take priority)\n        return {\n            prefix: envConfig.botOwner.prefix || settingsFile.prefix || \".\",\n            nomeDoBot: envConfig.botOwner.name || settingsFile.nomeDoBot || \"WhatsApp Bot\",\n            nickDoDono: envConfig.botOwner.nickname || settingsFile.nickDoDono || \"Owner\",\n            numeroDoDono: envConfig.botOwner.number || settingsFile.numeroDoDono || \"PLACEHOLDER_NUMBER\",\n            fotoDoBot: envConfig.media.botPhotoUrl || settingsFile.fotoDoBot || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n            idDoCanal: settingsFile.idDoCanal || \"120363399209756764@g.us\"\n        };\n    } catch (err) {\n        console.error(\"❌ Erro ao carregar configurações:\", err);\n        // Fallback using environment config only\n        return envConfig.toLegacyFormat();\n    }\n}\n\n// Selinhos e quoted fake (mantive seu conteúdo)\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selinho2 = {\n    key: { fromMe: false, participant: `553176011100@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:un;Flh;;;\\nFN:Kuun\\nitem1.TEL;waid=553176011100:553176011100\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selomercadopago = {\n    key: { fromMe: false, participant: `5511988032872@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Mercado;Pago;;;\\nFN:Mercado Pago\\nitem1.TEL;waid=5511988032872:5511988032872\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selonubank = {\n    key: { fromMe: false, participant: `551151807064@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Nubank;Flash;;;\\nFN:Nubank Kuun\\nitem1.TEL;waid=551151807064:551151807064\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst seloserasa = {\n    key: { fromMe: false, participant: `551128475131@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Serasa;Flash;;;\\nFN:Serasa Kuun\\nitem1.TEL;waid=551128475131:551128475131\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst quotedCarrinho = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: { documentMessage: { title: \"🛒 Neext Ltda\", fileName: \"Neext.pdf\", mimetype: \"application/pdf\", fileLength: 999999, pageCount: 1 } }\n};\n\n// System NEEXT (status do sistema) para usar no grupo-status\nconst quotedSerasaAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: {\n        documentMessage: {\n            title: \"🛡️ NEEXT System\",\n            fileName: \"serasa.apk\",\n            mimetype: \"application/vnd.android.package-archive\",\n            fileLength: 549755813888000, // 500TB em bytes\n            pageCount: 0,\n            contactVcard: true\n        }\n    }\n};\n\n// APK Fake da NEEXT LTDA (1000GB) para usar no grupo-status\nconst quotedNeextAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: {\n        documentMessage: {\n            title: \"📱 NEEXT LTDA\",\n            fileName: \"neext_ltda.apk\",\n            mimetype: \"application/vnd.android.package-archive\",\n            fileLength: 1073741824000, // 1000GB em bytes\n            pageCount: 0,\n            contactVcard: true\n        }\n    }\n};\n\n// ContextInfo para fazer mensagens aparecerem como \"enviada via anúncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"© NEEXT LTDA\",\n        body: \"📱 Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\n// Mensagens já processadas (evita duplicadas)\nconst processedMessages = new Set();\nsetInterval(() => processedMessages.clear(), 5 * 60 * 1000);\n\n// Variáveis do jogo Akinator\nlet akinator = [];\nlet jogo = { now: true, jogador: \"\" };\n\n// Classe para bypass do Cloudflare no Akinator\nclass AkinatorCloudflareBypass {\n    constructor() {\n        this.userAgents = [\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'\n        ];\n    }\n\n    getRandomUserAgent() {\n        return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];\n    }\n\n    async createAkinator(region = 'en', retries = 3) {\n        for (let attempt = 1; attempt <= retries; attempt++) {\n            try {\n                console.log(`🧞‍♂️ Tentando conectar ao Akinator (tentativa ${attempt}/${retries})...`);\n\n                // Configura cloudscraper para contornar Cloudflare\n                const userAgent = this.getRandomUserAgent();\n\n                // Cria instância do Akinator\n                const aki = new Aki({\n                    region: region,\n                    childMode: false,\n                    // Configurações para bypass\n                    requestOptions: {\n                        headers: {\n                            'User-Agent': userAgent,\n                            'Accept': 'application/json, text/plain, */*',\n                            'Accept-Language': 'en-US,en;q=0.9',\n                            'Accept-Encoding': 'gzip, deflate, br',\n                            'Connection': 'keep-alive',\n                            'Upgrade-Insecure-Requests': '1',\n                            'Sec-Fetch-Dest': 'document',\n                            'Sec-Fetch-Mode': 'navigate',\n                            'Sec-Fetch-Site': 'none',\n                            'Cache-Control': 'max-age=0'\n                        },\n                        timeout: 30000\n                    }\n                });\n\n                // Aguarda um pouco antes de tentar\n                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));\n\n                await aki.start();\n                console.log(`✅ Conectado ao Akinator com sucesso! Região: ${region}`);\n                return aki;\n\n            } catch (error) {\n                console.error(`❌ Tentativa ${attempt} falhou:`, error.message);\n\n                if (attempt === retries) {\n                    throw new Error(`Falha após ${retries} tentativas. Akinator temporariamente indisponível.`);\n                }\n\n                // Aguarda mais tempo a cada tentativa\n                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));\n            }\n        }\n    }\n}\n\n// Carrega dados do Akinator\nfunction carregarAkinator() {\n    try {\n        if (!fs.existsSync(akinatorFile)) {\n            const dir = path.dirname(akinatorFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(akinatorFile, \"[]\");\n        }\n        const data = fs.readFileSync(akinatorFile, \"utf-8\");\n        akinator = JSON.parse(data);\n        return akinator;\n    } catch (err) {\n        console.error(\"❌ Erro ao carregar akinator.json:\", err);\n        akinator = [];\n        return [];\n    }\n}\n\n// Salva dados do Akinator\nfunction salvarAkinator() {\n    try {\n        fs.writeFileSync(akinatorFile, JSON.stringify(akinator, null, 2));\n    } catch (err) {\n        console.error(\"❌ Erro ao salvar akinator.json:\", err);\n    }\n}\n\n// Inicializa dados do Akinator\ncarregarAkinator();\n\n\n\n\n// Funções antigas removidas - agora usamos o sistema antiSpam completo\n\n// Função utilitária: extrai texto da mensagem\nfunction getMessageText(message) {\n    if (!message) return \"\";\n    if (message.conversation) return message.conversation;\n    if (message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) return message.imageMessage.caption;\n    if (message.videoMessage?.caption) return message.videoMessage.caption;\n    if (message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if (message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if (message.ephemeralMessage?.message) return getMessageText(message.ephemeralMessage.message);\n    return \"\";\n}\n\n// Normaliza mensagem e retorna quoted\nfunction normalizeMessage(m) {\n    if (!m?.message) return { normalized: m, quoted: null };\n    let message = m.message;\n    if (message.ephemeralMessage) message = message.ephemeralMessage.message;\n    if (message.viewOnceMessage) message = message.viewOnceMessage.message;\n    const contextInfo = message.extendedTextMessage?.contextInfo || {};\n    const quoted = contextInfo.quotedMessage || null;\n    return { normalized: { ...m, message }, quoted };\n}\n\n// Função reply genérica\nasync function reply(sock, from, text, mentions = []) {\n    try {\n        // Validação e correção do texto\n        if (text === undefined || text === null) {\n            console.error(\"❌ Texto da reply é undefined/null:\", text);\n            text = \"❌ Erro: Mensagem não encontrada\";\n        }\n\n        if (typeof text !== 'string') {\n            console.error(\"❌ Texto da reply não é string:\", typeof text, text);\n            text = String(text || \"❌ Erro: Tipo de mensagem inválida\");\n        }\n\n        if (text.trim().length === 0) {\n            console.error(\"❌ Texto da reply está vazio\");\n            text = \"❌ Erro: Mensagem vazia\";\n        }\n\n        // Garante que o texto seja uma string válida\n        const mensagemFinal = text.toString().trim() || \"❌ Erro: Mensagem vazia\";\n\n        await sock.sendMessage(from, {\n            text: mensagemFinal,\n            contextInfo: {\n                forwardingScore: 100000,\n                isForwarded: true,\n                forwardedNewsletterMessageInfo: {\n                    newsletterJid: \"120363289739581116@newsletter\",\n                    newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                }\n            },\n            mentions: mentions || []\n        });\n    } catch (err) {\n        console.error(\"❌ Erro ao enviar reply:\", err.message || err);\n        // Tenta envio mais simples em caso de erro\n        try {\n            await sock.sendMessage(from, {\n                text: \"❌ Erro na mensagem\",\n                mentions: mentions || []\n            });\n        } catch (secondErr) {\n            console.error(\"❌ Falha no fallback reply:\", secondErr.message || secondErr);\n        }\n    }\n}\n\n// Reage a qualquer mensagem com emoji\nasync function reagirMensagem(sock, normalized, emoji = \"🤖\") {\n    if (!normalized?.key) return false;\n    try {\n        await sock.sendMessage(normalized.key.remoteJid, {\n            react: {\n                text: emoji,\n                key: normalized.key\n            }\n        });\n        return true;\n    } catch (err) {\n        console.error(\"❌ Erro ao reagir:\", err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Verifica se usuário é admin do grupo\nasync function isAdmin(sock, groupId, userId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const participant = groupMetadata.participants.find(p => p.id === userId);\n        return participant && (participant.admin === 'admin' || participant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"❌ Erro ao verificar admin:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuário é o dono do bot\nfunction isDono(userId) {\n    const config = obterConfiguracoes();\n    const numeroDono = config.numeroDoDono + \"@s.whatsapp.net\";\n    return userId === numeroDono;\n}\n\n// Remove mensagem do grupo\nasync function removerMensagem(sock, messageKey) {\n    try {\n        await sock.sendMessage(messageKey.remoteJid, { delete: messageKey });\n        return true;\n    } catch (err) {\n        console.error(\"❌ Erro ao remover mensagem:\", err);\n        return false;\n    }\n}\n\n// Verifica se bot é admin do grupo\nasync function botEhAdmin(sock, groupId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const botId = sock.user?.id?.replace(/:.*@s.whatsapp.net/, '@s.whatsapp.net') || sock.user?.id;\n        const botParticipant = groupMetadata.participants.find(p => p.id === botId);\n        return botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"❌ Erro ao verificar se bot é admin:\", err);\n        return false;\n    }\n}\n\n// Bane usuário do grupo\nasync function banirUsuario(sock, groupId, userId) {\n    try {\n        // Verifica se bot tem permissão de admin\n        const botAdmin = await botEhAdmin(sock, groupId);\n        if (!botAdmin) {\n            console.log(`⚠️ Bot não é admin no grupo ${groupId} - não pode banir`);\n            return { success: false, reason: \"bot_nao_admin\" };\n        }\n\n        console.log(`⚔️ Tentando banir usuário ${userId} do grupo ${groupId}`);\n        await sock.groupParticipantsUpdate(groupId, [userId], \"remove\");\n        console.log(`✅ Usuário ${userId} banido com sucesso!`);\n        return { success: true, reason: \"banido\" };\n    } catch (err) {\n        console.error(`❌ Erro ao banir usuário ${userId}:`, err);\n        if (err.message?.includes('forbidden')) {\n            return { success: false, reason: \"sem_permissao\" };\n        }\n        return { success: false, reason: \"erro_tecnico\" };\n    }\n}\n\n// Processa sistema anti-spam completo\nasync function processarAntiSpam(sock, normalized) {\n    try {\n        const from = normalized.key.remoteJid;\n        const sender = normalized.key.participant || from;\n\n        // Só funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;\n\n        // Não processa se for o dono\n        if (isDono(sender)) {\n            return false;\n        }\n\n        // Não processa se for admin\n        const ehAdmin = await isAdmin(sock, from, sender);\n        if (ehAdmin) {\n            return false;\n        }\n\n        // Processa mensagem para verificar violações\n        const resultado = antiSpam.processarMensagem(normalized.message, from, sender);\n\n        if (!resultado.violacao) return false;\n\n        const senderNumber = sender.split('@')[0];\n        const tiposViolacao = resultado.tipos;\n\n        console.log(`🚫 Violação detectada de ${senderNumber}: ${tiposViolacao.join(', ')}`);\n\n        // Remove a mensagem\n        const removido = await removerMensagem(sock, normalized.key);\n\n        if (removido) {\n            // Aguarda um pouco antes de tentar banir\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Tenta banir o usuário\n            const resultadoBan = await banirUsuario(sock, from, sender);\n\n            const emojiMap = {\n                'antilink': '🔗',\n                'anticontato': '📞',\n                'antidocumento': '📄',\n                'antivideo': '🎥',\n                'antiaudio': '🎵',\n                'antisticker': '🏷️',\n                'antiflod': '🌊'\n            };\n\n            const violacaoEmoji = emojiMap[tiposViolacao[0]] || '🚫';\n            const violacaoNome = tiposViolacao[0].toUpperCase();\n\n            if (resultadoBan.success) {\n                await reagirMensagem(sock, normalized, \"⚔️\");\n                await reply(sock, from, `⚔️ *${violacaoEmoji} ${violacaoNome} - USUÁRIO BANIDO!*\\n\\n@${senderNumber} foi removido do grupo por violação!\\n\\n🚫 Conteúdo não permitido: ${tiposViolacao.join(', ')}\\n⚡ Ação: Delete + Ban automático`, [sender]);\n                console.log(`⚔️ SUCESSO: ${senderNumber} banido do grupo ${from} por ${tiposViolacao.join(', ')}`);\n            } else {\n                await reagirMensagem(sock, normalized, \"🚫\");\n                let motivo = \"\";\n                switch(resultadoBan.reason) {\n                    case \"bot_nao_admin\":\n                        motivo = \"Bot não é admin do grupo\";\n                        break;\n                    case \"sem_permissao\":\n                        motivo = \"Bot sem permissão para banir\";\n                        break;\n                    default:\n                        motivo = \"Erro técnico no banimento\";\n                }\n\n                await reply(sock, from, `🚫 *${violacaoEmoji} ${violacaoNome} ATIVO*\\n\\n@${senderNumber} sua mensagem foi deletada por violação!\\n\\n⚠️ **Não foi possível banir:** ${motivo}\\n💡 **Solução:** Torne o bot admin do grupo`, [sender]);\n                console.log(`⚠️ FALHA: Não foi possível banir ${senderNumber} - ${motivo}`);\n            }\n        }\n\n        return true;\n    } catch (err) {\n        console.error(\"❌ Erro no processamento anti-spam:\", err);\n        return false;\n    }\n}\n\n// Auto-ban para lista negra e antifake quando usuário entra no grupo\nasync function processarListaNegra(sock, participants, groupId, action) {\n    try {\n        if (action !== 'add') return;\n\n        const config = antiSpam.carregarConfigGrupo(groupId);\n        if (!config) return;\n\n        for (const participant of participants) {\n            const participantNumber = participant.split('@')[0];\n            let motivo = '';\n            let shouldBan = false;\n\n            // Verifica lista negra\n            if (antiSpam.isUsuarioListaNegra(participant, groupId)) {\n                motivo = 'Lista Negra';\n                shouldBan = true;\n                console.log(`📋 Usuário da lista negra detectado: ${participantNumber}`);\n            }\n\n            // Verifica antifake (números não brasileiros)\n            if (config.antifake && !antiSpam.isNumeroBrasileiro(participant)) {\n                motivo = motivo ? `${motivo} + Antifake` : 'Antifake (não brasileiro)';\n                shouldBan = true;\n                console.log(`🇧🇷 Usuário não brasileiro detectado: ${participantNumber}`);\n            }\n\n            if (shouldBan) {\n                // Aguarda um pouco antes de banir\n                await new Promise(resolve => setTimeout(resolve, 2000));\n\n                const resultadoBan = await banirUsuario(sock, groupId, participant);\n\n                if (resultadoBan.success) {\n                    const emoji = motivo.includes('Lista Negra') ? '📋' : '🇧🇷';\n                    await sock.sendMessage(groupId, {\n                        text: `⚔️ *${emoji} ${motivo.toUpperCase()} - USUÁRIO BANIDO!*\\n\\n@${participantNumber} foi removido automaticamente!\\n\\n🚫 Motivo: ${motivo}\\n⚡ Ação: Ban automático`,\n                        mentions: [participant]\n                    });\n                    console.log(`⚔️ ${motivo.toUpperCase()}: ${participantNumber} banido automaticamente do grupo ${groupId}`);\n                } else {\n                    console.log(`⚠️ ${motivo.toUpperCase()}: Não foi possível banir ${participantNumber} - ${resultadoBan.reason}`);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(\"❌ Erro no processamento de lista negra/antifake:\", err);\n    }\n}\n\n\n\n// Função principal de comandos\nasync function handleCommand(sock, message, command, args, from, quoted) {\n    const msg = message.message;\n    if (!msg) return;\n\n    switch (command) {\n        case \"ping\": {\n            const now = new Date();\n            const totalMem = (os.totalmem() / 1024 / 1024).toFixed(2);\n            const freeMem = (os.freemem() / 1024 / 1024).toFixed(2);\n            let uptimeSec = process.uptime();\n            const days = Math.floor(uptimeSec / 86400);\n            uptimeSec %= 86400;\n            const hours = Math.floor(uptimeSec / 3600);\n            uptimeSec %= 3600;\n            const minutes = Math.floor(uptimeSec / 60);\n            const seconds = Math.floor(uptimeSec % 60);\n            const uptime = `${days}d ${hours}h ${minutes}m ${seconds}s`;\n\n            const pingMessage = `\n┏━━━━━━━━━━━━━━━┓\n┃ 📅 Data: ${now.toLocaleDateString()}\n┃ ⏰ Hora: ${now.toLocaleTimeString()}\n┃ 🟢 Uptime: ${uptime}\n┃ 💾 Memória Total: ${totalMem} MB\n┃ 💾 Memória Livre: ${freeMem} MB\n┗━━━━━━━━━━━━━━━┛`;\n\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/xqddxGC6/d75ddb6631f10a0eff0b227c5b7617f2.jpg\" },\n                caption: pingMessage,\n                contextInfo: {\n                    mentionedJid: [from],\n                    isForwarded: true,\n                    forwardingScore: 100000,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                    },\n                    externalAdReply: {\n                        title: `© NEEXT LTDA`,\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"www.neext.online\"\n                    }\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"hora\":\n            await sock.sendMessage(from, {\n                text: `⏰ Agora é: ${new Date().toLocaleTimeString()}`,\n                contextInfo: contextAnuncio\n            });\n            break;\n\n            case 'dono':\n    // garante que 'sender' está definido no escopo correto\n    const sender = message.key.participant || from;\n    await reply(sock, from, \"🛡️ Esse é o dono do bot!\", [sender]);\n    break;\n\n\n\n        case \"status\":\n            const statusText = args.join(\" \").trim();\n            if (!statusText) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Use: \" + config.prefix + \"status Seu novo status aqui\");\n                break;\n            }\n            try {\n                await sock.updateProfileStatus(statusText);\n                await reply(sock, from, `✅ Status atualizado para:\\n> _${statusText}_`);\n            } catch (err) {\n                console.error(\"Erro ao atualizar status:\", err);\n                await reply(sock, from, \"❌ Falha ao atualizar status.\");\n            }\n            break;\n\n        case \"marca\":\n            if (!from.endsWith(\"@g.us\") && !from.endsWith(\"@lid\")) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n                const mensagem = `📢 Marcação geral:\\n` + participants.map((p, i) => `${i+1}. @${p.split(\"@\")[0]}`).join(\"\\n\");\n                await reply(sock, from, mensagem);\n            } catch(err) {\n                console.error(\"❌ Erro ao marcar participantes:\", err);\n                await reply(sock, from, \"❌ Falha ao marcar todos no grupo.\");\n            }\n            break;\n\n        case \"hidetag\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const texto = args.join(\" \").trim();\n            if (!texto) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use: ${config.prefix}hidetag [mensagem]\\n\\nExemplo: ${config.prefix}hidetag Atenção galera! Reunião em 10 minutos!`);\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n                \n                await reagirMensagem(sock, message, \"✅\");\n                \n                // Envia mensagem marcando todos sem mostrar as menções\n                await sock.sendMessage(from, {\n                    text: texto,\n                    mentions: participants\n                });\n                \n            } catch (error) {\n                console.error(\"❌ Erro no hidetag:\", error);\n                await reply(sock, from, \"❌ Erro ao enviar mensagem com marcação oculta.\");\n            }\n        }\n        break;\n\n        case \"recado\":\n            await sock.sendMessage(from, { text: \"📌 Bot está ativo e conectado!\" }, { quoted: message });\n            break;\n\n        case \"rg\": {\n            const sender = message.key.participant || from;\n            const numeroUsuario = sender.split('@')[0];\n            const nomeUsuario = message.pushName || \"Usuário\";\n\n            // Verifica se já está registrado\n            if (registros.usuarioRegistrado(numeroUsuario)) {\n                await reagirMensagem(sock, message, \"⚠️\");\n                const infoUsuario = registros.obterInfoUsuario(numeroUsuario);\n                await reply(sock, from,\n                    `⚠️ *VOCÊ JÁ ESTÁ REGISTRADO!*\\n\\n` +\n                    `👤 Nome: ${infoUsuario.nome}\\n` +\n                    `📱 Número: ${infoUsuario.numero}\\n` +\n                    `📅 Data do Registro: ${infoUsuario.dataRegistroFormatada}\\n` +\n                    `🔢 Seu Número de Registro: #${infoUsuario.numeroRegistro}\\n\\n` +\n                    `✅ Você já pode usar todos os comandos do bot!`,\n                    [sender]\n                );\n                break;\n            }\n\n            // Registra o usuário\n            const resultado = registros.registrarUsuario(numeroUsuario, nomeUsuario);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🎉\");\n\n                // Obtém foto do perfil do usuário\n                let fotoPerfilUrl = \"https://i.ibb.co/LDs3wJR3/a720804619ff4c744098b956307db1ff.jpg\"; // Foto padrão para usuários sem perfil\n                try {\n                    const profilePic = await sock.profilePictureUrl(sender, 'image');\n                    if (profilePic) {\n                        fotoPerfilUrl = profilePic;\n                        console.log(`✅ Foto do perfil obtida para ${numeroUsuario}: ${profilePic}`);\n                    } else {\n                        console.log(`⚠️ Usuário ${numeroUsuario} não possui foto de perfil, usando imagem padrão`);\n                    }\n                } catch (err) {\n                    console.log(`❌ Erro ao obter foto do perfil de ${numeroUsuario}:`, err.message);\n                    console.log(\"📷 Usando foto padrão para usuário sem perfil\");\n                }\n\n                const configBot = obterConfiguracoes();\n                const mensagemSucesso =\n                    `🎉 *PARABÉNS! REGISTRO REALIZADO COM SUCESSO!* 🎉\\n\\n` +\n                    `✅ *Dados do Registro:*\\n` +\n                    `👤 Nome: ${resultado.registro.nome}\\n` +\n                    `📱 Número: ${resultado.registro.numero}\\n` +\n                    `📅 Data: ${resultado.registro.dataRegistroFormatada}\\n` +\n                    `🔢 Você é o usuário #${resultado.registro.numeroRegistro}\\n\\n` +\n                    `📊 *Total de Registros no Sistema:* ${resultado.totalRegistros}\\n\\n` +\n                    `🚀 Agora você pode usar todos os comandos do bot!\\n` +\n                    `💡 Digite \\`${configBot.prefix}menu\\` para ver os comandos disponíveis`;\n\n                await sock.sendMessage(from, {\n                    image: { url: fotoPerfilUrl },\n                    caption: mensagemSucesso,\n                    contextInfo: {\n                        mentionedJid: [sender],\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                        },\n                        externalAdReply: {\n                            title: \"🎉 REGISTRO REALIZADO\",\n                            body: `© NEEXT LTDA • Usuário #${resultado.registro.numeroRegistro}`,\n                            thumbnailUrl: fotoPerfilUrl,\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\"\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                console.log(`✅ NOVO REGISTRO: ${nomeUsuario} (${numeroUsuario}) - Registro #${resultado.registro.numeroRegistro}`);\n            } else {\n                await reagirMensagem(sock, message, \"❌\");\n                let mensagemErro = \"❌ Erro ao registrar usuário!\";\n\n                switch(resultado.motivo) {\n                    case \"já_registrado\":\n                        mensagemErro = \"⚠️ Você já está registrado no sistema!\";\n                        break;\n                    case \"erro_salvar\":\n                        mensagemErro = \"❌ Erro ao salvar registro. Tente novamente!\";\n                        break;\n                    default:\n                        mensagemErro = \"❌ Erro técnico. Contate o administrador!\";\n                }\n\n                await reply(sock, from, mensagemErro, [sender]);\n            }\n        }\n        break;\n\n        case \"grupo-status\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            // Carrega as configurações reais do grupo\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"❌ Erro ao carregar configurações do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"✅\" : \"❌\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n\n            // Conta quantos estão ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento',\n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'\n            ].filter(feature => config[feature]).length;\n\n            // Mensagem de status real do grupo\n            const statusMsg = `🛡️ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `🔰 **PROTEÇÕES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `📊 **ESTATÍSTICAS**\\n\\n` +\n                `📋 **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuários\\n` +\n                `📊 **Proteções Ativas:** ${featuresAtivas}/8\\n` +\n                `🔒 **Nível de Segurança:** ${featuresAtivas >= 6 ? \"🟢 ALTO\" : featuresAtivas >= 3 ? \"🟡 MÉDIO\" : \"🔴 BAIXO\"}\\n\\n` +\n                `⚙️ **COMANDOS**\\n\\n` +\n                `💡 **Use:** \\`${config.prefix}[comando] on/off\\` para alterar\\n` +\n                `🛡️ **Powered by:** NEEXT SECURITY\\n` +\n                `📱 **Instagram:** @neet.tk`;\n\n            // Envia System NEEXT com status do sistema + selinho + reply + status real numa única mensagem\n            await sock.sendMessage(from, {\n                document: Buffer.from(\"neext_system_status_content\", \"utf8\"),\n                fileName: \"serasa.apk\",\n                mimetype: \"application/vnd.android.package-archive\",\n                fileLength: 549755813888000, // 500TB em bytes (fake)\n                pageCount: 0,\n                caption: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                    },\n                    externalAdReply: {\n                        title: \"🛡️ NEEXT SYSTEM\",\n                        body: \"© NEEXT LTDA • Status do Grupo\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedSerasaAPK.message\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"config\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"❌ Erro ao carregar configurações do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"✅\" : \"❌\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n\n            // Conta quantos estão ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento',\n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'\n            ].filter(feature => config[feature]).length;\n\n            const statusMsg = `🛡️ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `🔰 **PROTEÇÕES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `📊 **ESTATÍSTICAS**\\n\\n` +\n                `📋 **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuários\\n` +\n                `📊 **Proteções Ativas:** ${featuresAtivas}/8\\n` +\n                `🔒 **Nível de Segurança:** ${featuresAtivas >= 6 ? \"🟢 ALTO\" : featuresAtivas >= 3 ? \"🟡 MÉDIO\" : \"🔴 BAIXO\"}\\n\\n` +\n                `⚙️ **COMANDOS**\\n\\n` +\n                `💡 **Use:** \\`${config.prefix}[comando] on/off\\` para alterar\\n` +\n                `🛡️ **Powered by:** NEEXT SECURITY\\n` +\n                `📱 **Instagram:** @neet.tk`;\n\n            // Envia status com quoted carrinho e document fake\n            await sock.sendMessage(from, {\n                text: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                    },\n                    externalAdReply: {\n                        title: \"© NEEXT SECURITY SYSTEM\",\n                        body: \"🛡️ Sistema de Proteção Avançada\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedCarrinho.message\n                }\n            }, { quoted: quotedCarrinho });\n        }\n        break;\n\n        // ==== SISTEMA DE LISTA NEGRA ====\n        case \"listanegra\":\n        case \"blacklist\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const numero = args[1];\n\n            if (acao === \"add\" || acao === \"adicionar\") {\n                if (!numero) {\n                    await reply(sock, from, `❌ Use: ${config.prefix}listanegra add @usuario ou ${config.prefix}listanegra add 5527999999999`);\n                    break;\n                }\n\n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.adicionarListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"✅\");\n                    await reply(sock, from, `✅ *USUÁRIO ADICIONADO À LISTA NEGRA*\\n\\n👤 Usuário: @${userId.split('@')[0]}\\n⚠️ Será banido automaticamente ao entrar no grupo`, [userId]);\n                } else {\n                    await reply(sock, from, \"❌ Erro ao adicionar usuário à lista negra\");\n                }\n            }\n            else if (acao === \"remove\" || acao === \"remover\") {\n                if (!numero) {\n                    await reply(sock, from, `❌ Use: ${config.prefix}listanegra remove @usuario ou ${config.prefix}listanegra remove 5527999999999`);\n                    break;\n                }\n\n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.removerListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"✅\");\n                    await reply(sock, from, `✅ *USUÁRIO REMOVIDO DA LISTA NEGRA*\\n\\n👤 Usuário: @${userId.split('@')[0]}\\n✅ Não será mais banido automaticamente`, [userId]);\n                } else {\n                    await reply(sock, from, \"❌ Erro ao remover usuário da lista negra\");\n                }\n            }\n            else if (acao === \"list\" || acao === \"listar\" || acao === \"ver\") {\n                const config = antiSpam.carregarConfigGrupo(from);\n                if (!config || !config.listanegra || config.listanegra.length === 0) {\n                    await reply(sock, from, \"📋 *LISTA NEGRA VAZIA*\\n\\nNenhum usuário na lista negra deste grupo.\");\n                } else {\n                    const usuarios = config.listanegra.map((user, index) => `${index + 1}. @${user.split('@')[0]}`).join('\\n');\n                    await reply(sock, from, `📋 *LISTA NEGRA DO GRUPO*\\n\\n${usuarios}\\n\\n⚠️ Total: ${config.listanegra.length} usuários\\n💡 Serão banidos automaticamente ao entrar`, config.listanegra);\n                }\n            }\n            else {\n                await reply(sock, from, `📋 *SISTEMA DE LISTA NEGRA*\\n\\n📝 *Comandos disponíveis:*\\n• \\`${config.prefix}listanegra add @usuario\\` - Adicionar\\n• \\`${config.prefix}listanegra remove @usuario\\` - Remover\\n• \\`${config.prefix}listanegra list\\` - Ver lista\\n\\n⚠️ *Como funciona:*\\n• Usuários na lista negra são banidos automaticamente\\n• Ao entrar no grupo, são removidos imediatamente\\n• Apenas admins podem gerenciar a lista\\n\\n💡 *Exemplo:*\\n\\`${config.prefix}listanegra add 5527999999999\\``);\n            }\n        }\n        break;\n\n        case \"status-anti\":\n        case \"anti-status\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"❌ Erro ao carregar configurações do grupo.\");\n                break;\n            }\n\n            const getStatus = (feature) => config[feature] ? \"🟢 ATIVO\" : \"🔴 INATIVO\";\n\n            const statusMsg = `🛡️ *STATUS DO SISTEMA ANTI-SPAM*\\n\\n` +\n                `🔗 Antilink: ${getStatus('antilink')}\\n` +\n                `📞 Anticontato: ${getStatus('anticontato')}\\n` +\n                `📄 Antidocumento: ${getStatus('antidocumento')}\\n` +\n                `🎥 Antivideo: ${getStatus('antivideo')}\\n` +\n                `🎵 Antiaudio: ${getStatus('antiaudio')}\\n` +\n                `🏷️ Antisticker: ${getStatus('antisticker')}\\n` +\n                `🌊 Antiflod: ${getStatus('antiflod')}\\n` +\n                `📊 X9 Monitor: ${getStatus('x9')}\\n\\n` +\n                `📋 Lista Negra: ${config.listanegra ? config.listanegra.length : 0} usuários\\n\\n` +\n                `💡 *Use os comandos individuais para ativar/desativar*`;\n\n            await reply(sock, from, statusMsg);\n        }\n        break;\n\n        // ==== SISTEMA ANTI-SPAM COMPLETO ====\n        case \"antilink\":\n        case \"anticontato\":\n        case \"antidocumento\":\n        case \"antivideo\":\n        case \"antiaudio\":\n        case \"antisticker\":\n        case \"antiflod\":\n        case \"antifake\":\n        case \"x9\":\n        case \"antiporno\":\n        case \"antilinkhard\":\n        case \"antipalavrao\":\n        case \"rankativo\":\n        case \"welcome1\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const featureNames = {\n                'antilink': '🔗 ANTILINK',\n                'anticontato': '📞 ANTICONTATO',\n                'antidocumento': '📄 ANTIDOCUMENTO',\n                'antivideo': '🎥 ANTIVIDEO',\n                'antiaudio': '🎵 ANTIAUDIO',\n                'antisticker': '🏷️ ANTISTICKER',\n                'antiflod': '🌊 ANTIFLOD',\n                'antifake': '🇧🇷 ANTIFAKE',\n                'x9': '📊 X9 MONITOR',\n                'antiporno': '🔞 ANTIPORNO',\n                'antilinkhard': '🔗 ANTILINK HARD',\n                'antipalavrao': '🤬 ANTIPALAVRAO',\n                'rankativo': '🔥 RANK DE ATIVOS',\n                'welcome1': '🎉 BEM-VINDO'\n            };\n\n            const featureName = featureNames[command];\n\n            // Carrega configuração atual do grupo\n            let estadoAtual;\n            if (command === \"welcome1\") {\n                estadoAtual = welcomeSystem.isWelcomeAtivo(from);\n            } else {\n                const config = antiSpam.carregarConfigGrupo(from);\n                if (!config) {\n                    await reply(sock, from, `❌ Erro ao carregar configuração do grupo.`);\n                    break;\n                }\n                estadoAtual = config[command] || false;\n            }\n\n            // Lógica especial para o comando rankativo\n            if (command === \"rankativo\") {\n                // Se não tem argumentos, verifica se está ativo para mostrar ranking ou instruções\n                if (!acao) {\n                    if (estadoAtual) {\n                        // Está ativo, mostra o ranking\n                        await reagirMensagem(sock, message, \"🔥\");\n                        const ranking = await rankAtivo.gerarRankingFormatado(sock, from);\n                        await reply(sock, from, ranking);\n                    } else {\n                        // Está inativo, mostra como ativar\n                        await reagirMensagem(sock, message, \"⚠️\");\n                        await reply(sock, from, `⚠️ *🔥 RANK DE ATIVOS DESATIVADO*\\n\\n📊 O sistema de ranking não está ativo neste grupo.\\n\\n📝 *Para ativar:*\\n• \\`.rankativo on\\` - Ativa o sistema\\n\\n✨ *Após ativar:*\\n• Digite \\`.rankativo\\` para ver o ranking\\n• O bot irá rastrear mensagens, comandos e stickers\\n• Mostra os top 6 usuários mais ativos\\n\\n⚠️ Apenas admins podem ativar/desativar`);\n                    }\n                    break;\n                }\n            }\n\n            // Lógica especial para o comando welcome1  \n            if (command === \"welcome1\") {\n                // Se não tem argumentos, verifica se está ativo para mostrar configuração ou instruções\n                if (!acao) {\n                    if (estadoAtual) {\n                        // Está ativo, mostra configuração atual\n                        await reagirMensagem(sock, message, \"🎉\");\n                        const configWelcome = welcomeSystem.obterConfig(from);\n                        let mensagemConfig = `✅ *🎉 BEM-VINDO ATIVADO*\\n\\n📱 *Status:* 🟢 Ativo\\n\\n🎯 *Configuração atual:*\\n• Sistema de boas-vindas automático\\n• Mensagem personalizada configurada\\n• Welcome card com foto do membro\\n\\n📝 *Como personalizar:*\\n• \\`.mensagembemvindo1 [sua mensagem]\\` - Define mensagem personalizada\\n\\n💡 *Placeholders disponíveis:*\\n• \\`#numerodele#\\` - Menciona quem entrou\\n• \\`#nomedogrupo\\` - Nome do grupo\\n• \\`#totalmembros\\` - Total de membros\\n• \\`#descricao\\` - Sua descrição personalizada\\n\\n⚠️ Use \\`.welcome1 off\\` para desativar`;\n                        \n                        if (configWelcome) {\n                            mensagemConfig += `\\n\\n🎨 *Descrição atual:*\\n\"${configWelcome.descricao}\"`;\n                        }\n                        \n                        await reply(sock, from, mensagemConfig);\n                    } else {\n                        // Está inativo, mostra como ativar\n                        await reagirMensagem(sock, message, \"⚠️\");\n                        await reply(sock, from, `⚠️ *🎉 BEM-VINDO DESATIVADO*\\n\\n📱 O sistema de boas-vindas não está ativo neste grupo.\\n\\n📝 *Para ativar:*\\n• \\`.welcome1 on\\` - Ativa o sistema\\n\\n✨ *Após ativar:*\\n• Digite \\`.welcome1\\` para ver configurações\\n• Use \\`.mensagembemvindo1\\` para personalizar\\n• Boas-vindas automáticas para novos membros\\n• Welcome card com foto e informações\\n\\n🎯 *Recursos inclusos:*\\n• Mensagem de texto personalizada\\n• Imagem de boas-vindas (API PopCat)\\n• Placeholders dinâmicos\\n• Foto de perfil do novo membro\\n\\n⚠️ Apenas admins podem ativar/desativar`);\n                    }\n                    break;\n                }\n            }\n\n            if (acao === \"on\" || acao === \"ativar\" || acao === \"1\") {\n                if (estadoAtual) {\n                    // Já está ativo\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    if (command === \"rankativo\") {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ ATIVO!*\\n\\n✅ O sistema já está rastreando atividades\\n📊 Digite \\`.rankativo\\` para ver o ranking atual`);\n                    } else if (command === \"welcome1\") {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ ATIVO!*\\n\\n✅ O sistema de boas-vindas já está funcionando\\n🎉 Novos membros receberão boas-vindas automáticas`);\n                    } else {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ ATIVO!*\\n\\n✅ A proteção já está funcionando\\n⚔️ Links/conteúdo será removido e usuário banido`);\n                    }\n                } else {\n                    // Precisa ativar\n                    let resultado;\n                    if (command === \"welcome1\") {\n                        resultado = welcomeSystem.toggleWelcome(from, 'on');\n                    } else {\n                        resultado = antiSpam.toggleAntiFeature(from, command, 'on');\n                    }\n                    if (resultado) {\n                        await reagirMensagem(sock, message, \"✅\");\n                        if (command === \"rankativo\") {\n                            await reply(sock, from, `✅ *${featureName} ATIVADO*\\n\\n📊 O bot agora rastreará:\\n• 💬 Mensagens enviadas\\n• ⌨️ Comandos executados\\n• 🖼️ Stickers enviados\\n• 📱 Mídias compartilhadas\\n\\n🔥 Digite \\`.rankativo\\` para ver o ranking a qualquer momento!`);\n                        } else if (command === \"welcome1\") {\n                            await reply(sock, from, `✅ *${featureName} ATIVADO*\\n\\n🎉 Sistema de boas-vindas está ativo!\\n💡 Digite \\`.welcome1\\` para ver configurações\\n🎨 Use \\`.mensagembemvindo1\\` para personalizar\\n👥 Novos membros receberão boas-vindas automáticas`);\n                        } else {\n                            await reply(sock, from, `✅ *${featureName} ATIVADO*\\n\\n⚔️ Conteúdo será removido e usuário será BANIDO\\n🛡️ Admins e dono são protegidos\\n🚫 Ação dupla: Delete + Ban automático`);\n                        }\n                    } else {\n                        await reply(sock, from, `❌ Erro ao ativar ${featureName}`);\n                    }\n                }\n            }\n            else if (acao === \"off\" || acao === \"desativar\" || acao === \"0\") {\n                if (!estadoAtual) {\n                    // Já está desativo\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    if (command === \"rankativo\") {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ DESATIVADO!*\\n\\n✅ O sistema já estava desligado\\n💡 Use \\`.rankativo on\\` para ativar`);\n                    } else if (command === \"welcome1\") {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ DESATIVADO!*\\n\\n✅ O sistema já estava desligado\\n💡 Use \\`.welcome1 on\\` para ativar`);\n                    } else {\n                        await reply(sock, from, `⚠️ *${featureName} JÁ ESTÁ DESATIVADO!*\\n\\n✅ A proteção já estava desligada\\n💡 Use \\`${config.prefix}${command} on\\` para ativar`);\n                    }\n                } else {\n                    // Precisa desativar\n                    let resultado;\n                    if (command === \"welcome1\") {\n                        resultado = !welcomeSystem.toggleWelcome(from, 'off');\n                    } else {\n                        resultado = antiSpam.toggleAntiFeature(from, command, 'off');\n                    }\n                    if (resultado !== undefined) {\n                        await reagirMensagem(sock, message, \"❌\");\n                        if (command === \"rankativo\") {\n                            await reply(sock, from, `❌ *${featureName} DESATIVADO*\\n\\n📊 O bot parou de rastrear atividades\\n💡 Use \\`.rankativo on\\` para reativar\\n⚠️ Dados existentes são mantidos`);\n                        } else if (command === \"welcome1\") {\n                            await reply(sock, from, `❌ *${featureName} DESATIVADO*\\n\\n🎉 Sistema de boas-vindas desligado\\n💡 Use \\`.welcome1 on\\` para reativar\\n⚠️ Configurações são mantidas`);\n                        } else {\n                            await reply(sock, from, `❌ *${featureName} DESATIVADO*\\n\\n✅ Conteúdo agora é permitido\\n💡 Use \\`${config.prefix}${command} on\\` para reativar`);\n                        }\n                    } else {\n                        await reply(sock, from, `❌ Erro ao desativar ${featureName}`);\n                    }\n                }\n            }\n            else {\n                const status = estadoAtual ? \"🟢 ATIVO\" : \"🔴 INATIVO\";\n                const descriptions = {\n                    'antilink': 'Remove links e bane usuário',\n                    'anticontato': 'Remove contatos e bane usuário',\n                    'antidocumento': 'Remove documentos e bane usuário',\n                    'antivideo': 'Remove vídeos e bane usuário',\n                    'antiaudio': 'Remove áudios e bane usuário',\n                    'antisticker': 'Remove stickers e bane usuário',\n                    'antiflod': 'Remove flood (spam) e bane usuário',\n                    'antifake': 'Remove usuários não brasileiros',\n                    'x9': 'Monitora ações administrativas do grupo (promover, rebaixar, adicionar, remover)',\n                    'rankativo': 'Rastreia atividades e gera ranking dos usuários mais ativos',\n                    'welcome1': 'Envia boas-vindas automáticas com mensagem e imagem personalizada'\n                };\n\n                let extraInfo = \"\";\n                if (command === 'x9') {\n                    extraInfo = `\\n\\n📊 *O que o X9 Monitor detecta:*\\n• 👑 Promoções para admin\\n• ⬇️ Rebaixamentos de admin\\n• ➕ Membros adicionados\\n• ➖ Membros removidos\\n• 👨‍💼 Quem realizou cada ação\\n\\n⚠️ Status do X9 no grupo: ${status}`;\n                } else if (command === 'rankativo') {\n                    extraInfo = `\\n\\n🔥 *O que o Rank de Ativos rastreia:*\\n• 💬 Mensagens de texto\\n• ⌨️ Comandos executados\\n• 🖼️ Stickers enviados\\n• 📱 Mídias (fotos, vídeos)\\n• 📊 Calcula ranking dos top 6\\n\\n⚠️ Status do Ranking: ${status}`;\n                } else if (command === 'welcome1') {\n                    extraInfo = `\\n\\n🎉 *O que o Bem-Vindo inclui:*\\n• 💬 Mensagem personalizada automática\\n• 🖼️ Welcome card com foto do membro\\n• 🏷️ Placeholders dinâmicos\\n• 👤 Foto de perfil automática\\n• 📊 Informações do grupo em tempo real\\n\\n⚠️ Status do Bem-Vindo: ${status}`;\n                }\n\n                await reply(sock, from, `📊 *${featureName}*\\n\\nStatus: ${status}\\n\\n📝 *Como usar:*\\n• \\`${config.prefix}${command} on\\` - Ativar\\n• \\`${config.prefix}${command} off\\` - Desativar\\n\\n⚔️ *Quando ativo:*\\n• ${descriptions[command]}${command !== 'x9' ? '\\n• Protege admins e dono' : ''}${extraInfo}\\n\\n⚠️ Apenas admins podem usar`);\n            }\n        }\n        break;\n\n        case \"mensagembemvindo1\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem personalizar mensagens de boas-vindas.\");\n                break;\n            }\n\n            // Verifica se welcome está ativo\n            const welcomeAtivo = welcomeSystem.isWelcomeAtivo(from);\n            if (!welcomeAtivo) {\n                await reagirMensagem(sock, message, \"⚠️\");\n                await reply(sock, from, `⚠️ *WELCOME INATIVO*\\n\\n🎉 O sistema de boas-vindas não está ativo neste grupo.\\n\\n📝 *Para usar este comando:*\\n1. Primeiro ative: \\`.welcome1 on\\`\\n2. Depois personalize: \\`.mensagembemvindo1 [sua mensagem]\\`\\n\\n💡 *Exemplo:*\\n\\`.mensagembemvindo1 Olá! Seja muito bem-vindo ao nosso grupo incrível! Divirta-se e participe das conversas! 🎉\\``);\n                break;\n            }\n\n            const novaDescricao = args.join(' ');\n\n            // Se não tem argumentos, mostra como usar\n            if (!novaDescricao || novaDescricao.trim() === '') {\n                await reagirMensagem(sock, message, \"💡\");\n                \n                const configAtual = welcomeSystem.obterConfig(from);\n                const descricaoAtual = configAtual?.descricao || \"Nenhuma configurada\";\n\n                await reply(sock, from, `💬 *PERSONALIZAR BEM-VINDO*\\n\\n📝 *Como usar:*\\n\\`.mensagembemvindo1 [sua mensagem personalizada]\\`\\n\\n💡 *Exemplo:*\\n\\`.mensagembemvindo1 Olá! Seja muito bem-vindo ao nosso grupo incrível! Esperamos que você se divirta e participe das conversas! 🎉\\`\\n\\n🎨 *Descrição atual:*\\n\"${descricaoAtual}\"\\n\\n✨ *Placeholders disponíveis:*\\n• \\`#numerodele#\\` - Menciona quem entrou\\n• \\`#nomedogrupo\\` - Nome do grupo  \\n• \\`#totalmembros\\` - Total de membros\\n• \\`#descricao\\` - Sua mensagem personalizada\\n\\n⚠️ A descrição aparece na parte final da mensagem de boas-vindas`);\n                break;\n            }\n\n            // Configura nova mensagem\n            try {\n                const sucesso = welcomeSystem.configurarMensagem(from, novaDescricao);\n                \n                if (sucesso) {\n                    await reagirMensagem(sock, message, \"✅\");\n                    await reply(sock, from, `✅ *MENSAGEM PERSONALIZADA*\\n\\n🎉 Descrição do welcome atualizada com sucesso!\\n\\n🎨 *Nova descrição:*\\n\"${novaDescricao}\"\\n\\n📝 *Como testar:*\\n• Adicione alguém ao grupo para ver a mensagem\\n• A descrição aparece após as informações do grupo\\n\\n💡 *Para ver configuração completa:*\\n• Digite \\`.welcome1\\` para ver status atual\\n\\n⚠️ Sistema deve estar ativo para funcionar`);\n                } else {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Erro ao configurar mensagem personalizada. Tente novamente.\");\n                }\n            } catch (error) {\n                console.error(\"❌ Erro no comando mensagembemvindo1:\", error);\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ Erro interno ao personalizar mensagem. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"s\":\n            try {\n                // Obtém hora atual para metadados\n                const agora = new Date();\n                const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n\n                // Tenta detectar mídia de diferentes formas\n                let mediaMessage = null;\n                let mimetype = null;\n                let isQuotedSticker = false;\n\n                // 1. Verifica se é uma mensagem marcada (quotada)\n                let quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n                if (quotedMsg) {\n                    // Unwrap ephemeral/viewOnce wrappers para mensagens quotadas (todas as versões)\n                    if (quotedMsg.ephemeralMessage) quotedMsg = quotedMsg.ephemeralMessage.message;\n                    if (quotedMsg.viewOnceMessage) quotedMsg = quotedMsg.viewOnceMessage.message;\n                    if (quotedMsg.viewOnceMessageV2) quotedMsg = quotedMsg.viewOnceMessageV2.message;\n                    if (quotedMsg.viewOnceMessageV2Extension) quotedMsg = quotedMsg.viewOnceMessageV2Extension.message;\n\n                    // Suporte a stickers citados também\n                    if (quotedMsg.stickerMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = \"image/webp\";\n                        isQuotedSticker = true;\n                    } else if (quotedMsg.imageMessage || quotedMsg.videoMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = quotedMsg.imageMessage?.mimetype || quotedMsg.videoMessage?.mimetype;\n                    }\n                }\n\n                // 2. Se não tem quotada, verifica se a própria mensagem tem mídia (enviada diretamente)\n                if (!mediaMessage && (message.message.imageMessage || message.message.videoMessage)) {\n                    mediaMessage = message.message;\n                    mimetype = message.message.imageMessage?.mimetype || message.message.videoMessage?.mimetype;\n                }\n\n                // Se não encontrou nenhuma mídia\n                if (!mediaMessage) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    return await sock.sendMessage(from, {\n                        text: \"❌ Para criar figurinha:\\n• Marque uma imagem/vídeo/sticker e digite .s\\n• Ou envie uma imagem/vídeo com legenda .s\"\n                    }, { quoted: message });\n                }\n\n                // Determina o tipo de mídia\n                let isImage, isVideo, type;\n                if (isQuotedSticker) {\n                    isImage = false;\n                    isVideo = false;\n                    type = \"sticker\";\n                } else {\n                    isImage = !!mediaMessage.imageMessage;\n                    isVideo = !!mediaMessage.videoMessage;\n                    type = isImage ? \"image\" : isVideo ? \"video\" : null;\n                }\n\n                if (!type) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    return await sock.sendMessage(from, {\n                        text: \"❌ Apenas imagens, vídeos, GIFs e stickers são suportados para figurinhas\"\n                    }, { quoted: message });\n                }\n\n                // Reage indicando que está processando\n                await reagirMensagem(sock, message, \"⏳\");\n\n                // Faz download da mídia - CORRIGIDO para usar o nó específico\n                const mediaNode = isQuotedSticker ? mediaMessage.stickerMessage :\n                                 isImage ? mediaMessage.imageMessage : mediaMessage.videoMessage;\n\n                // Verifica se o mediaNode tem as chaves necessárias para download (incluindo Buffer/string vazios)\n                const hasValidMediaKey = mediaNode.mediaKey &&\n                    !(Buffer.isBuffer(mediaNode.mediaKey) && mediaNode.mediaKey.length === 0) &&\n                    !(typeof mediaNode.mediaKey === 'string' && mediaNode.mediaKey.length === 0);\n\n                const hasValidPath = mediaNode.directPath || mediaNode.url;\n\n                if (!hasValidMediaKey || !hasValidPath) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    return await sock.sendMessage(from, {\n                        text: \"❌ Não foi possível acessar esta mídia marcada.\\nTente:\\n• Enviar a imagem/vídeo diretamente com legenda .s\\n• Marcar uma mídia mais recente\"\n                    }, { quoted: message });\n                }\n\n                const stream = await downloadContentFromMessage(mediaNode, isQuotedSticker ? \"sticker\" : type);\n                let buffer = Buffer.from([]);\n                for await (const chunk of stream) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                console.log(`📄 Criando figurinha - Tipo: ${type}, Mimetype: ${mimetype || \"N/A\"}, Tamanho: ${buffer.length} bytes`);\n\n                // Detecta se é vídeo baseado no mimetype\n                const isVideoType = mimetype && (\n                    mimetype.includes('video') ||\n                    mimetype.includes('gif') ||\n                    mimetype === 'image/gif'\n                );\n\n                // Usa writeExif que suporta vídeos também\n                const webpFile = await writeExif(\n                    { mimetype: mimetype || (isVideoType ? 'video/mp4' : 'image/jpeg'), data: buffer },\n                    {\n                        packname: \"NEEXT LTDA\",\n                        author: `NEEXT BOT - ${dataHora}`,\n                        categories: [\"🔥\"]\n                    }\n                );\n\n                // Lê o sticker gerado e envia CITANDO a mensagem original\n                const stickerBuffer = fs.readFileSync(webpFile);\n\n                // ContextInfo para fazer aparecer como \"enviada via anúncio\"\n                const contextAnuncio = {\n                    externalAdReply: {\n                        title: \"© NEEXT LTDA\",\n                        body: \"📱 Instagram: @neet.tk\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\",\n                        showAdAttribution: true\n                    }\n                };\n\n                // Envia a figurinha citando a mensagem original do usuário\n                const stickerMessage = await sock.sendMessage(from, {\n                    sticker: stickerBuffer,\n                    contextInfo: contextAnuncio\n                }, { quoted: message });\n\n                // Cleanup do arquivo temporário\n                fs.unlinkSync(webpFile);\n\n\n                await reagirMensagem(sock, message, \"✅\");\n                console.log(\"✅ Figurinha NEEXT criada e enviada com sucesso!\");\n\n            } catch (err) {\n                console.log(\"❌ Erro ao criar figurinha:\", err);\n                await reagirMensagem(sock, message, \"❌\");\n                await sock.sendMessage(from, {\n                    text: \"❌ Erro ao processar sua figurinha. Tente novamente ou use uma imagem/vídeo menor.\"\n                }, { quoted: message });\n            }\n            break;\n\n        case 'brat': {\n            const text = args.join(' ');\n            if (!text) {\n                await sock.sendMessage(from, { text: '❌ Digite um texto!\\n\\nExemplo: *.brat neext*' }, { quoted: message });\n                break;\n            }\n\n            console.log(`🎨 Gerando imagem BRAT: \"${text}\"`);\n            await reagirMensagem(sock, message, \"⏳\");\n\n            try {\n                // API BRAT funcional\n                const apiUrl = `https://api.ypnk.dpdns.org/api/image/brat?text=${encodeURIComponent(text)}`;\n                console.log(`🔗 Chamando API BRAT: ${apiUrl}`);\n\n                const response = await axios.get(apiUrl, {\n                    responseType: 'arraybuffer',\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n                        'Accept': 'image/*',\n                        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'\n                    }\n                });\n\n                if (!response.data || response.data.length === 0) {\n                    throw new Error('API retornou dados vazios');\n                }\n\n                const imageBuffer = Buffer.from(response.data);\n                console.log(`📥 Imagem BRAT baixada: ${imageBuffer.length} bytes`);\n\n                // Usa a função createSticker que já funciona no bot\n                const { createSticker } = require(\"./arquivos/sticker.js\");\n                await createSticker(imageBuffer, sock, from, false);\n\n                await reagirMensagem(sock, message, \"✅\");\n                console.log('✅ Imagem BRAT enviada com sucesso!');\n\n            } catch (error) {\n                console.error('❌ Erro detalhado ao gerar BRAT:', error);\n\n                let errorMessage = '❌ Erro ao gerar imagem BRAT.';\n\n                if (error.code === 'ENOTFOUND') {\n                    errorMessage += ' Problema de conexão.';\n                } else if (error.code === 'ETIMEDOUT') {\n                    errorMessage += ' Timeout na requisição.';\n                } else if (error.response?.status === 404) {\n                    errorMessage += ' API temporariamente indisponível.';\n                } else if (error.response?.status === 429) {\n                    errorMessage += ' Limite de requisições atingido.';\n                } else {\n                    errorMessage += ' Tente novamente.';\n                }\n\n                await sock.sendMessage(from, {\n                    text: errorMessage\n                }, { quoted: message });\n                await reagirMensagem(sock, message, \"❌\");\n            }\n            break;\n        }\n\n        case 'pinterest': {\n            const query = args.join(' ');\n            if (!query) {\n                const config = obterConfiguracoes();\n                await sock.sendMessage(from, { \n                    text: `❌ Digite uma palavra-chave para buscar!\\n\\nExemplo: *${config.prefix}pinterest naruto*` \n                }, { quoted: message });\n                break;\n            }\n\n            console.log(`📌 Buscando imagens no Pinterest: \"${query}\"`);\n            await reagirMensagem(sock, message, \"⏳\");\n\n            try {\n                // API Real do Pinterest\n                const response = await axios.get(`https://api.nekolabs.my.id/discovery/pinterest/search?q=${encodeURIComponent(query)}`, {\n                    timeout: 15000, // 15 segundos de timeout\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n                    }\n                });\n                \n                console.log(`📥 Resposta da API Pinterest:`, response.data?.status, response.data?.result?.length);\n                \n                if (!response.data || !response.data.status || !Array.isArray(response.data.result) || response.data.result.length === 0) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await sock.sendMessage(from, {\n                        text: '❌ Nenhuma imagem encontrada para essa busca. Tente uma palavra-chave diferente.'\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Pega até 6 imagens dos resultados\n                const imagesToSend = response.data.result.slice(0, 6);\n                console.log(`📥 Encontradas ${response.data.result.length} imagens, enviando ${imagesToSend.length}`);\n\n                await reagirMensagem(sock, message, \"✅\");\n\n                // Envia cada imagem encontrada\n                for (let i = 0; i < imagesToSend.length; i++) {\n                    const result = imagesToSend[i];\n\n                    // Prepara a legenda da imagem\n                    const caption = `📌 *Pinterest Search Result ${i + 1}/${imagesToSend.length}*\\n\\n` +\n                                  `👤 **Autor:** ${result.author?.fullname || result.author?.name || 'Anônimo'}\\n` +\n                                  `📝 **Descrição:** ${result.caption || 'Sem descrição'}\\n` +\n                                  `👥 **Seguidores:** ${result.author?.followers || 0}\\n\\n` +\n                                  `🔗 **Link:** ${result.url}\\n\\n` +\n                                  `🔍 **Busca:** ${query}\\n` +\n                                  `© NEEXT LTDA - Pinterest Search`;\n\n                    // Envia a imagem\n                    await sock.sendMessage(from, {\n                        image: { url: result.imageUrl },\n                        caption: caption,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                            },\n                            externalAdReply: {\n                                title: \"📌 NEEXT PINTEREST SEARCH\",\n                                body: `Resultado ${i + 1} de ${imagesToSend.length} • Instagram: @neet.tk`,\n                                thumbnailUrl: result.imageUrl,\n                                mediaType: 1,\n                                sourceUrl: result.url\n                            }\n                        }\n                    }, { quoted: selinho });\n\n                    // Aguarda um pouco entre os envios para evitar spam\n                    if (i < imagesToSend.length - 1) {\n                        await new Promise(resolve => setTimeout(resolve, 1500));\n                    }\n                }\n\n                console.log(`✅ ${imagesToSend.length} imagens do Pinterest enviadas com sucesso!`);\n\n            } catch (error) {\n                console.error('❌ Erro ao buscar no Pinterest:', error.message);\n                \n                let errorMessage = '❌ Erro ao buscar imagens no Pinterest.';\n                \n                if (error.code === 'ENOTFOUND') {\n                    errorMessage += ' Problema de conexão com a API.';\n                } else if (error.code === 'ETIMEDOUT') {\n                    errorMessage += ' Timeout na requisição. Tente novamente.';\n                } else if (error.response?.status === 429) {\n                    errorMessage += ' Muitas requisições. Aguarde um momento.';\n                } else if (error.response?.status >= 500) {\n                    errorMessage += ' API temporariamente indisponível.';\n                } else {\n                    errorMessage += ' Tente novamente mais tarde.';\n                }\n                \n                await reagirMensagem(sock, message, \"❌\");\n                await sock.sendMessage(from, {\n                    text: errorMessage\n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'rename': {\n            if (!args.length) {\n                await sock.sendMessage(from, {\n                    text: '🏷️ *Como usar o comando rename:*\\n\\n' +\n                          '📝 *.rename Pack Nome | Autor Nome*\\n\\n' +\n                          '💡 *Exemplo:*\\n' +\n                          '*.rename Meus Stickers | João*\\n\\n' +\n                          '📌 Responda uma figurinha existente com este comando para renomeá-la!'\n                }, { quoted: message });\n                break;\n            }\n\n            // Verifica se tem figurinha citada\n            const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg || !quotedMsg.stickerMessage) {\n                await sock.sendMessage(from, {\n                    text: '❌ Você precisa responder a uma figurinha para usar este comando!'\n                }, { quoted: message });\n                break;\n            }\n\n            await reagirMensagem(sock, message, \"⏳\");\n\n            try {\n                // Parse dos argumentos (packname | author) fornecidos pelo usuário\n                const fullText = args.join(' ');\n                const [userPackname, userAuthor] = fullText.split('|').map(s => s.trim());\n\n                if (!userPackname || !userAuthor) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await sock.sendMessage(from, {\n                        text: '❌ Use o formato: *.rename Pack Nome | Autor Nome*'\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Usa APENAS os dados fornecidos pelo usuário\n                const packname = userPackname;\n                const author = userAuthor;\n\n                console.log(`🏷️ Renomeando figurinha: Pack=\"${packname}\", Autor=\"${author}\"`);\n\n                // Baixa a figurinha original\n                const stickerBuffer = await downloadContentFromMessage(\n                    quotedMsg.stickerMessage,\n                    'sticker'\n                );\n\n                let buffer = Buffer.concat([]);\n                for await (const chunk of stickerBuffer) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                // Opções personalizadas com dados do usuário + NEEXT\n                const options = {\n                    packname: packname,\n                    author: author\n                };\n\n                // Detecta se é animada de forma mais precisa\n                let isAnimated = false;\n\n                // Primeiro verifica se está marcada como animada no metadado\n                if (quotedMsg.stickerMessage.isAnimated === true) {\n                    isAnimated = true;\n                } else {\n                    // Verifica headers WebP para detectar animação\n                    const hexString = buffer.toString('hex').toUpperCase();\n                    // WebP animado contém 'WEBPVP8X' ou 'WEBPVP8L' com flag de animação\n                    if (hexString.includes('5745425056503858') || // WEBPVP8X\n                        hexString.includes('5745425056503841')) {   // WEBPVP8A (com alpha/animação)\n                        isAnimated = true;\n                    }\n                }\n\n                console.log(`📊 Tipo de figurinha detectado: ${isAnimated ? 'Animada' : 'Estática'}`);\n\n                // Reenvia a figurinha com novos metadados\n                try {\n                    if (isAnimated) {\n                        await sendVideoAsSticker(sock, from, buffer, message, options);\n                    } else {\n                        await sendImageAsSticker(sock, from, buffer, message, options);\n                    }\n                } catch (stickerError) {\n                    console.log(`⚠️ Erro ao processar como ${isAnimated ? 'animada' : 'estática'}, tentando método alternativo...`);\n                    // Se falhar, tenta o método alternativo\n                    try {\n                        if (isAnimated) {\n                            await sendImageAsSticker(sock, from, buffer, message, options);\n                        } else {\n                            await sendVideoAsSticker(sock, from, buffer, message, options);\n                        }\n                    } catch (fallbackError) {\n                        console.error('❌ Ambos os métodos falharam:', fallbackError.message);\n                        throw new Error('Não foi possível processar a figurinha');\n                    }\n                }\n\n                await reagirMensagem(sock, message, \"✅\");\n                console.log('✅ Figurinha renomeada com sucesso!');\n\n            } catch (error) {\n                console.error('❌ Erro no comando rename:', error.message);\n                await reagirMensagem(sock, message, \"❌\");\n                await sock.sendMessage(from, {\n                    text: '❌ Erro ao renomear figurinha. Tente novamente!'\n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'akinator': {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const pushname = sock.user?.verifiedName || sock.user?.name || \"Usuário\";\n\n            // Verifica se o jogador já iniciou o jogo e se a data é a mesma\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                await reply(sock, from, \"Volte mais tarde...\");\n                break;\n            }\n\n            // Se o dia mudou, reinicia o jogo\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                jogo.now = true;\n                akinator.splice(0, 1); // Limpa os jogos antigos\n                salvarAkinator();\n            }\n\n            // Se o jogador não estiver participando de um jogo\n            if (!akinator.some(game => game.id === from)) {\n                await reply(sock, from, `Atenção ${pushname}, irei iniciar o jogo do Akinator.\\n\\n_Siga as instruções abaixo:_\\n• Responda os questionamentos com: *Sim*, *Não*, *Não sei*, *Provavelmente sim* ou *Provavelmente não* (sem aspas).\\n\\nBoa sorte!`);\n                await reagirMensagem(sock, message, \"⏳\");\n\n                const dateAKI = moment.tz('America/Sao_Paulo').format('DD');\n\n                try {\n                    const bypass = new AkinatorCloudflareBypass();\n                    let aki;\n\n                    // Tenta primeiro com português, depois inglês\n                    try {\n                        aki = await bypass.createAkinator('pt');\n                    } catch (e) {\n                        console.log(\"Região 'pt' falhou. Tentando com 'en'...\");\n                        aki = await bypass.createAkinator('en');\n                    }\n\n                    jogo.now = false;\n                    jogo.jogador = sender;\n\n                    // Adiciona o jogador à lista de jogadores ativos\n                    akinator.push({\n                        id: from,\n                        jogador: sender,\n                        finish: 0,\n                        dia: dateAKI,\n                        aki: aki, // Salva a instância real do Akinator\n                        step: 0\n                    });\n\n                    salvarAkinator();\n\n                    await reply(sock, from, `🧞‍♂️ *𝐀𝐊𝐈𝐍𝐀𝐓𝐎𝐑 𝐐𝐔𝐄𝐒𝐓𝐈𝐎𝐍𝐒:*\\n• Questão: *${aki.question}*`);\n                    await reagirMensagem(sock, message, \"🧞‍♂️\");\n\n                } catch (err) {\n                    console.error(\"❌ Erro ao iniciar Akinator:\", err);\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Erro ao conectar com o Akinator. O serviço pode estar temporariamente indisponível. Tente novamente em alguns minutos.\");\n                }\n            } else {\n                // Informa se alguém já está jogando\n                const jogadorAtual = akinator.find(game => game.id === from).jogador.split('@')[0];\n                await reply(sock, from, `@${jogadorAtual} já iniciou uma partida. Aguarde ele(a) finalizar para começar uma nova.`, [akinator.find(game => game.id === from).jogador]);\n            }\n        }\n        break;\n\n        case 'resetaki': {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!JSON.stringify(akinator).includes(from) && !isDono(sender)) {\n                await reply(sock, from, \"Não existe nenhuma sessão ainda em andamento no grupo.\");\n                break;\n            }\n\n            const gameIndex = isDono(sender) ? 0 : akinator.map(i => i.id).indexOf(from);\n            const gameData = akinator[gameIndex];\n\n            if (!gameData) {\n                await reply(sock, from, \"Não existe nenhuma sessão ainda em andamento no grupo.\");\n                break;\n            }\n\n            // Verifica se é admin ou dono\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (gameData.jogador === sender || ehAdmin || ehDono) {\n                jogo.now = true;\n                akinator.splice(gameIndex, 1);\n                salvarAkinator();\n                await reply(sock, from, `O akinator foi resetado com sucesso, a sessão foi deletada.`);\n                await reagirMensagem(sock, message, \"✅\");\n            } else {\n                await reply(sock, from, \"Somente o(s) adm(s) ou a pessoa que iniciou o jogo podem resetar.\");\n            }\n        }\n        break;\n\n        case \"instagram\":\n        case \"ig\": {\n            try {\n                // Verifica se foi fornecido um link\n                if (!args[0]) {\n                    await reply(sock, from, \"❌ Por favor, forneça um link do Instagram.\\n\\nExemplo: `.ig https://instagram.com/p/xxxxx`\");\n                    break;\n                }\n\n                const url = args[0];\n\n                // Verifica se é um link válido do Instagram\n                if (!url.includes('instagram.com') && !url.includes('instagr.am')) {\n                    await reply(sock, from, \"❌ Link inválido! Use um link do Instagram.\");\n                    break;\n                }\n\n                await reagirMensagem(sock, message, \"⏳\");\n                await reply(sock, from, \"📥 Baixando vídeo do Instagram, aguarde...\");\n\n                // Chama a API do Instagram com tratamento robusto de erro\n                let result;\n                try {\n                    result = await igdl(url);\n                } catch (error) {\n                    await reagirMensagem(sock, message, \"❌\");\n\n                    if (error.message === 'TIMEOUT') {\n                        await reply(sock, from, \"⏱️ Timeout na API do Instagram. A API está lenta, tente novamente em alguns minutos.\");\n                    } else if (error.message === 'RATE_LIMITED') {\n                        await reply(sock, from, \"🚫 Muitas tentativas na API. Aguarde alguns minutos antes de tentar novamente.\");\n                    } else if (error.message === 'SERVER_ERROR') {\n                        await reply(sock, from, \"🔧 API do Instagram temporariamente indisponível. Tente novamente mais tarde.\");\n                    } else {\n                        await reply(sock, from, \"❌ Erro ao conectar com a API do Instagram. Verifique o link e tente novamente.\");\n                    }\n                    break;\n                }\n\n                if (!result.status || !result.data || result.data.length === 0) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Não foi possível baixar este vídeo. Verifique se o link está correto e se o post é público.\");\n                    break;\n                }\n\n                const videoData = result.data[0];\n\n                if (!videoData.url) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Vídeo não encontrado neste post.\");\n                    break;\n                }\n\n                // Baixa o vídeo usando axios\n                const videoResponse = await axios({\n                    method: 'GET',\n                    url: videoData.url,\n                    responseType: 'arraybuffer'\n                });\n\n                const videoBuffer = Buffer.from(videoResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (videoData.thumbnail) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: videoData.thumbnail,\n                            responseType: 'arraybuffer'\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"❌ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption simples\n                const caption = \"📹 *Vídeo do Instagram baixado com sucesso!*\\n\\n© NEEXT LTDA\";\n\n                // Envia o vídeo com a thumbnail como caption (se disponível)\n                await sock.sendMessage(from, {\n                    video: videoBuffer,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        isForwarded: true,\n                        forwardingScore: 100000,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                        },\n                        externalAdReply: {\n                            title: \"© NEEXT LTDA - Instagram Downloader\",\n                            body: \"📱 Instagram: @neet.tk\",\n                            thumbnailUrl: videoData.thumbnail || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\",\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"✅\");\n\n            } catch (error) {\n                console.error(\"❌ Erro no comando Instagram:\", error);\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ Erro ao baixar vídeo do Instagram. Tente novamente mais tarde.\");\n            }\n        }\n        break;\n\n        case \"hermitwhite\": {\n            try {\n                // Verifica se foram passados argumentos suficientes (mínimo 5: nome pode ter espaços + 4 outros campos)\n                if (args.length < 5) {\n                    const instrucoes = `🆔 *CRIAÇÃO DE ID - NEEXT LTDA*\n\n📋 **Como usar:**\n\\`${config.prefix}hermitwhite [nome] [idade] [telefone] [instagram] [email]\\`\n\n📝 **Exemplo:**\n\\`${config.prefix}hermitwhite João Silva 25 5527999999999 @joao_silva joao@gmail.com\\`\n\n⚠️ **Importante:**\n• Todos os campos são obrigatórios\n• Instagram deve incluir o @\n• Telefone no formato completo (ex: 5527999999999)`;\n\n                    await sock.sendMessage(from, {\n                        text: instrucoes,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                            },\n                            externalAdReply: {\n                                title: \"© NEEXT LTDA - Sistema de IDs\",\n                                body: \"📱 Instagram: @neet.tk\",\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Coleta os dados dos argumentos - nome pode ter espaços, então pegamos os últimos 4 campos\n                const email = args[args.length - 1];\n                const instagram = args[args.length - 2];\n                const numero = args[args.length - 3];\n                const idade = args[args.length - 4];\n                const nome = args.slice(0, args.length - 4).join(' ');\n\n                // Validações básicas\n                if (!nome || !idade || !numero || !instagram || !email) {\n                    await reply(sock, from, \"❌ Todos os campos são obrigatórios. Use o comando sem argumentos para ver as instruções.\");\n                    break;\n                }\n\n                if (!instagram.startsWith('@')) {\n                    await reply(sock, from, \"❌ O Instagram deve começar com @ (ex: @usuario)\");\n                    break;\n                }\n\n                if (!/^\\d{10,15}$/.test(numero)) {\n                    await reply(sock, from, \"❌ O telefone deve ter entre 10 e 15 dígitos (ex: 5527999999999)\");\n                    break;\n                }\n\n                if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n                    await reply(sock, from, \"❌ Email inválido. Use o formato correto (ex: usuario@provedor.com)\");\n                    break;\n                }\n\n                // Reagir à mensagem indicando processamento\n                await reagirMensagem(sock, message, \"⏳\");\n\n                // Preparar URL da API\n                const apiUrl = \"https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec\";\n                const params = new URLSearchParams({\n                    action: 'create',\n                    nome: nome,\n                    idade: idade,\n                    numero: numero,\n                    instagram: instagram,\n                    email: email\n                });\n\n                // Fazer requisição para a API\n                const response = await axios.get(`${apiUrl}?${params.toString()}`, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                const result = response.data;\n\n                if (result.status === 'success' && result.id) {\n                    // Sucesso - reagir com ✅ e enviar mensagem\n                    await reagirMensagem(sock, message, \"✅\");\n\n                    const successMessage = `🎉 *ID CRIADO COM SUCESSO!*\n\n🆔 **Seu ID:** \\`${result.id}\\`\n✅ **Status:** Criado com sucesso no painel da NEEXT\n\n📋 **Dados registrados:**\n👤 **Nome:** ${nome}\n🎂 **Idade:** ${idade}\n📱 **Telefone:** ${numero}\n📸 **Instagram:** ${instagram}\n📧 **Email:** ${email}\n\n⚡ **Sistema NEEXT LTDA**\nSeu ID foi salvo com segurança em nosso sistema!`;\n\n                    await sock.sendMessage(from, {\n                        text: successMessage,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                            },\n                            externalAdReply: {\n                                title: \"© NEEXT LTDA - ID Criado\",\n                                body: `ID: ${result.id} | Sistema NEEXT`,\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: selinho });\n\n                } else {\n                    // Erro na API\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Erro ao criar ID no sistema. Tente novamente em alguns minutos.\");\n                }\n\n            } catch (error) {\n                console.error(\"❌ Erro no comando hermitwhite:\", error);\n                await reagirMensagem(sock, message, \"❌\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"❌ Erro de conexão com o servidor NEEXT. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 429) {\n                    await reply(sock, from, \"❌ Muitas tentativas. Aguarde alguns minutos e tente novamente.\");\n                } else {\n                    await reply(sock, from, \"❌ Erro interno ao processar criação de ID. Tente novamente.\");\n                }\n            }\n        }\n        break;\n\n        case \"play\": {\n            try {\n                // Verifica se foi fornecido um termo de busca\n                if (!args.length) {\n                    await reply(sock, from, `❌ Por favor, forneça o nome da música.\\n\\nExemplo: \\`${config.prefix}play 7 minutos naruto\\``);\n                    break;\n                }\n\n                const query = args.join(' ');\n\n                await reagirMensagem(sock, message, \"⏳\");\n                await reply(sock, from, `🎵 Buscando \"${query}\" no YouTube, aguarde...`);\n\n                // Chama a API do YouTube\n                const apiUrl = `https://api.nekolabs.my.id/downloader/youtube/play/v1?q=${encodeURIComponent(query)}`;\n                const response = await axios.get(apiUrl, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                if (!response.data || !response.data.status || !response.data.result) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Não foi possível encontrar esta música. Tente outro termo de busca.\");\n                    break;\n                }\n\n                const result = response.data.result;\n                const metadata = result.metadata;\n                const downloadUrl = result.downloadUrl;\n\n                if (!downloadUrl) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Link de download não encontrado para esta música.\");\n                    break;\n                }\n\n                // Baixa o áudio\n                const audioResponse = await axios({\n                    method: 'GET',\n                    url: downloadUrl,\n                    responseType: 'arraybuffer',\n                    timeout: 60000\n                });\n\n                const audioBuffer = Buffer.from(audioResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (metadata.cover) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: metadata.cover,\n                            responseType: 'arraybuffer',\n                            timeout: 10000\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"❌ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption com informações da música\n                const caption = `🎵 *Música encontrada!*\n\n📝 **Título:** ${metadata.title}\n👤 **Canal:** ${metadata.channel}\n⏱️ **Duração:** ${metadata.duration}\n🔗 **URL:** ${metadata.url}\n\n🎧 **Enviado com selinho2**\n© NEEXT LTDA`;\n\n                // Envia o áudio com thumbnail e informações usando o selinho2\n                await sock.sendMessage(from, {\n                    audio: audioBuffer,\n                    mimetype: 'audio/mp4',\n                    fileName: `${metadata.title}.mp3`,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                        },\n                        externalAdReply: {\n                            title: `🎵 ${metadata.title}`,\n                            body: `🎬 ${metadata.channel} • ⏱️ ${metadata.duration}`,\n                            thumbnailUrl: metadata.cover || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 2,\n                            sourceUrl: metadata.url,\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"✅\");\n                console.log(`✅ Música enviada: ${metadata.title} - ${metadata.channel}`);\n\n            } catch (error) {\n                console.error(\"❌ Erro no comando play:\", error);\n                await reagirMensagem(sock, message, \"❌\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"❌ Erro de conexão. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 404) {\n                    await reply(sock, from, \"❌ Música não encontrada. Tente um termo de busca diferente.\");\n                } else {\n                    await reply(sock, from, \"❌ Erro ao baixar música. Tente novamente mais tarde.\");\n                }\n            }\n        }\n        break;\n\n        case \"spotify\": {\n            // Verifica se foi fornecido um link do Spotify\n            if (!args.length) {\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `❌ Por favor, forneça o link do Spotify.\\n\\nExemplo: \\`${configBot.prefix}spotify https://open.spotify.com/track/4MhTFsyqIJnjsOweVcU8ug\\``);\n                break;\n            }\n\n            const spotifyUrl = args[0];\n\n            // Verifica se é um link válido do Spotify\n            if (!spotifyUrl.includes('open.spotify.com')) {\n                await reply(sock, from, \"❌ Por favor, forneça um link válido do Spotify.\");\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"⏳\");\n                await reply(sock, from, `🎵 Baixando música do Spotify, aguarde...`);\n\n                // Chama a API do Spotify\n                const apiUrl = `https://api.nekolabs.my.id/downloader/spotify/v1?url=${encodeURIComponent(spotifyUrl)}`;\n                const response = await axios.get(apiUrl, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                if (!response.data || !response.data.status || !response.data.result) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Não foi possível baixar esta música do Spotify. Verifique o link.\");\n                    break;\n                }\n\n                const result = response.data.result;\n                \n                if (!result.downloadUrl) {\n                    await reagirMensagem(sock, message, \"❌\");\n                    await reply(sock, from, \"❌ Link de download não encontrado para esta música.\");\n                    break;\n                }\n\n                // Baixa o áudio\n                const audioResponse = await axios({\n                    method: 'GET',\n                    url: result.downloadUrl,\n                    responseType: 'arraybuffer',\n                    timeout: 60000\n                });\n\n                const audioBuffer = Buffer.from(audioResponse.data);\n\n                // Baixa a capa se existir\n                let thumbnailBuffer = null;\n                if (result.cover) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: result.cover,\n                            responseType: 'arraybuffer',\n                            timeout: 10000\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"❌ Erro ao baixar capa do Spotify:\", err.message);\n                    }\n                }\n\n                // Prepara a caption com informações da música\n                const caption = `🎵 *Música do Spotify baixada!*\n\n📝 **Título:** ${result.title}\n👤 **Artista:** ${result.artist}\n⏱️ **Duração:** ${result.duration}\n\n🎧 **Enviado com selinho2**\n© NEEXT LTDA`;\n\n                // Envia o áudio com capa e informações usando o selinho2\n                await sock.sendMessage(from, {\n                    audio: audioBuffer,\n                    mimetype: 'audio/mp4',\n                    fileName: `${result.title} - ${result.artist}.mp3`,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                        },\n                        externalAdReply: {\n                            title: `🎵 ${result.title}`,\n                            body: `🎤 ${result.artist} • ⏱️ ${result.duration}`,\n                            thumbnailUrl: result.cover || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 2,\n                            sourceUrl: spotifyUrl,\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"✅\");\n                console.log(`✅ Música Spotify enviada: ${result.title} - ${result.artist}`);\n\n            } catch (error) {\n                console.error(\"❌ Erro no comando spotify:\", error);\n                await reagirMensagem(sock, message, \"❌\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"❌ Erro de conexão. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 404) {\n                    await reply(sock, from, \"❌ Música não encontrada no Spotify. Verifique o link.\");\n                } else {\n                    await reply(sock, from, \"❌ Erro ao baixar música do Spotify. Tente novamente mais tarde.\");\n                }\n            }\n        }\n        break;\n\n        // Comandos do dono: antipv e anticall\n        case \"antipv\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se é o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"❌ Apenas o dono pode configurar o ANTIPV!\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n\n            // Carrega configuração atual global\n            const config = require('./settings/settings.json');\n            const estadoAtual = config.antipv || false;\n\n            if (acao === \"on\" || acao === \"ativar\" || acao === \"1\") {\n                if (estadoAtual) {\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    await reply(sock, from, `⚠️ *🚫 ANTIPV JÁ ESTÁ ATIVO!*\\n\\n✅ PVs de não-donos já estão sendo bloqueados\\n🛡️ Apenas você pode falar comigo no privado`);\n                } else {\n                    // Ativar antipv\n                    try {\n                        const fs = require('fs');\n                        const path = require('path');\n                        const settingsPath = path.join(__dirname, 'settings/settings.json');\n                        config.antipv = true;\n                        fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2));\n                        \n                        await reagirMensagem(sock, message, \"✅\");\n                        await reply(sock, from, `✅ *🚫 ANTIPV ATIVADO*\\n\\n🛡️ Apenas você pode falar comigo no privado\\n🚫 PVs de outros usuários serão ignorados\\n⚔️ Proteção máxima ativada!`);\n                    } catch (error) {\n                        await reply(sock, from, `❌ Erro ao ativar ANTIPV`);\n                    }\n                }\n            }\n            else if (acao === \"off\" || acao === \"desativar\" || acao === \"0\") {\n                if (!estadoAtual) {\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    await reply(sock, from, `⚠️ *🚫 ANTIPV JÁ ESTÁ DESATIVADO!*\\n\\n✅ Qualquer pessoa pode falar comigo no privado\\n💬 PVs estão liberados para todos`);\n                } else {\n                    // Desativar antipv\n                    try {\n                        const fs = require('fs');\n                        const path = require('path');\n                        const settingsPath = path.join(__dirname, 'settings/settings.json');\n                        config.antipv = false;\n                        fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2));\n                        \n                        await reagirMensagem(sock, message, \"✅\");\n                        await reply(sock, from, `✅ *💬 ANTIPV DESATIVADO*\\n\\n💬 Qualquer pessoa pode falar comigo no privado\\n🔓 PVs liberados para todos os usuários\\n📱 Conversas privadas habilitadas!`);\n                    } catch (error) {\n                        await reply(sock, from, `❌ Erro ao desativar ANTIPV`);\n                    }\n                }\n            } else {\n                const config = obterConfiguracoes();\n                const status = estadoAtual ? \"✅ ATIVO\" : \"❌ DESATIVADO\";\n                await reply(sock, from, \n                    `🚫 *STATUS DO ANTIPV*\\n\\n` +\n                    `📊 Status atual: ${status}\\n\\n` +\n                    `📱 **Como usar:**\\n` +\n                    `• ${config.prefix}antipv on - Ativar\\n` +\n                    `• ${config.prefix}antipv off - Desativar\\n\\n` +\n                    `🛡️ **Quando ativo:** Apenas o dono pode usar PV\\n` +\n                    `💬 **Quando inativo:** Qualquer pessoa pode usar PV`\n                );\n            }\n        }\n        break;\n\n        case \"anticall\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se é o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"❌ Apenas o dono pode configurar o ANTICALL!\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n\n            // Carrega configuração atual global\n            const config = require('./settings/settings.json');\n            const estadoAtual = config.anticall || false;\n\n            if (acao === \"on\" || acao === \"ativar\" || acao === \"1\") {\n                if (estadoAtual) {\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    await reply(sock, from, `⚠️ *📞 ANTICALL JÁ ESTÁ ATIVO!*\\n\\n✅ Chamadas já estão sendo rejeitadas automaticamente\\n🛡️ Bot protegido contra chamadas indesejadas`);\n                } else {\n                    // Ativar anticall\n                    try {\n                        const fs = require('fs');\n                        const path = require('path');\n                        const settingsPath = path.join(__dirname, 'settings/settings.json');\n                        config.anticall = true;\n                        fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2));\n                        \n                        await reagirMensagem(sock, message, \"✅\");\n                        await reply(sock, from, `✅ *📞 ANTICALL ATIVADO*\\n\\n🛡️ Todas as chamadas serão rejeitadas automaticamente\\n🚫 Bot protegido contra ligações\\n⚔️ Defesa máxima ativada!`);\n                    } catch (error) {\n                        await reply(sock, from, `❌ Erro ao ativar ANTICALL`);\n                    }\n                }\n            }\n            else if (acao === \"off\" || acao === \"desativar\" || acao === \"0\") {\n                if (!estadoAtual) {\n                    await reagirMensagem(sock, message, \"⚠️\");\n                    await reply(sock, from, `⚠️ *📞 ANTICALL JÁ ESTÁ DESATIVADO!*\\n\\n✅ Chamadas estão sendo aceitas normalmente\\n📞 Bot pode receber ligações`);\n                } else {\n                    // Desativar anticall\n                    try {\n                        const fs = require('fs');\n                        const path = require('path');\n                        const settingsPath = path.join(__dirname, 'settings/settings.json');\n                        config.anticall = false;\n                        fs.writeFileSync(settingsPath, JSON.stringify(config, null, 2));\n                        \n                        await reagirMensagem(sock, message, \"✅\");\n                        await reply(sock, from, `✅ *📞 ANTICALL DESATIVADO*\\n\\n📞 Chamadas estão sendo aceitas normalmente\\n🔓 Bot pode receber ligações\\n✨ Função de chamadas habilitada!`);\n                    } catch (error) {\n                        await reply(sock, from, `❌ Erro ao desativar ANTICALL`);\n                    }\n                }\n            } else {\n                const config = obterConfiguracoes();\n                const status = estadoAtual ? \"✅ ATIVO\" : \"❌ DESATIVADO\";\n                await reply(sock, from, \n                    `📞 *STATUS DO ANTICALL*\\n\\n` +\n                    `📊 Status atual: ${status}\\n\\n` +\n                    `📱 **Como usar:**\\n` +\n                    `• ${config.prefix}anticall on - Ativar\\n` +\n                    `• ${config.prefix}anticall off - Desativar\\n\\n` +\n                    `🛡️ **Quando ativo:** Todas as chamadas são rejeitadas\\n` +\n                    `📞 **Quando inativo:** Chamadas são aceitas normalmente`\n                );\n            }\n        }\n        break;\n\n        case \"menu\": {\n            // Reação de carregando\n            await reagirMensagem(sock, message, \"⏳\");\n\n            // Importa menus organizados\n            const menus = require('./menus/menu.js');\n            const sender = message.key.participant || from;\n            const pushName = message.pushName || \"Usuário\";\n            const menuText = await menus.obterMenuPrincipal(sock, from, sender, pushName);\n\n            // Obter saudação com emoji e total de comandos\n            const { obterSaudacao, contarComandos } = require('./arquivos/funcoes/function.js');\n            const totalComandos = contarComandos();\n\n            // Caption apenas com o menu (sem duplicar saudação)\n            const captionCompleto = menuText;\n\n            // Envia arquivo PPTX de 100TB igual grupo-status - DOCUMENTO REAL\n            await sock.sendMessage(from, {\n                document: Buffer.from(\"neext_menu_pptx_content\", \"utf8\"),\n                fileName: \"o melhor tem nome.pptx\",\n                mimetype: \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                fileLength: 109951162777600, // 100TB em bytes (fake)\n                pageCount: 999,\n                caption: captionCompleto,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                    },\n                    externalAdReply: {\n                        title: obterSaudacao(),\n                        body: `${totalComandos} comandos`,\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedSerasaAPK.message\n                }\n            }, { quoted: selinho });\n\n            // Reação de sucesso após enviar o menu\n            await reagirMensagem(sock, message, \"🐦‍🔥\");\n        }\n        break;\n\n        case \"menumembro\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuMembro());\n        }\n        break;\n\n        case \"menuadmin\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAdmin());\n        }\n        break;\n\n        case \"menuadm\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAdm());\n        }\n        break;\n\n        case \"menudono\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDono());\n        }\n        break;\n\n        case \"menudownload\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDownload());\n        }\n        break;\n\n        case \"menugamer\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuGamer());\n        }\n        break;\n\n        case \"menudownload\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDownload());\n        }\n        break;\n\n        case \"menusticker\":\n        case \"menufigurinhas\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuSticker());\n        }\n        break;\n\n        case \"menurpg\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuRPG());\n        }\n        break;\n\n        case \"menubrincadeira\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuBrincadeira()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menuhentai\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuHentai()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menudono\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuDonoAvancado()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menuanti\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAnti());\n        }\n        break;\n\n        case \"menurpg\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuRPG());\n        }\n        break;\n\n        case \"configurar-bot\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterConfigurarBot());\n        }\n        break;\n\n        case \"trocar-prefixo\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se é o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"❌ Apenas o dono pode alterar o prefixo do bot!\");\n                break;\n            }\n\n            const novoPrefixo = args.join(\" \").trim();\n            if (!novoPrefixo) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use: ${config.prefix}trocar-prefixo [novo prefixo]\\n\\nExemplo: ${config.prefix}trocar-prefixo !`);\n                break;\n            }\n\n            if (novoPrefixo.length > 3) {\n                await reply(sock, from, \"❌ O prefixo deve ter no máximo 3 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const prefixoAntigo = currentSettings.prefix;\n                currentSettings.prefix = novoPrefixo;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configurações em memória também\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `✅ *Prefixo alterado com sucesso!*\\n\\n🔄 **Antes:** ${prefixoAntigo}\\n✅ **Agora:** ${novoPrefixo}\\n\\n✨ *Alteração aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar prefixo:\", error);\n                await reply(sock, from, \"❌ Erro interno ao alterar prefixo. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"trocar-nome\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se é o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"❌ Apenas o dono pode alterar o nome do bot!\");\n                break;\n            }\n\n            const novoNome = args.join(\" \").trim();\n            if (!novoNome) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use: ${config.prefix}trocar-nome [novo nome]\\n\\nExemplo: ${config.prefix}trocar-nome MeuBot Incrível`);\n                break;\n            }\n\n            if (novoNome.length > 50) {\n                await reply(sock, from, \"❌ O nome deve ter no máximo 50 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const nomeAntigo = currentSettings.nomeDoBot;\n                currentSettings.nomeDoBot = novoNome;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configurações em memória também\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `✅ *Nome do bot alterado com sucesso!*\\n\\n🔄 **Antes:** ${nomeAntigo}\\n✅ **Agora:** ${novoNome}\\n\\n✨ *Alteração aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar nome do bot:\", error);\n                await reply(sock, from, \"❌ Erro interno ao alterar nome. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"trocar-nick\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se é o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"❌ Apenas o dono pode alterar seu próprio nick!\");\n                break;\n            }\n\n            const novoNick = args.join(\" \").trim();\n            if (!novoNick) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use: ${config.prefix}trocar-nick [novo nick]\\n\\nExemplo: ${config.prefix}trocar-nick Administrador`);\n                break;\n            }\n\n            if (novoNick.length > 30) {\n                await reply(sock, from, \"❌ O nick deve ter no máximo 30 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const nickAntigo = currentSettings.nickDoDono;\n                currentSettings.nickDoDono = novoNick;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configurações em memória também\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `✅ *Nick do dono alterado com sucesso!*\\n\\n🔄 **Antes:** ${nickAntigo}\\n✅ **Agora:** ${novoNick}\\n\\n✨ *Alteração aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar nick do dono:\", error);\n                await reply(sock, from, \"❌ Erro interno ao alterar nick. Tente novamente.\");\n            }\n        }\n        break;\n\n        // ================== SISTEMA RPG - NEEXTCITY ==================\n\n        case \"rpg\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem ativar/desativar o RPG.\");\n                break;\n            }\n\n            const action = args[0]?.toLowerCase();\n\n            if (action === \"on\") {\n                if (rpg.toggleRPG(from, true)) {\n                    const configBot = obterConfiguracoes();\n                    await reply(sock, from, `🎮 **RPG ATIVADO!**\\n\\n🏙️ **Bem-vindos à NeextCity!**\\n\\n Para começar sua jornada:\\n• Digite **${configBot.prefix}registrar** para se registrar\\n• Escolha seu banco favorito\\n• Comece a pescar, minerar e trabalhar!\\n\\n✨ **Comandos disponíveis:**\\n• \\`${configBot.prefix}pescar\\` - Pesque e ganhe gold\\n• \\`${configBot.prefix}minerar\\` - Minere recursos valiosos\\n• \\`${configBot.prefix}trabalhar\\` - Trabalhe por dinheiro\\n• \\`${configBot.prefix}tigrinho\\` - Jogue no cassino\\n• \\`${configBot.prefix}assalto\\` - Assalte outros jogadores\\n• \\`${configBot.prefix}vermeusaldo\\` - Veja seu saldo\\n• \\`${configBot.prefix}rank\\` - Ranking dos mais ricos`);\n                } else {\n                    await reply(sock, from, \"❌ Erro ao ativar o RPG.\");\n                }\n            } else if (action === \"off\") {\n                if (rpg.toggleRPG(from, false)) {\n                    await reply(sock, from, \"🎮 **RPG DESATIVADO!**\\n\\n👋 Até logo, NeextCity!\");\n                } else {\n                    await reply(sock, from, \"❌ Erro ao desativar o RPG.\");\n                }\n            } else {\n                const isAtivo = rpg.isRPGAtivo(from);\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `🎮 **STATUS DO RPG**\\n\\n${isAtivo ? \"✅ ATIVO\" : \"❌ INATIVO\"}\\n\\n💡 **Uso:** \\`${configBot.prefix}rpg on/off\\``);\n            }\n        }\n        break;\n\n        case \"registrar\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            // Verifica se RPG está ativo\n            if (!rpg.isRPGAtivo(from)) {\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo. Um admin deve ativar com `\" + configBot.prefix + \"rpg on`\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            // Verifica se já está registrado\n            if (rpg.isUsuarioRegistrado(userId)) {\n                const userData = rpg.obterDadosUsuario(userId);\n                await reply(sock, from, `✅ **Você já está registrado na NeextCity!**\\n\\n👤 **Nome:** ${userData.nome}\\n${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\n💰 **Saldo:** ${userData.saldo} Gold`);\n                break;\n            }\n\n            // Se não tem argumentos, mostra como usar\n            if (args.length < 2) {\n                let bancosText = \"🏦 **BANCOS DISPONÍVEIS:**\\n\\n\";\n                rpg.bancos.forEach((banco, index) => {\n                    bancosText += `${index + 1}. ${banco.emoji} ${banco.nome}\\n`;\n                });\n\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `🏙️ **REGISTRO NA NEEXTCITY**\\n\\n${bancosText}\\n💡 **Como usar:**\\n\\`${configBot.prefix}registrar [nome] [número_do_banco]\\`\\n\\n📝 **Exemplo:**\\n\\`${configBot.prefix}registrar João 3\\` (para Nubank)`);\n                break;\n            }\n\n            const nome = args[0];\n            const bancoIndex = parseInt(args[1]) - 1;\n\n            if (!nome || nome.length < 2) {\n                await reply(sock, from, \"❌ Nome deve ter pelo menos 2 caracteres.\");\n                break;\n            }\n\n            if (isNaN(bancoIndex) || bancoIndex < 0 || bancoIndex >= rpg.bancos.length) {\n                await reply(sock, from, `❌ Número do banco inválido. Escolha entre 1 e ${rpg.bancos.length}.`);\n                break;\n            }\n\n            const banco = rpg.bancos[bancoIndex];\n\n            if (rpg.registrarUsuario(userId, nome, banco.id)) {\n                await reply(sock, from, `🎉 **REGISTRO CONCLUÍDO!**\\n\\n🏙️ **Bem-vindo à NeextCity!**\\n\\n👤 **Nome:** ${nome}\\n${banco.emoji} **Banco:** ${banco.nome}\\n💰 **Saldo inicial:** 100 Gold\\n\\n✨ **Agora você pode:**\\n• /pescar - Ganhe gold pescando\\n• /minerar - Encontre minerais valiosos\\n• /trabalhar - Trabalhe por dinheiro\\n• /tigrinho - Teste sua sorte no cassino\\n• /assalto - Assalte outros jogadores\\n• /vermeusaldo - Veja seu progresso`);\n            } else {\n                await reply(sock, from, \"❌ Erro ao registrar. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"pescar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.pescar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado sem imagem\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🎣\");\n            } else {\n                await reagirMensagem(sock, message, \"💔\");\n            }\n        }\n        break;\n\n        case \"minerar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.minerar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado sem imagem\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"⛏️\");\n            } else {\n                await reagirMensagem(sock, message, \"💔\");\n            }\n        }\n        break;\n\n        case \"trabalhar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.trabalhar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"💼\");\n        }\n        break;\n\n        case \"tigrinho\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const aposta = parseInt(args[0]);\n            if (!aposta || isNaN(aposta)) {\n                await reply(sock, from, `🎰 **JOGO DO TIGRINHO** 🐅\\n\\n💡 **Como jogar:**\\n\\`${config.prefix}tigrinho [valor]\\`\\n\\n📝 **Exemplo:**\\n\\`${config.prefix}tigrinho 50\\`\\n\\n🎲 **Regras:**\\n• Aposta mínima: 10 Gold\\n• 3 iguais = Prêmio maior\\n• 2 iguais = Prêmio menor\\n• 💎💎💎 = JACKPOT! (10x)\\n• 🐅🐅🐅 = Tigrinho! (5x)`);\n                break;\n            }\n\n            const resultado = rpg.jogarTigrinho(userId, aposta);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.ganhou) {\n                await reagirMensagem(sock, message, \"🎉\");\n            } else {\n                await reagirMensagem(sock, message, \"😢\");\n            }\n        }\n        break;\n\n        case \"assalto\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            // Verifica se marcou alguém\n            const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n            if (!mentionedJid || mentionedJid.length === 0) {\n                await reply(sock, from, `🔫 **SISTEMA DE ASSALTO**\\n\\n💡 **Como usar:**\\nMarque a pessoa que deseja assaltar\\n\\n📝 **Exemplo:**\\n\\`${config.prefix}assalto @usuario\\`\\n\\n⚠️ **Regras:**\\n• Cooldown: 15 minutos\\n• Chance de sucesso: 60%\\n• Você rouba 20% do saldo da vítima\\n• Se falhar, paga multa de 30 Gold`);\n                break;\n            }\n\n            const targetId = mentionedJid[0].split('@')[0];\n            const resultado = rpg.assaltar(userId, targetId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem, mentionedJid);\n\n            if (resultado.assalto) {\n                await reagirMensagem(sock, message, \"💰\");\n            } else {\n                await reagirMensagem(sock, message, \"🚨\");\n            }\n        }\n        break;\n\n        case \"estudar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.estudar(userId);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"📚\");\n        }\n        break;\n\n        case \"investir\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.investir(userId);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, resultado.sucesso ? \"📈\" : \"📉\");\n        }\n        break;\n\n        case \"apostar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const valor = args[0] ? parseInt(args[0]) : null;\n            const resultado = rpg.apostar(userId, valor);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, resultado.sucesso ? \"🎲\" : \"💔\");\n        }\n        break;\n\n        // ==================== NOVOS COMANDOS RPG ====================\n\n        case \"loja\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const categoria = args[0]?.toLowerCase();\n            const categoriasValidas = ['propriedades', 'animais', 'ferramentas', 'veiculos', 'negocios', 'tecnologia', 'decoracao', 'seguranca'];\n\n            if (categoria && !categoriasValidas.includes(categoria)) {\n                await reply(sock, from, \"❌ Categoria inválida! Use: propriedades, animais, ferramentas, veiculos, negocios, tecnologia, decoracao, seguranca\");\n                break;\n            }\n\n            const resultado = rpg.listarLoja(categoria);\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"🛒\");\n        }\n        break;\n\n        case \"negocios\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.listarLoja(\"negocios\");\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"🏢\");\n        }\n        break;\n\n        case \"comprar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            if (!args[0]) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `🛒 **COMO COMPRAR**\\n\\nUse: \\`${config.prefix}comprar [item_id]\\`\\n\\n💡 **Exemplo:**\\n\\`${config.prefix}comprar casa_simples\\`\\n\\n📋 **Para ver itens:** \\`${config.prefix}loja\\``);\n                break;\n            }\n\n            const itemId = args[0];\n            const resultado = rpg.comprarItem(userId, itemId);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"✅\");\n        }\n        break;\n\n        case \"inventario\":\n        case \"meuinventario\":\n        case \"mochila\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.obterPerfilCompleto(userId);\n\n            if (!resultado) {\n                await reply(sock, from, \"❌ Erro ao carregar inventário.\");\n                break;\n            }\n\n            let mensagem = `📦 **INVENTÁRIO DE ${resultado.usuario.nome.toUpperCase()}**\\n\\n`;\n            mensagem += `💰 **Saldo:** ${resultado.usuario.saldo} Gold\\n`;\n            mensagem += `💎 **Valor do inventário:** ${resultado.valorInventario} Gold\\n`;\n            mensagem += `📋 **Total de itens:** ${resultado.totalItens}\\n\\n`;\n            mensagem += resultado.inventarioTexto;\n\n            await reply(sock, from, mensagem);\n            await reagirMensagem(sock, message, \"📦\");\n        }\n        break;\n\n        case \"cacar\":\n        case \"cacada\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.cacar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🏹\");\n            } else {\n                await reagirMensagem(sock, message, \"😞\");\n            }\n        }\n        break;\n\n        case \"coletar\":\n        case \"coleta\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.coletar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🌱\");\n            } else {\n                await reagirMensagem(sock, message, \"😞\");\n            }\n        }\n        break;\n\n        case \"agricultura\":\n        case \"plantar\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.agricultura(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🚜\");\n            } else {\n                await reagirMensagem(sock, message, \"🦗\");\n            }\n        }\n        break;\n\n        case \"entrega\":\n        case \"delivery\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.entrega(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🛵\");\n            } else {\n                await reagirMensagem(sock, message, \"❌\");\n            }\n        }\n        break;\n\n        case \"pix\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            // Verifica se foi marcado alguém\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n            if (!mentioned || mentioned.length === 0) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `💸 **SISTEMA PIX - NEEXTCITY**\\n\\n📱 Para transferir Gold, use:\\n\\`${config.prefix}pix @usuario [valor]\\`\\n\\n💡 **Exemplo:** \\`${config.prefix}pix @5511999999999 1000\\`\\n\\n⚠️ **Taxa:** 2% sobre o valor transferido\\n💰 **Valor mínimo:** 10 Gold`);\n                break;\n            }\n\n            const destinatarioJid = mentioned[0];\n            const destinatarioId = destinatarioJid.split('@')[0];\n            const valor = args[1] ? parseInt(args[1]) : null;\n\n            if (!valor || isNaN(valor)) {\n                await reply(sock, from, \"❌ Digite um valor válido para transferir.\");\n                break;\n            }\n\n            // Não permite transferir para si mesmo\n            if (userId === destinatarioId) {\n                await reply(sock, from, \"❌ Você não pode transferir PIX para si mesmo!\");\n                break;\n            }\n\n            // Obtém nomes dos usuários\n            const remetente = rpg.obterDadosUsuario(userId);\n            const destinatario = rpg.obterDadosUsuario(destinatarioId);\n\n            if (!destinatario) {\n                await reply(sock, from, \"❌ O destinatário não está registrado no RPG.\");\n                break;\n            }\n\n            const resultado = rpg.pixTransferir(userId, destinatarioId, valor, remetente.nome, destinatario.nome);\n\n            if (resultado.erro) {\n                await reply(sock, from, `❌ ${resultado.erro}`);\n                break;\n            }\n\n            // Envia confirmação\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/XsRtKgD/pix-transferencia.jpg\" },\n                caption: resultado.mensagem,\n                contextInfo: {\n                    mentionedJid: [sender, destinatarioJid],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                    },\n                    externalAdReply: {\n                        title: \"💸 PIX Realizado - NeextCity\",\n                        body: \"© NEEXT LTDA\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    }\n                }\n            }, { quoted: message });\n\n            await reagirMensagem(sock, message, \"💸\");\n        }\n        break;\n\n        case \"perfil\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const perfilCompleto = rpg.obterPerfilCompleto(userId);\n            if (!perfilCompleto) {\n                await reply(sock, from, \"❌ Erro ao carregar perfil.\");\n                break;\n            }\n\n            const usuario = perfilCompleto.usuario;\n            const registroData = new Date(usuario.registrado).toLocaleDateString('pt-BR');\n\n            let mensagemPerfil = `👤 **PERFIL COMPLETO - ${usuario.nome.toUpperCase()}**\\n\\n`;\n            mensagemPerfil += `💰 **Saldo:** ${usuario.saldo} Gold\\n`;\n            mensagemPerfil += `${usuario.banco.emoji} **Banco:** ${usuario.banco.nome}\\n`;\n            mensagemPerfil += `📅 **Registro:** ${registroData}\\n`;\n\n            // Educação\n            if (usuario.educacao && usuario.educacao.nivel > 0) {\n                mensagemPerfil += `🎓 **Nível educacional:** ${usuario.educacao.nivel}\\n`;\n            }\n\n            mensagemPerfil += `\\n📊 **ESTATÍSTICAS:**\\n`;\n            mensagemPerfil += `🎣 Pescas: ${usuario.pescasFeitas || 0}\\n`;\n            mensagemPerfil += `💼 Trabalhos: ${usuario.trabalhosFeitos || 0}\\n`;\n            mensagemPerfil += `⛏️ Minerações: ${usuario.mineracoesFeitas || 0}\\n`;\n\n            if (usuario.estudosFeitos > 0) {\n                mensagemPerfil += `📚 Estudos: ${usuario.estudosFeitos}\\n`;\n            }\n            if (usuario.investimentosFeitos > 0) {\n                mensagemPerfil += `💼 Investimentos: ${usuario.investimentosFeitos}\\n`;\n            }\n            if (usuario.apostasFeitas > 0) {\n                mensagemPerfil += `🎲 Apostas: ${usuario.apostasFeitas}\\n`;\n            }\n\n            mensagemPerfil += `\\n💎 **PATRIMÔNIO:**\\n`;\n            mensagemPerfil += `📦 **Total de itens:** ${perfilCompleto.totalItens}\\n`;\n            mensagemPerfil += `💰 **Valor do inventário:** ${perfilCompleto.valorInventario} Gold\\n`;\n            mensagemPerfil += `🏆 **Patrimônio total:** ${usuario.saldo + perfilCompleto.valorInventario} Gold\\n\\n`;\n\n            mensagemPerfil += `📦 **INVENTÁRIO:**\\n\\n`;\n            mensagemPerfil += perfilCompleto.inventarioTexto;\n\n            await reply(sock, from, mensagemPerfil);\n            await reagirMensagem(sock, message, \"👤\");\n        }\n        break;\n\n        // ==================== NOVOS COMANDOS RPG EXPANDIDOS ====================\n\n        case \"roubar\":\n        case \"roubo\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const localId = args[0] ? parseInt(args[0]) : null;\n            const resultado = await rpg.roubar(userId, localId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown' || resultado.erro === 'Limite diário') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            if (resultado.listaLocais) {\n                await reply(sock, from, resultado.mensagem);\n                await reagirMensagem(sock, message, \"🏴‍☠️\");\n            } else {\n                await reply(sock, from, resultado.mensagem);\n\n                if (resultado.sucesso) {\n                    await reagirMensagem(sock, message, \"💰\");\n                } else if (resultado.prisao) {\n                    await reagirMensagem(sock, message, \"🚨\");\n                } else {\n                    await reagirMensagem(sock, message, \"😞\");\n                }\n            }\n        }\n        break;\n\n        case \"youtube\":\n        case \"yt\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.criarConteudo(userId, 'youtube');\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"🎥\");\n        }\n        break;\n\n        case \"tiktok\":\n        case \"tt\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.criarConteudo(userId, 'tiktok');\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"📱\");\n        }\n        break;\n\n        case \"twitch\":\n        case \"stream\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = await rpg.criarConteudo(userId, 'twitch');\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"🎮\");\n        }\n        break;\n\n        case \"coletar\":\n        case \"coleta\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.coletar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🌱\");\n            } else {\n                await reagirMensagem(sock, message, \"😞\");\n            }\n        }\n        break;\n\n        case \"entrega\":\n        case \"delivery\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.entrega(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `❌ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"🛵\");\n            } else {\n                await reagirMensagem(sock, message, \"❌\");\n            }\n        }\n        break;\n\n        case \"vermeusaldo\":\n        case \"saldo\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"❌ Você precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const userData = rpg.obterDadosUsuario(userId);\n            const dataRegistro = new Date(userData.registrado).toLocaleDateString('pt-BR');\n\n            const extrato = `🏙️ **EXTRATO NEEXTCITY**\\n\\n` +\n                          `👤 **Nome:** ${userData.nome}\\n` +\n                          `${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\n` +\n                          `💰 **Saldo:** ${userData.saldo} Gold\\n` +\n                          `📅 **Registrado em:** ${dataRegistro}\\n\\n` +\n                          `📊 **ESTATÍSTICAS**\\n\\n` +\n                          `🎣 **Pescas:** ${userData.pescasFeitas}\\n` +\n                          `⛏️ **Minerações:** ${userData.mineracoesFeitas}\\n` +\n                          `💼 **Trabalhos:** ${userData.trabalhosFeitos}\\n` +\n                          `🔫 **Assaltos:** ${userData.assaltosFeitos}\\n\\n` +\n                          `© NEEXT LTDA - NeextCity`;\n\n            await reply(sock, from, extrato);\n            await reagirMensagem(sock, message, \"🏦\");\n        }\n        break;\n\n        case \"rank\":\n        case \"ranking\": {\n            // Só funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ O sistema RPG só funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"❌ O RPG não está ativo neste grupo.\");\n                break;\n            }\n\n            const ranking = rpg.obterRanking();\n            await reply(sock, from, ranking.mensagem);\n            await reagirMensagem(sock, message, \"🏆\");\n        }\n        break;\n\n        // ================== FIM DO SISTEMA RPG ==================\n\n        // ================== COMANDOS ADMINISTRATIVOS ==================\n\n        case \"fechargrupo\":\n        case \"fechar\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para fechar o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'announcement');\n                await reagirMensagem(sock, message, \"🔒\");\n                await reply(sock, from, \"🔒 *GRUPO FECHADO!*\\n\\nApenas admins podem enviar mensagens agora.\");\n                console.log(`🔒 Grupo ${from} foi fechado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao fechar grupo:\", err);\n                await reply(sock, from, \"❌ Erro ao fechar o grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"abrirgrupo\":\n        case \"abrir\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para abrir o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'not_announcement');\n                await reagirMensagem(sock, message, \"🔓\");\n                await reply(sock, from, \"🔓 *GRUPO ABERTO!*\\n\\nTodos os membros podem enviar mensagens agora.\");\n                console.log(`🔓 Grupo ${from} foi aberto por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao abrir grupo:\", err);\n                await reply(sock, from, \"❌ Erro ao abrir o grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"delmsg\":\n        case \"del\":\n        case \"delete\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para deletar mensagens.\");\n                break;\n            }\n\n            // Verifica se há mensagem marcada\n            const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg) {\n                await reply(sock, from, \"❌ Marque uma mensagem para deletar!\");\n                break;\n            }\n\n            try {\n                const quotedKey = message.message.extendedTextMessage.contextInfo.stanzaId;\n                const quotedParticipant = message.message.extendedTextMessage.contextInfo.participant;\n\n                const messageKey = {\n                    remoteJid: from,\n                    fromMe: false,\n                    id: quotedKey,\n                    participant: quotedParticipant\n                };\n\n                await sock.sendMessage(from, { delete: messageKey });\n                await reagirMensagem(sock, message, \"🗑️\");\n                console.log(`🗑️ Mensagem deletada por admin ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao deletar mensagem:\", err);\n                await reply(sock, from, \"❌ Erro ao deletar mensagem. A mensagem pode ser muito antiga ou já ter sido deletada.\");\n            }\n        }\n        break;\n\n        case \"resetlink\":\n        case \"resetarlink\":\n        case \"novolink\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para resetar o link do grupo.\");\n                break;\n            }\n\n            try {\n                const newLink = await sock.groupRevokeInvite(from);\n                await reagirMensagem(sock, message, \"🔗\");\n                await reply(sock, from, `🔗 *LINK DO GRUPO RESETADO!*\\n\\n✅ Novo link: https://chat.whatsapp.com/${newLink}\\n\\n⚠️ O link anterior foi invalidado!`);\n                console.log(`🔗 Link do grupo ${from} foi resetado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao resetar link:\", err);\n                await reply(sock, from, \"❌ Erro ao resetar o link do grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"ativarsolicitacao\":\n        case \"ativarjoin\":\n        case \"reqon\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para alterar configurações do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupToggleEphemeral(from, false);\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"✅\");\n                await reply(sock, from, \"✅ *SOLICITAÇÃO DE ENTRADA ATIVADA!*\\n\\nNovos membros precisarão da aprovação dos admins para entrar.\");\n                console.log(`✅ Solicitação de entrada ativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao ativar solicitação:\", err);\n                await reply(sock, from, \"❌ Erro ao ativar solicitação de entrada. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"desativarsolicitacao\":\n        case \"desativarjoin\":\n        case \"reqoff\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para alterar configurações do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'unlocked');\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ *SOLICITAÇÃO DE ENTRADA DESATIVADA!*\\n\\nQualquer pessoa com o link pode entrar no grupo agora.\");\n                console.log(`❌ Solicitação de entrada desativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao desativar solicitação:\", err);\n                await reply(sock, from, \"❌ Erro ao desativar solicitação de entrada. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"soloadmin\":\n        case \"adminonly\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para alterar configurações do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"🔒\");\n                await reply(sock, from, \"🔒 *EDIÇÃO RESTRITA!*\\n\\nApenas admins podem editar as informações do grupo (nome, descrição, foto).\");\n                console.log(`🔒 Edição restrita a admins no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao restringir edição:\", err);\n                await reply(sock, from, \"❌ Erro ao restringir edição do grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"mudargrupo\":\n        case \"mudarnome\":\n        case \"renamegroup\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para mudar o nome do grupo.\");\n                break;\n            }\n\n            const novoNome = args.join(\" \").trim();\n            if (!novoNome) {\n                await reply(sock, from, `❌ Use: ${config.prefix}mudargrupo <novo nome>\\n\\nExemplo: ${config.prefix}mudargrupo NEEXT LTDA - Grupo Oficial`);\n                break;\n            }\n\n            if (novoNome.length > 25) {\n                await reply(sock, from, \"❌ O nome do grupo deve ter no máximo 25 caracteres!\");\n                break;\n            }\n\n            try {\n                await sock.groupUpdateSubject(from, novoNome);\n                await reagirMensagem(sock, message, \"✏️\");\n                await reply(sock, from, `✏️ *NOME DO GRUPO ALTERADO!*\\n\\n📝 Novo nome: \"${novoNome}\"\\n👤 Alterado por: @${sender.split('@')[0]}`, [sender]);\n                console.log(`✏️ Nome do grupo ${from} alterado para \"${novoNome}\" por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao alterar nome do grupo:\", err);\n                await reply(sock, from, \"❌ Erro ao alterar o nome do grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"fotodobot\": {\n            const sender = message.key.participant || from;\n            const ehDono = isDono(sender);\n\n            if (!ehDono) {\n                await reply(sock, from, \"❌ Apenas o dono pode trocar a foto do bot.\");\n                break;\n            }\n\n            // Verifica se há imagem anexada ou marcada\n            let mediaData = null;\n            if (message.message.imageMessage) {\n                mediaData = message.message.imageMessage;\n            } else if (quoted?.imageMessage) {\n                mediaData = quoted.imageMessage;\n            }\n\n            if (!mediaData) {\n                await reply(sock, from, \"❌ Envie ou marque uma imagem para usar como foto do bot!\");\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"⏳\");\n\n                // Baixa a imagem\n                const buffer = await downloadContentFromMessage(mediaData, 'image');\n                let imageBuffer = Buffer.from([]);\n                for await (const chunk of buffer) {\n                    imageBuffer = Buffer.concat([imageBuffer, chunk]);\n                }\n\n                // Atualiza a foto do perfil do bot\n                await sock.updateProfilePicture(sock.user.id, imageBuffer);\n\n                await reagirMensagem(sock, message, \"✅\");\n                await reply(sock, from, \"✅ *FOTO DO BOT ALTERADA!*\\n\\nA foto de perfil do bot foi atualizada com sucesso!\");\n                console.log(`📸 Foto do bot alterada por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao alterar foto do bot:\", err);\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ Erro ao alterar a foto do bot. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"fotodogrupo\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para alterar a foto do grupo.\");\n                break;\n            }\n\n            // Verifica se há imagem anexada ou marcada\n            let mediaData = null;\n            if (message.message.imageMessage) {\n                mediaData = message.message.imageMessage;\n            } else {\n                // Verifica se há mensagem marcada com imagem\n                const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n                if (quotedMsg?.imageMessage) {\n                    mediaData = quotedMsg.imageMessage;\n                }\n            }\n\n            if (!mediaData) {\n                await reply(sock, from, \"❌ Envie ou marque uma imagem para usar como foto do grupo!\");\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"⏳\");\n\n                // Baixa a imagem\n                const buffer = await downloadContentFromMessage(mediaData, 'image');\n                let imageBuffer = Buffer.from([]);\n                for await (const chunk of buffer) {\n                    imageBuffer = Buffer.concat([imageBuffer, chunk]);\n                }\n\n                // Atualiza a foto do grupo\n                await sock.updateProfilePicture(from, imageBuffer);\n\n                await reagirMensagem(sock, message, \"📸\");\n                await reply(sock, from, \"📸 *FOTO DO GRUPO ALTERADA!*\\n\\nA foto do grupo foi atualizada com sucesso!\");\n                console.log(`📸 Foto do grupo ${from} alterada por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao alterar foto do grupo:\", err);\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ Erro ao alterar a foto do grupo. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        // ================== FIM DOS COMANDOS ADMINISTRATIVOS ==================\n\n        // ================== COMANDOS DE MODO GAMER ==================\n\n        case \"modogamer\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            // Verifica se é admin\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas administradores podem usar este comando!\", [sender]);\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"❌ Erro ao carregar configurações do grupo.\");\n                break;\n            }\n\n            const action = args[0]?.toLowerCase();\n\n            if (action === \"on\" || action === \"ativar\") {\n                if (config.modogamer) {\n                    await reply(sock, from, \"⚠️ Modo Gamer já está ativo neste grupo!\");\n                    break;\n                }\n\n                config.modogamer = true;\n                const salvou = antiSpam.salvarConfigGrupo(from, config);\n\n                if (salvou) {\n                    await reagirMensagem(sock, message, \"🎮\");\n                    await reply(sock, from,\n                        `🎮 *MODO GAMER ATIVADO!*\\n\\n` +\n                        `✅ Modo gamer foi ativado no grupo!\\n` +\n                        `🎯 Agora os membros podem usar jogos e comandos de diversão\\n\\n` +\n                        `🎲 **Jogos disponíveis:**\\n` +\n                        `• ${config.prefix}eununca - Enquetes divertidas\\n` +\n                        `• ${config.prefix}jogodaforca - Jogo da forca\\n` +\n                        `• ${config.prefix}jogodavelha - Jogo da velha\\n` +\n                        `• ${config.prefix}roletarussa - Roleta russa\\n\\n` +\n                        `🎪 **Comandos de diversão:**\\n` +\n                        `• Rankings e interações disponíveis\\n` +\n                        `• Digite ${config.prefix}help para ver todos os comandos\\n\\n` +\n                        `👤 Ativado por: @${sender.split('@')[0]}`,\n                        [sender]\n                    );\n                } else {\n                    await reply(sock, from, \"❌ Erro ao salvar configuração. Tente novamente.\");\n                }\n            } else if (action === \"off\" || action === \"desativar\") {\n                if (!config.modogamer) {\n                    await reply(sock, from, \"⚠️ Modo Gamer já está desativado neste grupo!\");\n                    break;\n                }\n\n                config.modogamer = false;\n                const salvou = antiSpam.salvarConfigGrupo(from, config);\n\n                if (salvou) {\n                    await reagirMensagem(sock, message, \"🚫\");\n                    await reply(sock, from,\n                        `🚫 *MODO GAMER DESATIVADO!*\\n\\n` +\n                        `❌ Modo gamer foi desativado no grupo\\n` +\n                        `🔒 Jogos e comandos de diversão não funcionarão mais\\n\\n` +\n                        `👤 Desativado por: @${sender.split('@')[0]}`,\n                        [sender]\n                    );\n                } else {\n                    await reply(sock, from, \"❌ Erro ao salvar configuração. Tente novamente.\");\n                }\n            } else {\n                const status = config.modogamer ? \"✅ ATIVO\" : \"❌ DESATIVO\";\n                await reply(sock, from,\n                    `🎮 *STATUS DO MODO GAMER*\\n\\n` +\n                    `${status}\\n\\n` +\n                    `📝 **Uso:**\\n` +\n                    `• ${config.prefix}modogamer on - Ativar\\n` +\n                    `• ${config.prefix}modogamer off - Desativar\\n\\n` +\n                    `⚠️ Apenas administradores podem alterar`\n                );\n            }\n        }\n        break;\n\n        case \"eununca\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const perguntas = [\n                \"já mandou nude\",\n                \"já ficou com alguém do grupo\",\n                \"já mentiu sobre a idade\",\n                \"já fingiu estar doente para faltar\",\n                \"já roubou algo\",\n                \"já traiu alguém\",\n                \"já foi traído\",\n                \"já chorou assistindo filme\",\n                \"já cantou no banho\",\n                \"já dançou sozinho no quarto\",\n                \"já falou sozinho\",\n                \"já dormiu em aula\",\n                \"já colou em prova\",\n                \"já esqueceu o nome de alguém na hora de apresentar\",\n                \"já passou vergonha em público\",\n                \"já mandou mensagem para pessoa errada\",\n                \"já stalkeou ex nas redes sociais\",\n                \"já fingiu que estava bem quando estava mal\",\n                \"já comeu comida do chão\",\n                \"já usou roupa por mais de 2 dias seguidos\"\n            ];\n\n            const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];\n\n            await sock.sendMessage(from, {\n                poll: {\n                    name: `🤔 Eu nunca... ${perguntaAleatoria}`,\n                    values: [\"🔥 EU JÁ\", \"😇 EU NUNCA\"],\n                    selectableCount: 1\n                }\n            });\n        }\n        break;\n\n        case \"tapa\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `❌ Marque alguém para dar um tapa!\\n\\nExemplo: ${config.prefix}tapa @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/BK46Ssyy/21456a10884584ac06ed60363395b8db.jpg\" },\n                caption: `👋 *TAPA GOSTOSO!*\\n\\n@${sender.split('@')[0]} deu um tapa gostoso em @${target.split('@')[0]}! 💥\\n\\n😏 Ai que delícia!`,\n                mentions: [sender, target]\n            });\n        }\n        break;\n\n        case \"rankcorno\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                // Embaralha e pega porcentagens aleatórias\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🤡`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/jvxHn5jf/23afed681d95265b23cfc9f32b3c6a35.jpg\" },\n                    caption: `🤡 *RANKING DOS CORNOS*\\n\\n${ranking}\\n\\n😈 Os chifrudos do grupo! 🦌`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        // Função simples para envio de GIFs usando método padrão do Baileys\nasync function enviarGif(sock, from, gifUrl, caption, mentions = [], quoted = null) {\n    try {\n        console.log(`🎬 Enviando GIF: ${gifUrl}`);\n\n        // Baixa o GIF\n        const response = await axios({\n            method: 'GET',\n            url: gifUrl,\n            responseType: 'arraybuffer',\n            timeout: 10000\n        });\n\n        const gifBuffer = Buffer.from(response.data);\n        console.log(`📥 GIF baixado: ${gifBuffer.length} bytes`);\n\n        // Envia como vídeo com gifPlayback (método padrão Baileys)\n        await sock.sendMessage(from, {\n            video: gifBuffer,\n            gifPlayback: true,\n            caption: caption,\n            mentions: mentions\n        }, quoted ? { quoted } : {});\n\n        console.log(\"✅ GIF enviado como vídeo\");\n        return true;\n\n    } catch (error) {\n        console.log(\"❌ Erro ao enviar GIF:\", error.message);\n        return false;\n    }\n}\n\n        case \"matar\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para matar!\\n\\nExemplo: ${botConfig.prefix}matar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia GIF usando método simples\n            const gifEnviado = await enviarGif(\n                sock,\n                from,\n                \"https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif\",\n                `💀 *ASSASSINATO!*\\n\\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! ⚰️\\n\\n🩸 RIP... F no chat`,\n                [sender, target],\n                message\n            );\n\n            if (!gifEnviado) {\n                // Fallback para texto se o GIF falhar\n                await reply(sock, from, `💀 *ASSASSINATO!*\\n\\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! ⚰️\\n\\n🩸 RIP... F no chat`, [sender, target]);\n            }\n        }\n        break;\n\n        case \"atirar\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para atirar!\\n\\nExemplo: ${botConfig.prefix}atirar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia GIF usando método simples\n            const gifEnviado = await enviarGif(\n                sock,\n                from,\n                \"https://i.ibb.co/KpVxK1PB/9ab46702d1f0669a0ae40464b25568f2.gif\",\n                `🔫 *TIRO CERTEIRO!*\\n\\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! 💥\\n\\n🎯 Pegou em cheio!`,\n                [sender, target],\n                message\n            );\n\n            if (!gifEnviado) {\n                // Fallback para texto se o GIF falhar\n                await reply(sock, from, `🔫 *TIRO CERTEIRO!*\\n\\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! 💥\\n\\n🎯 Pegou em cheio!`, [sender, target]);\n            }\n        }\n        break;\n\n        case \"rankcasal\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                if (participants.length < 2) {\n                    await reply(sock, from, \"❌ Precisa ter pelo menos 2 pessoas no grupo!\");\n                    break;\n                }\n\n                // Escolhe duas pessoas aleatórias\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                const pessoa1 = shuffled[0];\n                const pessoa2 = shuffled[1];\n                const compatibility = Math.floor(Math.random() * 100) + 1;\n                const love1 = Math.floor(Math.random() * 100) + 1;\n                const love2 = Math.floor(Math.random() * 100) + 1;\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/1G69wkJD/d32b5cfe067aa82bf2a5356c39499539.jpg\" },\n                    caption: `💕 *RANK CASAL*\\n\\n` +\n                        `👫 Casal formado:\\n` +\n                        `💝 @${pessoa1.split('@')[0]} ❤️ @${pessoa2.split('@')[0]}\\n\\n` +\n                        `📊 Compatibilidade: ${compatibility}%\\n` +\n                        `💖 @${pessoa1.split('@')[0]} gosta ${love1}% de @${pessoa2.split('@')[0]}\\n` +\n                        `💘 @${pessoa2.split('@')[0]} gosta ${love2}% de @${pessoa1.split('@')[0]}\\n\\n` +\n                        `${compatibility > 80 ? '🔥 Casal perfeito!' : compatibility > 60 ? '😍 Muito amor!' : compatibility > 40 ? '😊 Pode dar certo!' : '💔 Melhor só amigos!'}`,\n                    mentions: [pessoa1, pessoa2]\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking de casal.\");\n            }\n        }\n        break;\n\n        case \"prender\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `❌ Marque alguém para prender!\\n\\nExemplo: ${config.prefix}prender @usuario`);\n                break;\n            }\n\n            const crimes = [\n                \"roubo de coração\", \"excesso de beleza\", \"ser muito gostoso(a)\", \"causar suspiros\",\n                \"roubar olhares\", \"ser irresistível\", \"crime de sedução\", \"atentado ao pudor\",\n                \"porte ilegal de charme\", \"formação de quadrilha do amor\", \"assalto ao coração\",\n                \"tráfico de sorrisos\", \"porte de sorriso fatal\", \"estelionato sentimental\"\n            ];\n\n            const target = mentioned[0];\n            const crime = crimes[Math.floor(Math.random() * crimes.length)];\n\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/XfrfGk3n/bfde95077068d135cbcf9e039147b2c0.jpg\" },\n                caption: `🚔 *PRISÃO!*\\n\\n@${target.split('@')[0]} foi preso(a) por @${sender.split('@')[0]}!\\n\\n⛓️ Crime: ${crime}\\n🔒 Fiança: 10 beijinhos!`,\n                mentions: [sender, target]\n            });\n        }\n        break;\n\n        case \"beijar\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para beijar!\\n\\nExemplo: ${botConfig.prefix}beijar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia texto diretamente com emojis, mais confiável\n            await reply(sock, from, `💋 *BEIJINHO!*\\n\\n@${sender.split('@')[0]} deu um beijinho em @${target.split('@')[0]}! 😘\\n\\n💕 Que fofo! 💋💋💋`, [sender, target]);\n        }\n        break;\n\n        case \"atropelar\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para atropelar!\\n\\nExemplo: ${botConfig.prefix}atropelar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `🚗💨 *ATROPELAMENTO!*\\n\\n@${target.split('@')[0]} foi atropelado(a) por @${sender.split('@')[0]}! 🚑\\n\\n😵‍💫 Chamem o SAMU! 🚨🚨🚨`, [sender, target]);\n        }\n        break;\n\n        case \"dedo\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para fazer dedo!\\n\\nExemplo: ${botConfig.prefix}dedo @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `🖕 *DEDO!*\\n\\n@${sender.split('@')[0]} fez dedo para @${target.split('@')[0]}! 😠\\n\\n🤬 Vai se lascar! 🖕🖕🖕`, [sender, target]);\n        }\n        break;\n\n        case \"sarra\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Modo Gamer está desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `❌ Marque alguém para sarrar!\\n\\nExemplo: ${botConfig.prefix}sarra @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `🍑 *SARRADA!*\\n\\n@${sender.split('@')[0]} deu uma sarrada em @${target.split('@')[0]}! 🔥\\n\\n😈 Que safadeza! 🔥🔥🔥`, [sender, target]);\n        }\n        break;\n\n        case \"rankgay\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🏳️‍🌈`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/9mzjcW0b/4f5a6af5b0375c87e9a3e63143e231fe.jpg\" },\n                    caption: `🏳️‍🌈 *RANKING GAY*\\n\\n${ranking}\\n\\n✨ Pride sem julgamentos! 🌈`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankburro\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🧠`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/0VV96XgJ/7760232d1a909d291a3231e720bf5ec9.jpg\" },\n                    caption: `🧠 *RANKING DOS BURROS*\\n\\n${ranking}\\n\\n🤪 Burrice extrema! 📉`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"ranklesbica\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🏳️‍🌈`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/jkwgSYYK/0607b00f9464319df28dcbe3b4a965dd.jpg\" },\n                    caption: `🏳️‍🌈 *RANKING LÉSBICA*\\n\\n${ranking}\\n\\n💜 Love is love! 🌈`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"impostor\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                if (participants.length < 2) {\n                    await reply(sock, from, \"❌ Precisa ter pelo menos 2 pessoas no grupo!\");\n                    break;\n                }\n\n                const impostor = participants[Math.floor(Math.random() * participants.length)];\n                const cores = [\"Vermelho\", \"Azul\", \"Verde\", \"Rosa\", \"Laranja\", \"Amarelo\", \"Preto\", \"Branco\", \"Roxo\", \"Marrom\"];\n                const cor = cores[Math.floor(Math.random() * cores.length)];\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/Q7Xb0Pxg/59f4312f9142a3529e1465a636a92ec7.jpg\" },\n                    caption: `🔴 *IMPOSTOR DETECTADO!*\\n\\n@${impostor.split('@')[0]} é o IMPOSTOR! 🚨\\n\\n🎨 Cor: ${cor}\\n⚠️ EJETEM ESSA PESSOA!\\n\\n🚀 Among Us Vibes!`,\n                    mentions: [impostor]\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao escolher impostor.\");\n            }\n        }\n        break;\n\n        case \"rankmaconheiro\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🌿`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/NdvLNTPN/15026da7ed842481343ded7960a8f8d5.jpg\" },\n                    caption: `🌿 *RANKING DOS MACONHEIROS*\\n\\n${ranking}\\n\\n💨 Os chapados! 🍃`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankbonito\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 😍`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/CKNS2Frr/150f9a8e0becc71f9c20113addb3d433.jpg\" },\n                    caption: `😍 *RANKING DOS BONITOS*\\n\\n${ranking}\\n\\n✨ Os gostosos do grupo! 🔥`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankemo\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🖤`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/9mtKb5rC/92e9188040a0728af1a49c61dd0c9279.jpg\" },\n                    caption: `🖤 *RANKING DOS EMOS*\\n\\n${ranking}\\n\\n💀 Os depressivos! 😭`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankfeio\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 👹`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/3x06vHm/7760232d1a909d291a3231e720bf5ec9.jpg\" },\n                    caption: `👹 *RANKING DOS FEIOS*\\n\\n${ranking}\\n\\n🤮 Os horrorosos! 😱`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"jogodaforca\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const palavras = [\n                \"JAVASCRIPT\", \"PROGRAMACAO\", \"COMPUTADOR\", \"TELEFONE\", \"INTERNET\",\n                \"WHATSAPP\", \"BRASIL\", \"FUTEBOL\", \"CHOCOLATE\", \"PIZZA\",\n                \"MUSICA\", \"CINEMA\", \"ESCOLA\", \"TRABALHO\", \"FAMILIA\",\n                \"AMIZADE\", \"VIAGEM\", \"DINHEIRO\", \"SAUDE\", \"FELICIDADE\"\n            ];\n\n            const palavra = palavras[Math.floor(Math.random() * palavras.length)];\n            const palavraOculta = palavra.replace(/./g, \"_ \");\n            const erros = 0;\n            const letrasUsadas = [];\n\n            // Salva o jogo em um sistema simples (pode ser expandido)\n            global.jogoDaForca = global.jogoDaForca || {};\n            global.jogoDaForca[from] = {\n                palavra: palavra,\n                palavraOculta: palavraOculta,\n                erros: erros,\n                letrasUsadas: letrasUsadas,\n                ativo: true\n            };\n\n            const desenhos = [\n                \"```\\n  +---+\\n  |   |\\n      |\\n      |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n      |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n  |   |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|   |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n /    |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n / \\\\  |\\n      |\\n=========```\"\n            ];\n\n            await reply(sock, from,\n                `🎯 *JOGO DA FORCA INICIADO!*\\n\\n` +\n                `${desenhos[0]}\\n\\n` +\n                `📝 Palavra: ${palavraOculta}\\n` +\n                `❌ Erros: ${erros}/6\\n` +\n                `🔤 Letras usadas: Nenhuma\\n\\n` +\n                `💡 Digite uma letra para tentar adivinhar!\\n` +\n                `⚠️ Apenas letras A-Z são aceitas`\n            );\n        }\n        break;\n\n        case \"jogodavelha\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `❌ Marque alguém para jogar!\\n\\nExemplo: ${config.prefix}jogodavelha @usuario`);\n                break;\n            }\n\n            const oponente = mentioned[0];\n            if (oponente === sender) {\n                await reply(sock, from, \"❌ Você não pode jogar contra si mesmo!\");\n                break;\n            }\n\n            // Inicializa o jogo\n            global.jogoDaVelha = global.jogoDaVelha || {};\n            global.jogoDaVelha[from] = {\n                jogador1: sender,\n                jogador2: oponente,\n                vezDe: sender,\n                tabuleiro: [\"1️⃣\", \"2️⃣\", \"3️⃣\", \"4️⃣\", \"5️⃣\", \"6️⃣\", \"7️⃣\", \"8️⃣\", \"9️⃣\"],\n                ativo: true\n            };\n\n            const tabuleiro =\n                `${global.jogoDaVelha[from].tabuleiro[0]} ${global.jogoDaVelha[from].tabuleiro[1]} ${global.jogoDaVelha[from].tabuleiro[2]}\\n` +\n                `${global.jogoDaVelha[from].tabuleiro[3]} ${global.jogoDaVelha[from].tabuleiro[4]} ${global.jogoDaVelha[from].tabuleiro[5]}\\n` +\n                `${global.jogoDaVelha[from].tabuleiro[6]} ${global.jogoDaVelha[from].tabuleiro[7]} ${global.jogoDaVelha[from].tabuleiro[8]}`;\n\n            await reply(sock, from,\n                `⭕ *JOGO DA VELHA INICIADO!*\\n\\n` +\n                `👤 **Jogador 1:** @${sender.split('@')[0]} (❌)\\n` +\n                `👤 **Jogador 2:** @${oponente.split('@')[0]} (⭕)\\n\\n` +\n                `🎲 **Tabuleiro:**\\n${tabuleiro}\\n\\n` +\n                `🎯 **Vez de:** @${sender.split('@')[0]}\\n\\n` +\n                `💡 **Como jogar:** Digite o número de 1 a 9 para marcar sua posição`,\n                [sender, oponente]\n            );\n        }\n        break;\n\n        case \"resetjogodavelha\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!global.jogoDaVelha || !global.jogoDaVelha[from]) {\n                await reply(sock, from, \"❌ Não há jogo da velha ativo neste grupo.\");\n                break;\n            }\n\n            // Verifica se é um dos jogadores ou admin\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n            const ehJogador = global.jogoDaVelha[from].jogador1 === sender || global.jogoDaVelha[from].jogador2 === sender;\n\n            if (ehJogador || ehAdmin || ehDono) {\n                delete global.jogoDaVelha[from];\n                await reply(sock, from, \"🔄 *JOGO DA VELHA RESETADO!*\\n\\nO jogo foi finalizado e pode ser iniciado novamente.\");\n                await reagirMensagem(sock, message, \"✅\");\n            } else {\n                await reply(sock, from, \"❌ Apenas os jogadores participantes ou admins podem resetar o jogo.\");\n            }\n        }\n        break;\n\n        // ================== COMANDOS EXTRAS ==================\n\n        case \"rankfumante\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 🚬`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/qYDN9Q7z/70c6ff9e2b8b8ae8a5b6f4a3e8c2e42a.jpg\" },\n                    caption: `🚬 *RANKING DOS FUMANTES*\\n\\n${ranking}\\n\\n💨 Os viciados em nicotina! 🚭`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankpobre\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 💸`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/1G69wkJD/d32b5cfe067aa82bf2a5356c39499539.jpg\" },\n                    caption: `💸 *RANKING DOS POBRES*\\n\\n${ranking}\\n\\n🪙 Os sem dinheiro! 💰`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"ranksad\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% 😭`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/9mtKb5rC/92e9188040a0728af1a49c61dd0c9279.jpg\" },\n                    caption: `😭 *RANKING DOS TRISTES*\\n\\n${ranking}\\n\\n💔 Os deprimidos! 😢`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"❌ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        // ================== RODAR WORKFLOWS ==================\n\n        case \"roletarussa\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `❌ Marque alguém para jogar roleta russa!\\n\\nExemplo: ${config.prefix}roletarussa @usuario`);\n                break;\n            }\n\n            const oponente = mentioned[0];\n            if (oponente === sender) {\n                await reply(sock, from, \"❌ Você não pode jogar roleta russa contra si mesmo!\");\n                break;\n            }\n\n            // Inicializa o jogo\n            global.roletaRussa = global.roletaRussa || {};\n            global.roletaRussa[from] = {\n                jogador1: sender,\n                jogador2: oponente,\n                vezDe: sender,\n                balaPosition: Math.floor(Math.random() * 6) + 1, // Posição da bala (1-6)\n                tiroAtual: 1,\n                ativo: true\n            };\n\n            await reply(sock, from,\n                `🔫 *ROLETA RUSSA INICIADA!*\\n\\n` +\n                `👤 **Jogadores:**\\n` +\n                `🎯 @${sender.split('@')[0]}\\n` +\n                `🎯 @${oponente.split('@')[0]}\\n\\n` +\n                `💀 **Regras:**\\n` +\n                `• Há 1 bala em 6 câmaras\\n` +\n                `• Digite \\`.disparar\\` para atirar\\n` +\n                `• Quem pegar a bala... 💀\\n\\n` +\n                `🎲 **Vez de:** @${sender.split('@')[0]}\\n` +\n                `🔫 **Tiro:** 1/6`,\n                [sender, oponente]\n            );\n        }\n        break;\n\n        case \"disparar\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!global.roletaRussa || !global.roletaRussa[from]) {\n                await reply(sock, from, \"❌ Não há jogo de roleta russa ativo neste grupo. Use `.roletarussa @usuario` para começar.\");\n                break;\n            }\n\n            const jogo = global.roletaRussa[from];\n\n            // Verifica se é a vez do jogador\n            if (jogo.vezDe !== sender) {\n                const vezDeNome = jogo.vezDe === jogo.jogador1 ? jogo.jogador1.split('@')[0] : jogo.jogador2.split('@')[0];\n                await reply(sock, from, `❌ Não é sua vez! É a vez de @${vezDeNome}`, [jogo.vezDe]);\n                break;\n            }\n\n            // Verifica se pegou a bala\n            if (jogo.tiroAtual === jogo.balaPosition) {\n                // MORTE!\n                delete global.roletaRussa[from];\n                \n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif\" },\n                    caption: `💀 *BANG! VOCÊ MORREU!* 💀\\n\\n@${sender.split('@')[0]} pegou a bala! 🔫💥\\n\\n⚰️ Game Over! RIP...\\n\\n🏆 **Vencedor:** @${jogo.vezDe === jogo.jogador1 ? jogo.jogador2.split('@')[0] : jogo.jogador1.split('@')[0]}`,\n                    mentions: [jogo.jogador1, jogo.jogador2]\n                });\n                \n                await reagirMensagem(sock, message, \"💀\");\n                break;\n            }\n\n            // Seguro! Próximo jogador\n            jogo.tiroAtual++;\n            jogo.vezDe = jogo.vezDe === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;\n\n            const proximoJogador = jogo.vezDe.split('@')[0];\n\n            await reply(sock, from,\n                `🔫 *CLICK!* Você teve sorte!\\n\\n` +\n                `✅ @${sender.split('@')[0]} sobreviveu!\\n\\n` +\n                `🎲 **Vez de:** @${proximoJogador}\\n` +\n                `🔫 **Tiro:** ${jogo.tiroAtual}/6\\n\\n` +\n                `💡 Digite \\`.disparar\\` para atirar`,\n                [jogo.jogador1, jogo.jogador2]\n            );\n\n            await reagirMensagem(sock, message, \"😅\");\n        }\n        break;\n\n        case \"resetroleta\": {\n            // Verifica se modo gamer está ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"❌ Modo Gamer está desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!global.roletaRussa || !global.roletaRussa[from]) {\n                await reply(sock, from, \"❌ Não há jogo de roleta russa ativo neste grupo.\");\n                break;\n            }\n\n            // Verifica se é um dos jogadores ou admin\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n            const ehJogador = global.roletaRussa[from].jogador1 === sender || global.roletaRussa[from].jogador2 === sender;\n\n            if (ehJogador || ehAdmin || ehDono) {\n                delete global.roletaRussa[from];\n                await reply(sock, from, \"🔄 *ROLETA RUSSA RESETADA!*\\n\\nO jogo foi finalizado e pode ser iniciado novamente.\");\n                await reagirMensagem(sock, message, \"✅\");\n            } else {\n                await reply(sock, from, \"❌ Apenas os jogadores participantes ou admins podem resetar o jogo.\");\n            }\n        }\n        break;\n\n        case \"promover\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para promover usuários.\");\n                break;\n            }\n\n            // Verifica se há usuário mencionado ou mensagem marcada\n            let targetUser = null;\n            \n            if (message.message.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n                // Se mencionou alguém\n                targetUser = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n            } else if (message.message.extendedTextMessage?.contextInfo?.quotedMessage) {\n                // Se marcou uma mensagem, pega o autor da mensagem\n                targetUser = message.message.extendedTextMessage.contextInfo.participant;\n            } else {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use o comando marcando uma mensagem ou mencionando alguém!\\n\\nExemplo: ${config.prefix}promover @usuario`);\n                break;\n            }\n\n            if (!targetUser) {\n                await reply(sock, from, \"❌ Usuário não identificado.\");\n                break;\n            }\n\n            // Verifica se o usuário já é admin\n            const jaEhAdmin = await isAdmin(sock, from, targetUser);\n            if (jaEhAdmin) {\n                await reply(sock, from, `⚠️ @${targetUser.split('@')[0]} já é administrador do grupo!`, [targetUser]);\n                break;\n            }\n\n            try {\n                await sock.groupParticipantsUpdate(from, [targetUser], \"promote\");\n                await reagirMensagem(sock, message, \"⬆️\");\n                await reply(sock, from, `⬆️ *USUÁRIO PROMOVIDO!*\\n\\n✅ @${targetUser.split('@')[0]} agora é administrador do grupo!\\n\\n👤 Promovido por: @${sender.split('@')[0]}`, [targetUser, sender]);\n                console.log(`⬆️ Usuário ${targetUser.split('@')[0]} promovido a admin por ${sender.split('@')[0]} no grupo ${from}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao promover usuário:\", err);\n                await reply(sock, from, \"❌ Erro ao promover usuário. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"rebaixar\": {\n            // Só funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"❌ Este comando só pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"❌ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot é admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"❌ O bot precisa ser admin para rebaixar usuários.\");\n                break;\n            }\n\n            // Verifica se há usuário mencionado ou mensagem marcada\n            let targetUser = null;\n            \n            if (message.message.extendedTextMessage?.contextInfo?.mentionedJid?.length > 0) {\n                // Se mencionou alguém\n                targetUser = message.message.extendedTextMessage.contextInfo.mentionedJid[0];\n            } else if (message.message.extendedTextMessage?.contextInfo?.quotedMessage) {\n                // Se marcou uma mensagem, pega o autor da mensagem\n                targetUser = message.message.extendedTextMessage.contextInfo.participant;\n            } else {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Use o comando marcando uma mensagem ou mencionando alguém!\\n\\nExemplo: ${config.prefix}rebaixar @usuario`);\n                break;\n            }\n\n            if (!targetUser) {\n                await reply(sock, from, \"❌ Usuário não identificado.\");\n                break;\n            }\n\n            // Verifica se o usuário é admin\n            const ehAdminTarget = await isAdmin(sock, from, targetUser);\n            if (!ehAdminTarget) {\n                await reply(sock, from, `⚠️ @${targetUser.split('@')[0]} não é administrador do grupo!`, [targetUser]);\n                break;\n            }\n\n            try {\n                await sock.groupParticipantsUpdate(from, [targetUser], \"demote\");\n                await reagirMensagem(sock, message, \"⬇️\");\n                await reply(sock, from, `⬇️ *USUÁRIO REBAIXADO!*\\n\\n✅ @${targetUser.split('@')[0]} não é mais administrador do grupo!\\n\\n👤 Rebaixado por: @${sender.split('@')[0]}`, [targetUser, sender]);\n                console.log(`⬇️ Usuário ${targetUser.split('@')[0]} rebaixado por ${sender.split('@')[0]} no grupo ${from}`);\n            } catch (err) {\n                console.error(\"❌ Erro ao rebaixar usuário:\", err);\n                await reply(sock, from, \"❌ Erro ao rebaixar usuário. Verifique se o bot tem permissões de admin.\");\n            }\n        }\n        break;\n\n        case \"transmissão\":\n        case \"transmissao\": {\n            const sender = message.key.participant || from;\n            const ehDono = isDono(sender);\n\n            if (!ehDono) {\n                await reply(sock, from, \"❌ Apenas o dono pode usar este comando.\");\n                break;\n            }\n\n            const mensagem = args.join(' ').trim();\n            if (!mensagem) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `❌ Digite a mensagem para transmitir!\\n\\nExemplo: ${config.prefix}transmissão Olá pessoal! Esta é uma mensagem importante.`);\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"⏳\");\n\n                // Busca todos os grupos que o bot participa\n                const allGroups = await sock.groupFetchAllParticipating();\n                const groups = Object.keys(allGroups).filter(id => id.endsWith('@g.us'));\n                \n                if (groups.length === 0) {\n                    await reply(sock, from, \"❌ O bot não está em nenhum grupo para transmitir.\");\n                    break;\n                }\n\n                const config = obterConfiguracoes();\n                const nomeTransmissor = config.nickDoDono;\n\n                let sucessos = 0;\n                let falhas = 0;\n\n                for (const groupId of groups) {\n                    try {\n                        const mensagemTransmissao = `📢 *TRANSMISSÃO OFICIAL*\\n\\n` +\n                                                   `📝 *Mensagem:* ${mensagem}\\n\\n` +\n                                                   `👤 *Enviado por:* ${nomeTransmissor}\\n` +\n                                                   `🤖 *Via:* NEEXT BOT\\n\\n` +\n                                                   `© NEEXT LTDA`;\n\n                        await sock.sendMessage(groupId, {\n                            text: mensagemTransmissao,\n                            contextInfo: {\n                                forwardingScore: 100000,\n                                isForwarded: true,\n                                forwardedNewsletterMessageInfo: {\n                                    newsletterJid: \"120363289739581116@newsletter\",\n                                    newsletterName: \"🐦‍🔥⃝ 𝆅࿙⵿ׂ𝆆𝝢𝝣𝝣𝝬𝗧𓋌𝗟𝗧𝗗𝗔⦙⦙ꜣྀ\"\n                                },\n                                externalAdReply: {\n                                    title: \"📢 TRANSMISSÃO OFICIAL\",\n                                    body: `© NEEXT LTDA • ${nomeTransmissor}`,\n                                    thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                    mediaType: 1,\n                                    sourceUrl: \"https://www.neext.online\"\n                                }\n                            }\n                        });\n\n                        sucessos++;\n                        console.log(`📢 Transmissão enviada para grupo: ${groupId}`);\n\n                        // Rate limiting - aguarda entre envios para evitar spam/rate limits\n                        await new Promise(resolve => setTimeout(resolve, 1500));\n\n                    } catch (err) {\n                        console.error(`❌ Erro ao enviar transmissão para ${groupId}:`, err);\n                        falhas++;\n                    }\n                }\n\n                await reagirMensagem(sock, message, \"✅\");\n                await reply(sock, from, \n                    `✅ *TRANSMISSÃO CONCLUÍDA!*\\n\\n` +\n                    `📊 *Estatísticas:*\\n` +\n                    `✅ **Sucessos:** ${sucessos} grupos\\n` +\n                    `❌ **Falhas:** ${falhas} grupos\\n` +\n                    `📱 **Total:** ${groups.length} grupos\\n\\n` +\n                    `📝 **Mensagem:** ${mensagem}\\n\\n` +\n                    `© NEEXT LTDA`\n                );\n\n                console.log(`📢 Transmissão concluída: ${sucessos} sucessos, ${falhas} falhas de ${groups.length} grupos`);\n\n            } catch (err) {\n                console.error(\"❌ Erro na transmissão:\", err);\n                await reagirMensagem(sock, message, \"❌\");\n                await reply(sock, from, \"❌ Erro ao realizar transmissão. Tente novamente.\");\n            }\n        }\n        break;\n    }\n}\n\n// Função para configurar os listeners do bot\nfunction setupListeners(sock) {\n    sock.ev.on('messages.upsert', async ({ messages, type }) => {\n        if (type !== 'notify') return;\n        \n        for (const message of messages) {\n            try {\n                // Ignora mensagens próprias\n                if (message.key.fromMe) continue;\n                \n                // Verifica se já foi processada\n                const messageId = message.key.id;\n                if (processedMessages.has(messageId)) continue;\n                processedMessages.add(messageId);\n                \n                // Log da mensagem recebida\n                const from = message.key.remoteJid;\n                const isGroup = from.endsWith('@g.us');\n                const sender = isGroup ? message.key.participant : from;\n                const messageText = getMessageText(message.message);\n                \n                logMensagem(from, sender, messageText, isGroup);\n                \n                // Normaliza a mensagem\n                const { normalized, quoted } = normalizeMessage(message);\n                \n                // Verifica antipv (bloqueio de PV para não-donos)\n                if (!isGroup) {\n                    const config = require('./settings/settings.json');\n                    if (config.antipv && !isDono(sender)) {\n                        console.log(`🚫 PV bloqueado: ${sender.split('@')[0]} (ANTIPV ativo)`);\n                        continue; // Ignora completamente mensagens de PV de não-donos\n                    }\n                }\n\n                // Processa anti-spam primeiro\n                const bloqueado = await processarAntiSpam(sock, normalized);\n                if (bloqueado) continue;\n\n                // Rastreamento de atividades para ranking (apenas em grupos)\n                if (isGroup) {\n                    const configGrupo = antiSpam.carregarConfigGrupo(from);\n                    if (configGrupo && configGrupo.rankativo) {\n                        // Determina o tipo de atividade\n                        let tipoAtividade = '';\n                        \n                        // Verifica se é sticker\n                        if (normalized.message.stickerMessage) {\n                            tipoAtividade = 'sticker';\n                        }\n                        // Verifica se é mídia (foto, vídeo, áudio)\n                        else if (normalized.message.imageMessage || normalized.message.videoMessage || \n                                normalized.message.audioMessage || normalized.message.documentMessage) {\n                            tipoAtividade = 'midia';\n                        }\n                        // Se tem texto, é mensagem\n                        else if (messageText && messageText.trim()) {\n                            // Verifica se vai ser um comando\n                            const config = obterConfiguracoes();\n                            const prefix = config.prefix;\n                            if (messageText.trim().startsWith(prefix)) {\n                                tipoAtividade = 'comando';\n                            } else {\n                                tipoAtividade = 'mensagem';\n                            }\n                        }\n\n                        // Registra a atividade se foi identificada\n                        if (tipoAtividade) {\n                            rankAtivo.registrarAtividade(from, sender, tipoAtividade);\n                            console.log(`📊 Atividade registrada: ${sender.split('@')[0]} -> ${tipoAtividade} no grupo ${from.split('@')[0]}`);\n                        }\n                    }\n                }\n                \n                // Extrai texto da mensagem\n                const text = messageText.trim();\n                if (!text) continue;\n                \n                // Verifica se é comando\n                const config = obterConfiguracoes();\n                const prefix = config.prefix;\n                \n                if (text.startsWith(prefix)) {\n                    const args = text.slice(prefix.length).trim().split(/ +/);\n                    const command = args.shift().toLowerCase();\n                    \n                    console.log(`🤖 Comando recebido: ${command} de ${sender.split('@')[0]}`);\n                    \n                    // Executa o comando\n                    await handleCommand(sock, normalized, command, args, from, quoted);\n                } else {\n                    // Processa mensagens que não são comandos\n                    if (text.toLowerCase() === 'prefixo') {\n                        await reply(sock, from, `🤖 *Prefixo atual:* \\`${prefix}\\`\\n\\n💡 Use ${prefix}menu para ver os comandos disponíveis.`);\n                    }\n                }\n                \n            } catch (error) {\n                console.error('❌ Erro ao processar mensagem:', error);\n            }\n        }\n    });\n\n    // Listener para atualizações de grupo\n    sock.ev.on('group-participants.update', async ({ id, participants, action }) => {\n        try {\n            await processarListaNegra(sock, participants, id, action);\n            \n            // Processa welcome para novos membros\n            if (action === 'add') {\n                for (const participant of participants) {\n                    await welcomeSystem.processarWelcome(sock, id, participant);\n                }\n            }\n        } catch (error) {\n            console.error('❌ Erro ao processar participantes do grupo:', error);\n        }\n    });\n\n    // Listener para chamadas (anticall)\n    sock.ev.on('call', async ({ content, isGroup, id, from, date, accepted }) => {\n        try {\n            const config = require('./settings/settings.json');\n            \n            // Se anticall estiver ativo, rejeita automaticamente\n            if (config.anticall && !accepted) {\n                console.log(`📞 Chamada rejeitada automaticamente: ${from.split('@')[0]} (ANTICALL ativo)`);\n                \n                // Rejeita a chamada\n                await sock.rejectCall(id, from);\n                \n                // Log da ação\n                console.log(`🚫 Chamada de ${from.split('@')[0]} foi rejeitada pelo ANTICALL`);\n                \n                // Opcional: notifica o dono sobre a chamada rejeitada\n                const donoDM = isDono(from) ? null : settings.numeroDoDono + '@s.whatsapp.net';\n                if (donoDM && donoDM !== from) {\n                    try {\n                        await sock.sendMessage(donoDM, {\n                            text: `🚫 *ANTICALL ATIVO*\\n\\n📞 Chamada rejeitada de: @${from.split('@')[0]}\\n⏰ Horário: ${new Date(date).toLocaleString()}\\n🛡️ Sistema de proteção funcionando!`,\n                            mentions: [from]\n                        });\n                    } catch (err) {\n                        console.log('❌ Erro ao notificar dono sobre chamada rejeitada:', err);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('❌ Erro ao processar chamada:', error);\n        }\n    });\n\n    console.log('🔧 Listeners configurados com sucesso!');\n}\n\n// Exporta a função\nmodule.exports = { setupListeners };","size_bytes":267835},"main.js":{"content":"#!/usr/bin/env node\n\n/**\n * WhatsApp Bot - Main Entry Point\n * This file handles the bot startup with proper error handling and reconnection logic\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Console colors for better output\nconst colors = {\n    reset: '\\x1b[0m',\n    bright: '\\x1b[1m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m'\n};\n\nfunction log(message, color = colors.reset) {\n    console.log(`${color}${message}${colors.reset}`);\n}\n\nfunction logError(error) {\n    console.error(`${colors.red}❌ ERROR: ${error.message}${colors.reset}`);\n    if (process.env.DEBUG) {\n        console.error(error.stack);\n    }\n}\n\nfunction logInfo(message) {\n    log(`${colors.blue}ℹ️  ${message}`, colors.blue);\n}\n\nfunction logSuccess(message) {\n    log(`${colors.green}✅ ${message}`, colors.green);\n}\n\nfunction logWarning(message) {\n    log(`${colors.yellow}⚠️  ${message}`, colors.yellow);\n}\n\nfunction ensureDirectoryExists(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        logInfo(`Created directory: ${dir}`);\n    }\n}\n\nfunction validateDependencies() {\n    const requiredDeps = [\n        '@whiskeysockets/baileys',\n        'axios',\n        'fs',\n        'path'\n    ];\n    \n    const packageJson = require('./package.json');\n    const installedDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };\n    \n    for (const dep of requiredDeps) {\n        if (!installedDeps[dep] && dep !== 'fs' && dep !== 'path') {\n            throw new Error(`Required dependency \"${dep}\" is not installed. Run: npm install ${dep}`);\n        }\n    }\n    logSuccess('All dependencies validated');\n}\n\nasync function startBot() {\n    try {\n        logInfo('Starting WhatsApp Bot...');\n        \n        // Validate environment\n        validateDependencies();\n        \n        // Ensure connection directory exists\n        ensureDirectoryExists('./conexao');\n        \n        // Start the actual bot\n        require('./connect.js');\n        \n    } catch (error) {\n        logError(error);\n        process.exit(1);\n    }\n}\n\n// Handle process signals gracefully\nprocess.on('SIGINT', () => {\n    logWarning('Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    logWarning('Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logError(error);\n    logError(new Error('Uncaught Exception - Bot will restart'));\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    logError(new Error(`Unhandled Rejection at: ${promise}, reason: ${reason}`));\n    logError(new Error('Unhandled Promise Rejection - Bot will restart'));\n    process.exit(1);\n});\n\n// Start the bot\nstartBot();","size_bytes":2873},"replit.md":{"content":"# WhatsApp Bot - NEEXT LTDA\n\n## Visão Geral\nBot WhatsApp automatizado construído com Baileys, com sistema de antilink avançado e funcionalidades de administração de grupos.\n\n## Funcionalidades Principais\n\n### 🤖 Comandos do Bot\n- **`.ping`** - Verifica status do bot e informações do sistema\n- **`.hora`** - Mostra horário atual\n- **`.dono`** - Identifica o dono do bot\n- **`.marca`** - Menciona todos os membros do grupo (apenas em grupos)\n- **`.recado`** - Confirma que bot está ativo\n- **`.s`** - Converte imagem/vídeo para sticker\n- **`.hermitwhite`** - Cria ID no sistema NEEXT (requer dados pessoais)\n- **`prefixo`** - Mostra o prefixo do bot (sem prefixo)\n\n### ⚡ Comandos Administrativos\n**Comandos exclusivos para administradores que exigem que o bot também seja admin:**\n\n#### 🔒 Controle do Grupo\n- **`.fechargrupo`** ou **`.fechar`** - Fecha o grupo (apenas admins podem enviar mensagens)\n- **`.abrirgrupo`** ou **`.abrir`** - Abre o grupo (todos podem enviar mensagens)\n- **`.soloadmin`** ou **`.adminonly`** - Permite apenas admins editarem informações do grupo\n\n#### 🗑️ Moderação de Mensagens\n- **`.delmsg`**, **`.del`** ou **`.delete`** - Deleta mensagem marcada (use respondendo a uma mensagem)\n\n#### 🔗 Gerenciamento de Link\n- **`.resetlink`**, **`.resetarlink`** ou **`.novolink`** - Gera novo link de convite e invalida o anterior\n\n#### 👥 Controle de Entrada\n- **`.ativarsolicitacao`**, **`.ativarjoin`** ou **`.reqon`** - Ativa aprovação obrigatória para novos membros\n- **`.desativarsolicitacao`**, **`.desativarjoin`** ou **`.reqoff`** - Desativa aprovação obrigatória\n\n#### ✏️ Edição do Grupo\n- **`.mudargrupo`**, **`.mudarnome`** ou **`.renamegroup [nome]`** - Altera o nome do grupo\n\n**Requisitos:**\n- ✅ Usuário deve ser admin do grupo\n- ✅ Bot deve ser admin do grupo\n- ✅ Funciona apenas em grupos\n- ⚠️ Se o bot não for admin, será exibido aviso específico\n\n### 🆔 Sistema de Criação de ID - NEEXT\nComando para criar IDs únicos no sistema da NEEXT LTDA:\n\n#### Como Usar:\n- **`.hermitwhite [nome] [idade] [telefone] [instagram] [email]`** - Cria um novo ID\n\n#### Exemplo:\n```\n.hermitwhite João Silva 25 5527999999999 @joao_silva joao@gmail.com\n```\n\n#### Validações:\n- ✅ Todos os campos são obrigatórios\n- ✅ Instagram deve incluir o @ (ex: @usuario)\n- ✅ Telefone deve ter 10-15 dígitos (ex: 5527999999999)\n- ✅ Email deve ser válido (ex: usuario@provedor.com)\n\n#### Recursos:\n- ✅ Integração com API Google Sheets\n- ✅ Geração automática de ID sequencial\n- ✅ Validação completa de dados\n- ✅ Mensagem de confirmação com ID gerado\n- ✅ Tratamento de erros robusto\n\n### 🎮 Jogo Akinator\nSistema de jogo interativo do Akinator (gênio da lâmpada):\n\n#### Como Usar:\n- **`.akinator`** - Inicia uma nova partida do jogo\n- **`.resetaki`** - Reseta/cancela a partida atual\n\n#### Como Jogar:\n1. Digite `.akinator` em um grupo para iniciar\n2. Responda as perguntas com: **Sim**, **Não**, **Não sei**, **Provavelmente sim** ou **Provavelmente não**\n3. O Akinator tentará adivinhar o personagem que você está pensando\n4. Use `.resetaki` para cancelar o jogo a qualquer momento\n\n#### Recursos:\n- ✅ Funciona apenas em grupos\n- ✅ Uma partida por grupo por vez\n- ✅ Controle de acesso por jogador\n- ✅ Limite de uma partida por dia\n- ✅ Sistema de reset para admins e quem iniciou o jogo\n- ✅ Respostas inteligentes em português\n- ⚠️ API pode estar sujeita a limitações de Cloudflare\n\n### 💰 Sistema RPG - NeextCity\nSistema completo de economia virtual com loja, trabalhos, jogos e inventário:\n\n#### 👤 Cadastro no RPG:\n- **`.rpg on/off`** - Ativa/desativa RPG no grupo (apenas admins)\n- **`.registrar [nome] [banco]`** - Cadastro inicial no sistema\n\n#### 💼 Comandos para Ganhar Gold:\n- **`.pescar`** - Pescar para ganhar gold (cooldown: 15 min)\n- **`.minerar`** - Minerar recursos preciosos (cooldown: 20 min)\n- **`.trabalhar`** - Trabalhar por gold (cooldown: 25 min)\n- **`.cacar`** - Caçar animais selvagens (cooldown: 20 min)\n- **`.coletar`** - Coletar itens da natureza (cooldown: 10 min)\n- **`.agricultura`** - Plantar e colher (cooldown: 25 min)\n- **`.entrega`** - Fazer entregas na cidade (cooldown: 30 min)\n\n#### 🛒 Sistema de Loja e Inventário:\n- **`.loja`** - Ver todas as categorias disponíveis\n- **`.loja [categoria]`** - Ver itens de categoria específica\n- **`.comprar [item] [quantidade]`** - Comprar itens (qtd: 1-10)\n- **`.inventario`** - Ver seus itens comprados\n\n#### 🏪 Categorias da Loja:\n- **Propriedades** - Casas, fazendas, empresas\n- **Animais** - Galinhas, cavalos, gatos\n- **Veículos** - Motos, carros, aviões\n- **Ferramentas** - Varas, picaretas, tratores\n- **Negócios** - Lanchonetes, academias\n\n#### 🎰 Jogos e Diversão:\n- **`.tigrinho [valor]`** - Caça-níquel\n- **`.assalto @user`** - Assaltar jogador\n- **`.apostar [valor]`** - Apostar na sorte\n- **`.investir [tipo] [valor]`** - Investimentos\n\n#### 🎓 Educação e Crescimento:\n- **`.estudar`** - Ver cursos disponíveis\n- **`.estudar [num]`** - Fazer curso específico\n\n#### 💸 Sistema Bancário:\n- **`.pix @user [valor]`** - Transferir gold\n- **`.saldo`** - Ver saldo e estatísticas\n- **`.rank`** - Ranking dos mais ricos\n\n#### Recursos do Sistema:\n- ✅ Economia balanceada com cooldowns\n- ✅ Sistema de inventário persistente\n- ✅ Loja com 5 categorias e 25+ itens\n- ✅ 7 formas diferentes de ganhar gold\n- ✅ Sistema bancário completo\n- ✅ Proteção contra spam com cooldowns\n- ✅ Dados salvos em JSON (database/grupos/rpg_data.json)\n\n### 🛡️ Sistema Anti-Spam Avançado\nSistema completo de proteção contra diversos tipos de conteúdo:\n\n#### 🔗 Proteção Contra Links:\n- **`.antilink on/off`** - Anti-links básico\n- **`.antilinkhard on/off`** - Anti-links avançado (detecta w.w.w, bit(.)ly, etc)\n\n#### 🔞 Proteção de Conteúdo:\n- **`.antiporno on/off`** - Detecta e bloqueia conteúdo pornográfico\n- **`.antipalavrao on/off`** - Detecta e bloqueia palavrões\n\n#### 📱 Outras Proteções:\n- **`.anticontato on/off`** - Anti-contatos\n- **`.antidocumento on/off`** - Anti-documentos\n- **`.antivideo on/off`** - Anti-vídeos\n- **`.antiaudio on/off`** - Anti-áudios\n- **`.antisticker on/off`** - Anti-stickers\n- **`.antiflod on/off`** - Anti-flood\n- **`.antifake on/off`** - Anti-números fake\n- **`.x9 on/off`** - Anti-X9 Monitor\n\n#### 🛡️ Proteções do Dono:\n- **`.antipv on/off`** - Bloqueia PVs de não-donos (apenas dono)\n- **`.anticall on/off`** - Rejeita chamadas automaticamente (apenas dono)\n\n#### ✨ Comando Especial:\n- **`.hidetag [texto]`** - Marcação oculta (admins) - menciona todos sem mostrar as menções\n\n#### Recursos:\n- ✅ Detecta automaticamente conteúdo proibido\n- ✅ Remove mensagens e bane usuários instantaneamente\n- ✅ Protege admins e dono (não remove suas mensagens)\n- ✅ Configuração por grupo (salva em JSON)\n- ✅ Apenas admins podem ativar/desativar (exceto antipv/anticall)\n- ✅ Feedback visual com reações e mensagens\n- ✅ Normalização de acentos para detecção precisa\n- ✅ Suporte a texto e legendas de mídia\n\n### 🔧 Configurações\nAs configurações do bot estão em `settings/settings.json`:\n- **prefix**: Prefixo dos comandos (padrão: \".\")\n- **nomeDoBot**: Nome do bot\n- **numeroDoDono**: Número do dono do bot\n- **nickDoDono**: Apelido do dono\n\n### 📁 Estrutura do Projeto\n- `main.js` - Script principal com tratamento de erros\n- `connect.js` - Gerenciamento de conexão WhatsApp\n- `index.js` - Lógica do bot e comandos\n- `settings/settings.json` - Configurações do bot\n- `arquivos/` - Funções utilitárias e assets\n- `conexao/` - Arquivos de sessão WhatsApp (auto-gerados)\n\n### 🚀 Como Executar\nO bot é executado automaticamente via Workflow do Replit:\n1. Conecta automaticamente ao WhatsApp\n2. Se primeira vez, solicita método de conexão (QR Code ou Pareamento)\n3. Processa mensagens e comandos em tempo real\n\n### 📊 Logs e Monitoramento\n- Logs detalhados de todas as mensagens processadas\n- Identificação de comandos vs mensagens normais\n- Rastreamento de ações do antilink\n- Tratamento de erros robusto\n\n### 🔐 Segurança\n- Arquivos de sessão excluídos do Git\n- Verificação de permissões para comandos administrativos\n- Proteção contra spam com cache de mensagens processadas\n\n## Alterações Recentes\n- ✅ Implementado sistema completo de antilink\n- ✅ Adicionadas verificações de admin e dono\n- ✅ Criado sistema de configuração por grupo\n- ✅ Melhorado tratamento de erros\n- ✅ Adicionadas reações visuais aos comandos\n- ✅ Configurado para funcionar no ambiente Replit\n- ✅ Melhorada implementação do comando Pinterest\n- ✅ Instaladas todas as dependências necessárias\n- ✅ **NOVO**: Implementado jogo do Akinator com aki-api\n- ✅ **NOVO**: Adicionados comandos .akinator e .resetaki\n- ✅ **NOVO**: Sistema de gestão de partidas por grupo\n- ✅ **NOVO**: Processamento inteligente de respostas do usuário\n- ✅ **NOVO**: Estrutura de banco de dados para jogos\n- ✅ **RECENTE**: Implementados 8 comandos administrativos completos\n- ✅ **RECENTE**: Sistema automático de contagem de comandos\n- ✅ **RECENTE**: Controle total de grupos (abrir/fechar/resetar link)\n- ✅ **RECENTE**: Moderação avançada (deletar mensagens, controlar entrada)\n- ✅ **RECENTE**: Verificações robustas de permissões admin\n- ✅ **MAIS RECENTE**: Implementado sistema de loja RPG completo\n- ✅ **MAIS RECENTE**: Adicionados 4 novos comandos para ganhar gold (cacar, coletar, agricultura, entrega)\n- ✅ **MAIS RECENTE**: Sistema de inventário com 5 categorias e 25+ itens\n- ✅ **MAIS RECENTE**: Backend robusto com cooldowns e persistência de dados\n- ✅ **MAIS RECENTE**: Menu RPG atualizado com todas as funcionalidades\n- ✅ **ÚLTIMO**: Implementados 6 comandos de moderação avançada (antiporno, antilinkhard, antipalavrao, antipv, anticall, hidetag)\n- ✅ **ÚLTIMO**: Sistema anti-spam expandido com detecção de pornografia e palavrões\n- ✅ **ÚLTIMO**: Normalização de acentos para detecção precisa em português\n- ✅ **ÚLTIMO**: Proteções do dono (bloqueio de PV e chamadas)\n- ✅ **ÚLTIMO**: Comando hidetag para marcação oculta\n- ✅ **ÚLTIMO**: Menus atualizados com todas as novas funcionalidades\n\n## Estado Atual\n✅ **Bot Online e Funcionando no Replit**\n✅ **Antilink Implementado e Testado**\n✅ **Todos os Comandos Operacionais**\n✅ **Comando Pinterest Melhorado**\n✅ **Workflow Configurado e Rodando**\n✅ **Dependências Instaladas e Funcionando**\n✅ **Stickers com Selinho Quotado Implementado**\n✅ **Deployment Configurado para Produção (VM)**\n✅ **Bot Conectado e Processando Comandos Ativamente**\n✅ **Menu Principal Reformulado com Estatísticas Dinâmicas**\n✅ **Sistema de Configuração Seguro Implementado**\n✅ **Importação GitHub Configurada Completamente**\n✅ **Detecção Automática de Ambiente Replit**\n✅ **QR Code Automático em Ambiente Não-Interativo**\n\n### 🆕 Funcionalidades Recentes\n- **Menu Principal Avançado**: Novo design com contadores de comandos, grupos e registros\n- **Configuração de Segurança**: Template `.env.example` para configuração segura\n- **Estatísticas Dinâmicas**: Contagem automática de comandos, grupos e usuários registrados\n- **Sistema de Cargo**: Detecção automática de cargo (Dono, Admin, Membro)\n- **Saudação Inteligente**: Saudações baseadas no horário atual\n\n### 🚀 Ambiente de Produção\n- **Deployment Target**: VM (para conexão persistente)\n- **Comando de Produção**: `node main.js`\n- **Status**: Pronto para deploy\n\n### 🔧 Configuração GitHub Import (Setembro 2025)\n- **Importação Automática**: ✅ Bot configurado para funcionar após importação do GitHub\n- **Detecção Replit**: ✅ Sistema detecta automaticamente ambiente Replit/não-interativo\n- **Dependências**: ✅ Todas as dependências do npm instaladas automaticamente\n- **Workflow**: ✅ Configurado para executar `node main.js` no console\n- **Deploy**: ✅ Configurado para VM (conexão persistente necessária para WhatsApp)\n- **Ambiente**: ✅ Pronto para uso imediato após importação\n- **Status**: ✅ IMPORTAÇÃO CONCLUÍDA COM SUCESSO\n\n## Configuração para Replit\nEste projeto foi configurado para funcionar no ambiente Replit com as seguintes otimizações:\n\n### ✅ Configuração Realizada\n- **Workflow Configurado**: Bot executa via `node main.js` no console\n- **Dependências Instaladas**: Todas as dependências do package.json instaladas com sucesso\n- **Arquivos Corrompidos Corrigidos**: Removidos duplicatas e erros de sintaxe do index.js\n- **Configuração de Segurança**: Settings.json configurado com valores seguros (placeholders)\n- **Estrutura de Pastas**: Todas as pastas necessárias criadas automaticamente\n\n### 🔐 Configuração de Ambiente\nPara usar o bot, configure as seguintes variáveis de ambiente baseadas no arquivo `.env.example`:\n\n- `BOT_OWNER_NUMBER`: Seu número de WhatsApp (formato: 5527999999999)\n- `BOT_OWNER_NICKNAME`: Seu apelido\n- `BOT_NAME`: Nome do bot\n- `BOT_PREFIX`: Prefixo dos comandos (padrão: .)\n- `BOT_PHOTO_URL`: URL da foto do bot\n\n### 🚀 Como Iniciar no Replit\n1. O bot inicia automaticamente quando o projeto é executado\n2. Na primeira execução, escolha o método de conexão:\n   - **QR Code**: Para conectar via computador\n   - **Pareamento**: Para conectar via celular (digite seu número)\n3. Após conectar, o bot ficará online e processará comandos automaticamente\n\n### 📁 Arquivos de Sessão\n- Pasta `conexao/`: Contém arquivos de sessão do WhatsApp (gerados automaticamente)\n- Estes arquivos mantêm a sessão ativa entre reinicializações\n- **Importante**: Não compartilhar estes arquivos pois contêm credenciais de acesso","size_bytes":13797},"start.sh":{"content":"#!/bin/bash\n\nGREEN='\\033[1;32m'\nBLUE='\\033[0;34m'\n\nwhile :\ndo\n    # Texto de conexão\n    printf \"${BLUE} NEEXT LTDA 𝐂𝐎𝐍𝐄𝐂𝐓𝐀𝐍𝐃𝐎, 𝐀𝐆𝐔𝐀𝐑𝐃𝐄\\n\"\n\n    # Chama index.js com parâmetro opcional\n    if [ \"$1\" = \"sim\" ]; then\n        node index.js sim\n    elif [ \"$1\" = \"não\" ]; then\n        node connect.js não\n    else\n        node connect.js\n    fi\n\n    # Texto de inicialização\n    printf \"${GREEN}『 NEEXT LTDA 』𝐈𝐍𝐈𝐂𝐈𝐀𝐍𝐃𝐎  𝐍𝐎𝐕𝐀𝐌𝐄𝐍𝐓𝐄\\n\"\n\n    sleep 1\ndone","size_bytes":560},"arquivos/exif.js":{"content":"const fs = require('fs');\nconst { writeExif } = require('./sticker.js');\n\n// Função para converter imagem para WebP\nasync function imageToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a função existente do sticker.js\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter imagem para WebP:', error);\n        throw error;\n    }\n}\n\n// Função para converter vídeo para WebP\nasync function videoToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a função existente do sticker.js para vídeos\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter vídeo para WebP:', error);\n        throw error;\n    }\n}\n\n// Função para escrever EXIF em imagens com dados personalizados\nasync function writeExifImg(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuário\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF na imagem:', error);\n        throw error;\n    }\n}\n\n// Função para escrever EXIF em vídeos com dados personalizados\nasync function writeExifVid(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuário\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF no vídeo:', error);\n        console.log('🔄 Tentando processar como imagem estática...');\n        \n        // Fallback: tenta processar como imagem se falhar como vídeo\n        try {\n            const packname = options.packname;\n            const author = options.author;\n            const media = { data: buffer, mimetype: 'image/webp' };\n            const metadata = { packname, author, _isRename: true };\n            return await writeExif(media, metadata);\n        } catch (fallbackError) {\n            console.error('❌ Fallback também falhou:', fallbackError);\n            throw error; // Lança o erro original\n        }\n    }\n}\n\nmodule.exports = {\n    imageToWebp,\n    videoToWebp,\n    writeExifImg,\n    writeExifVid\n};","size_bytes":3027},"arquivos/rename.js":{"content":"const fs = require('fs-extra');\nconst {\nimageToWebp,\nvideoToWebp,\nwriteExifImg,\nwriteExifVid\n} = require('./exif');\nconst {\ngetBuffer\n} = require('./funcoes/function.js');\n\n// Selinho para usar como quoted nos stickers\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\n\nconst sendImageAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifImg para preservar metadados personalizados\n buffer = await writeExifImg(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anúncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"© NEEXT LTDA\",\n        body: \"📱 Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, {\n    sticker: {url: buffer}, \n    contextInfo: contextAnuncio,\n    ...options\n}, {quoted: selinho})\nreturn buffer;\n};\n\n\n\nconst sendVideoAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifVid para preservar metadados personalizados\n buffer = await writeExifVid(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anúncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"© NEEXT LTDA\",\n        body: \"📱 Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, { \n    sticker: { url: buffer }, \n    contextInfo: contextAnuncio,\n    ...options \n}, { quoted: selinho })\nreturn buffer;\n}\n\nmodule.exports = {\nsendVideoAsSticker,\nsendImageAsSticker\n};","size_bytes":2586},"arquivos/sticker.js":{"content":"const fs = require(\"fs\");\nconst { tmpdir } = require(\"os\");\nconst path = require(\"path\");\nconst Crypto = require(\"crypto\");\nconst ff = require(\"fluent-ffmpeg\");\nconst webp = require(\"node-webpmux\");\n\n// Gera arquivo temporário\nfunction getRandomFile(ext) {\n    return path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}${ext}`);\n}\n\n// Converte Buffer para WebP preservando transparência\nasync function bufferToWebp(buffer, isVideo = false, mimetype = null) {\n    // Detecta extensão correta baseada no mimetype para preservar transparência\n    let inputExt;\n    if (isVideo) {\n        inputExt = \".mp4\";\n    } else if (mimetype) {\n        if (mimetype.includes('png')) inputExt = \".png\";\n        else if (mimetype.includes('webp')) inputExt = \".webp\";\n        else if (mimetype.includes('gif')) inputExt = \".gif\";\n        else inputExt = \".jpg\";\n    } else {\n        inputExt = \".jpg\";\n    }\n\n    const input = getRandomFile(inputExt);\n    const output = getRandomFile(\".webp\");\n\n    fs.writeFileSync(input, buffer);\n\n    await new Promise((resolve, reject) => {\n        const ffmpegCommand = ff(input)\n            .on(\"error\", (err) => {\n                // Cleanup input file on error\n                if (fs.existsSync(input)) fs.unlinkSync(input);\n                reject(err);\n            })\n            .on(\"end\", () => resolve());\n\n        if (isVideo) {\n            // Para vídeos: máximo 6 segundos, 512px, preserva transparência\n            ffmpegCommand\n                .duration(6)\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"fps=15,scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"80\",\n                    \"-lossless\", \"0\"\n                ]);\n        } else {\n            // Para imagens: 512px, preserva transparência, sem fps\n            ffmpegCommand\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"90\"\n                ]);\n        }\n\n        ffmpegCommand\n            .toFormat(\"webp\")\n            .save(output);\n    });\n\n    // Cleanup input file\n    if (fs.existsSync(input)) fs.unlinkSync(input);\n    return output;\n}\n\n// Função writeExif para compatibilidade com index.js\nasync function writeExif(media, metadata) {\n    const { mimetype, data } = media;\n    \n    // Para comando RENAME: usa EXATAMENTE os valores fornecidos sem fallbacks\n    // Para outros comandos: usa fallbacks NEEXT se não houver valores\n    let packname, author, categories;\n    \n    if (metadata._isRename) {\n        // Comando rename: usa APENAS os valores fornecidos pelo usuário\n        packname = metadata.packname;\n        author = metadata.author;\n        categories = metadata.categories || [\"😎\"];\n    } else {\n        // Outros comandos: pode usar fallbacks NEEXT\n        packname = metadata.packname || \"NEEXT LTDA\";\n        author = metadata.author || \"NEEXT BOT\";\n        categories = metadata.categories || [\"😎\"];\n    }\n    \n    // Detecta se é vídeo/GIF\n    const isVideo = mimetype && (\n        mimetype.includes('video') || \n        mimetype.includes('gif') ||\n        mimetype === 'image/gif'\n    );\n    \n    const webpFile = await bufferToWebp(data, isVideo, mimetype);\n    const img = new webp.Image();\n    await img.load(webpFile);\n\n    const json = {\n        \"sticker-pack-id\": `${packname}-${Date.now()}`,\n        \"sticker-pack-name\": packname,\n        \"sticker-pack-publisher\": author,\n        \"sticker-pack-categories\": categories\n    };\n\n    const exifAttr = Buffer.from([0x49,0x49,0x2A,0x00,0x08,0x00,0x00,0x00,0x01,0x00,0x41,0x57,0x07,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00]);\n    const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\");\n    const exif = Buffer.concat([exifAttr, jsonBuff]);\n    exif.writeUIntLE(jsonBuff.length, 14, 4);\n\n    img.exif = exif;\n    await img.save(webpFile);\n\n    return webpFile;\n}\n\n// Cria sticker e envia (versão melhorada)\nasync function createSticker(buffer, sock, from, isVideo = false) {\n    try {\n        const agora = new Date();\n        const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n        \n        const webpFile = await writeExif(\n            { mimetype: isVideo ? 'video/mp4' : 'image/jpeg', data: buffer },\n            { \n                packname: \"NEEXT LTDA\", \n                author: `NEEXT BOT - ${dataHora}`, \n                categories: [\"🔥\"] \n            }\n        );\n        \n        const stickerBuffer = fs.readFileSync(webpFile);\n        await sock.sendMessage(from, { sticker: stickerBuffer });\n        fs.unlinkSync(webpFile);\n        \n        console.log(\"✅ Figurinha criada com sucesso!\");\n    } catch (err) {\n        console.log(\"❌ Erro ao criar figurinha:\", err);\n        await sock.sendMessage(from, { text: \"❌ Erro ao criar figurinha.\" });\n    }\n}\n\nmodule.exports = { createSticker, writeExif };","size_bytes":5439},"menus/menu.js":{"content":"// menu.js - Sistema de menus organizados do bot NEEXT LTDA\n\n// Função para obter configurações atualizadas em tempo real\nfunction obterConfiguracoes() {\n    delete require.cache[require.resolve('../settings/settings.json')];\n    return require('../settings/settings.json');\n}\n\n// Importa funções utilitárias\nconst { obterSaudacao, contarGrupos, contarComandos } = require('../arquivos/funcoes/function.js');\nconst { obterEstatisticas } = require('../arquivos/registros.js');\n\n// Função para determinar cargo do usuário\nasync function obterCargoUsuario(sock, from, sender) {\n    try {\n        // Verifica se é o dono\n        const config = obterConfiguracoes();\n        const numeroDono = config.numeroDoDono + \"@s.whatsapp.net\";\n        if (sender === numeroDono) {\n            return \"👑 Dono\";\n        }\n\n        // Se estiver em grupo, verifica se é admin\n        if (from.endsWith('@g.us') || from.endsWith('@lid')) {\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participant = groupMetadata.participants.find(p => p.id === sender);\n                if (participant && (participant.admin === 'admin' || participant.admin === 'superadmin')) {\n                    return \"🛡️ Admin\";\n                }\n            } catch (err) {\n                // Se der erro, assume membro\n            }\n        }\n\n        return \"👤 Membro\";\n    } catch (err) {\n        return \"👤 Membro\";\n    }\n}\n\n// ========================\n// MENU PRINCIPAL - NOVO FORMATO\n// ========================\nasync function obterMenuPrincipal(sock, from, sender, pushName) {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    \n    try {\n        // Obter informações dinâmicas\n        const saudacao = obterSaudacao();\n        const totalComandos = contarComandos();\n        const totalGrupos = await contarGrupos(sock);\n        const estatisticasRegistros = obterEstatisticas();\n        const cargoUsuario = await obterCargoUsuario(sock, from, sender);\n        const nomeUsuario = pushName || \"Usuário\";\n        \n        return `${saudacao}! 👋\n\n╭──〔 𖦹∘̥⸽⃟ INFORMAÇÕES 〕──⪩\n│ 𖦹∘̥⸽🎯⃟ Prefixo: 「 ${prefix} 」\n│ 𖦹∘̥⸽📊⃟ Total de Comandos: ${totalComandos}\n│ 𖦹∘̥⸽🤖⃟ Nome do Bot: ${nomeDoBot}\n│ 𖦹∘̥⸽👤⃟ Usuário: ${nomeUsuario}\n│ 𖦹∘̥⸽🛠️⃟ Versão: ^7.0.0-rc.3\n│ 𖦹∘̥⸽👑⃟ Dono: ${nickDoDono}\n│ 𖦹∘̥⸽📈⃟ Total de Grupos: ${totalGrupos}\n│ 𖦹∘̥⸽📝⃟ Total Registrado: ${estatisticasRegistros.totalRegistros}\n│ 𖦹∘̥⸽🎗️⃟ Cargo: ${cargoUsuario.split(' ')[1]}\n╰───────────────────⪨\n\n╭──〔 MENUS DISPONÍVEIS 〕──⪩\n│ 𖧈∘̥⸽🏠⃟ menuPrincipal\n│ 𖧈∘̥⸽🎬⃟ menudownload\n│ 𖧈∘̥⸽🖼️⃟ menufigurinhas\n│ 𖧈∘̥⸽🔞⃟ menuhentai\n│ 𖧈∘̥⸽🛠️⃟ menuadm\n│ 𖧈∘̥⸽👑⃟ menudono\n│ 𖧈∘̥⸽🎉⃟ menubrincadeira\n│ 𖧈∘̥⸽🧑‍🤝‍🧑⃟ menuMembro\n│ 𖧈∘̥⸽🎮⃟ menuGamer\n│ 𖧈∘̥⸽🌐⃟ menuNeext\n╰──────────────────────⪨\n\n© NEEXT LTDA`;\n    } catch (error) {\n        console.error('Erro ao gerar menu principal:', error);\n        // Fallback para menu simples\n        return `🤖 *${nomeDoBot} - MENU PRINCIPAL*\\n\\n📋 *CATEGORIAS DISPONÍVEIS:*\\n\\n👥 \\`${prefix}menumembro\\` - Comandos para membros\\n🛡️ \\`${prefix}menuadmin\\` - Comandos administrativos\\n👑 \\`${prefix}menudono\\` - Comandos do dono\\n\\n━━━━━━━━━━━━━━━\\n© NEEXT LTDA - ${nickDoDono}`;\n    }\n}\n\n// ========================\n// MENU MEMBRO (comandos básicos)\n// ========================\nfunction obterMenuMembro() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n👥 *COMANDOS PARA MEMBROS*\n\n🤖 *INFORMAÇÕES DO BOT:*\n• \\`${prefix}ping\\` - Status e informações do sistema\n• \\`${prefix}hora\\` - Horário atual\n• \\`${prefix}dono\\` - Informações do dono\n• \\`${prefix}recado\\` - Confirma que o bot está ativo\n• \\`prefixo\\` - Mostra o prefixo atual\n\n📝 *UTILITÁRIOS:*\n• \\`${prefix}status [texto]\\` - Atualiza status do bot\n• \\`${prefix}rg\\` - Registra-se no sistema do bot\n• \\`${prefix}hermitwhite [dados]\\` - Cria ID no sistema NEEXT\n\n🏷️ *STICKERS:*\n• \\`${prefix}s\\` - Converte mídia em sticker\n• \\`${prefix}rename [pack|author]\\` - Renomeia sticker\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ADMIN (comandos administrativos)\n// ========================\nfunction obterMenuAdmin() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🛡️ *COMANDOS ADMINISTRATIVOS*\n\n👥 *GERENCIAMENTO DE GRUPO:*\n• \\`${prefix}marca\\` - Menciona todos os membros\n• \\`${prefix}fechargrupo\\` / \\`${prefix}fechar\\` - Fecha o grupo\n• \\`${prefix}abrirgrupo\\` / \\`${prefix}abrir\\` - Abre o grupo\n• \\`${prefix}mudargrupo [nome]\\` - Altera nome do grupo\n• \\`${prefix}resetlink\\` - Gera novo link do grupo\n\n🗑️ *MODERAÇÃO:*\n• \\`${prefix}del\\` - Deleta mensagem marcada\n• \\`${prefix}ativarsolicitacao\\` - Ativa aprovação de membros\n• \\`${prefix}desativarsolicitacao\\` - Desativa aprovação\n• \\`${prefix}soloadmin\\` - Apenas admins editam grupo\n\n⚙️ *CONFIGURAÇÕES:*\n• \\`${prefix}antilink on/off\\` - Liga/desliga antilink\n• \\`${prefix}modogamer on/off\\` - Liga/desliga modo gamer\n• \\`${prefix}rpg on/off\\` - Liga/desliga sistema RPG\n\n📊 *STATUS:*\n• \\`${prefix}grupo-status\\` - Status do grupo\n• \\`${prefix}status-anti\\` - Status sistemas anti-spam\n\n⚠️ *Requer: Admin do grupo + Bot admin*\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DONO (comandos exclusivos)\n// ========================\nfunction obterMenuDono() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n👑 *COMANDOS DO DONO*\n\n⚙️ *CONFIGURAÇÕES DO BOT:*\n• \\`${prefix}trocar-prefixo [novo]\\` - Altera prefixo\n• \\`${prefix}trocar-nome [novo]\\` - Altera nome do bot\n• \\`${prefix}trocar-nick [novo]\\` - Altera nick do dono\n• \\`${prefix}configurar-bot\\` - Guia de configurações\n\n🛡️ *PROTEÇÃO AVANÇADA:*\n• \\`${prefix}antipv on/off\\` - Bloqueia PVs de não-donos\n• \\`${prefix}anticall on/off\\` - Rejeita chamadas automaticamente\n\n🔧 *CONTROLE TOTAL:*\n• Todos os comandos de admin funcionam\n• Bypass de todas as restrições\n• Controle completo sobre configurações\n\n⚠️ *Acesso exclusivo para: ${nickDoDono}*\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DOWNLOAD (mídia e downloads)\n// ========================\nfunction obterMenuDownload() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n📥 *DOWNLOADS E MÍDIA*\n\n🎵 *MÚSICA:*\n• \\`${prefix}play [nome]\\` - Busca música no YouTube\n• \\`${prefix}spotify [link]\\` - Download do Spotify\n\n📷 *IMAGENS:*\n• \\`${prefix}pinterest [busca]\\` - Imagens do Pinterest\n• \\`${prefix}brat [texto]\\` - Gera imagem BRAT\n\n📱 *REDES SOCIAIS:*\n• \\`${prefix}ig [link]\\` - Download Instagram\n• \\`${prefix}instagram [link]\\` - Download Instagram\n\n🏷️ *STICKERS:*\n• \\`${prefix}s\\` - Criar sticker de mídia\n• \\`${prefix}rename [pack|author]\\` - Editar sticker\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU GAMER (jogos e entretenimento)\n// ========================\nfunction obterMenuGamer() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🎮 *JOGOS E ENTRETENIMENTO*\n\n⚠️ *Requer \\`${prefix}modogamer on\\` ativo no grupo*\n\n🎯 *JOGOS INTERATIVOS:*\n• \\`${prefix}jogodavelha @user\\` - Jogo da velha\n• \\`${prefix}roletarussa @user\\` - Roleta russa\n• \\`${prefix}disparar\\` - Atirar na roleta russa\n• \\`${prefix}resetjogodavelha\\` - Reset jogo da velha\n• \\`${prefix}resetroleta\\` - Reset roleta russa\n\n🎲 *DIVERSÃO:*\n• \\`${prefix}eununca\\` - Eu nunca poll\n• \\`${prefix}impostor\\` - Escolhe impostor aleatório\n\n💥 *AÇÕES DIVERTIDAS:*\n• \\`${prefix}tapa @user\\` - Dar tapa\n• \\`${prefix}matar @user\\` - Matar alguém\n• \\`${prefix}atirar @user\\` - Atirar em alguém\n• \\`${prefix}atropelar @user\\` - Atropelar\n• \\`${prefix}beijar @user\\` - Beijar alguém\n• \\`${prefix}prender @user\\` - Prender alguém\n• \\`${prefix}sarra @user\\` - Sarrar em alguém\n• \\`${prefix}dedo @user\\` - Mostrar dedo\n\n📊 *RANKINGS DIVERTIDOS:*\n• \\`${prefix}rankcorno\\` - Rank dos cornos\n• \\`${prefix}rankgay\\` - Rank dos gays\n• \\`${prefix}ranklesbica\\` - Rank das lésbicas\n• \\`${prefix}rankburro\\` - Rank dos burros\n• \\`${prefix}rankfeio\\` - Rank dos feios\n• \\`${prefix}rankbonito\\` - Rank dos bonitos\n• \\`${prefix}rankfumante\\` - Rank dos fumantes\n• \\`${prefix}rankmaconheiro\\` - Rank dos maconheiros\n• \\`${prefix}rankpobre\\` - Rank dos pobres\n• \\`${prefix}ranksad\\` - Rank dos tristes\n• \\`${prefix}rankemo\\` - Rank dos emos\n• \\`${prefix}rankcasal\\` - Rank de casais\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ADM (todos os comandos de administradores)\n// ========================\nfunction obterMenuAdm() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🛡️ *COMANDOS DE ADMINISTRADORES*\n\n⚠️ *Requer: Admin do grupo + Bot admin*\n\n🔗 *SISTEMA ANTI-SPAM:*\n• \\`${prefix}x9 on/off\\` - Anti-X9 Monitor\n• \\`${prefix}antilink on/off\\` - Anti-links\n• \\`${prefix}antilinkhard on/off\\` - Anti-links avançado\n• \\`${prefix}anticontato on/off\\` - Anti-contatos\n• \\`${prefix}antidocumento on/off\\` - Anti-documentos\n• \\`${prefix}antivideo on/off\\` - Anti-vídeos\n• \\`${prefix}antiaudio on/off\\` - Anti-áudios\n• \\`${prefix}antisticker on/off\\` - Anti-stickers\n• \\`${prefix}antiflod on/off\\` - Anti-flood\n• \\`${prefix}antifake on/off\\` - Anti-números fake\n• \\`${prefix}antiporno on/off\\` - Anti-pornografia\n• \\`${prefix}antipalavrao on/off\\` - Anti-palavrões\n\n📋 *LISTA NEGRA:*\n• \\`${prefix}listanegra add @user\\` - Adicionar usuário\n• \\`${prefix}listanegra remove @user\\` - Remover usuário\n• \\`${prefix}listanegra list\\` - Ver lista negra\n\n🗑️ *MODERAÇÃO:*\n• \\`${prefix}del\\` - Deleta mensagem marcada\n• \\`${prefix}marca\\` - Menciona todos os membros\n• \\`${prefix}hidetag [texto]\\` - Marcação oculta\n\n🔒 *CONTROLE DO GRUPO:*\n• \\`${prefix}fechargrupo\\` - Fecha o grupo\n• \\`${prefix}abrirgrupo\\` - Abre o grupo\n• \\`${prefix}mudargrupo [nome]\\` - Altera nome do grupo\n• \\`${prefix}soloadmin\\` - Só admin edita grupo\n• \\`${prefix}resetlink\\` - Gera novo link do grupo\n\n👥 *CONTROLE DE ENTRADA:*\n• \\`${prefix}ativarsolicitacao\\` - Ativa aprovação\n• \\`${prefix}desativarsolicitacao\\` - Desativa aprovação\n\n🎮 *CONFIGURAÇÕES:*\n• \\`${prefix}modogamer on/off\\` - Modo gamer\n• \\`${prefix}grupo-status\\` - Status do grupo\n\n📸 *PERSONALIZAÇÃO:*\n• \\`${prefix}fotodogrupo\\` - Troca foto do grupo\n• \\`${prefix}fotodobot\\` - Troca foto do bot\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ANTI-SPAM\n// ========================\nfunction obterMenuAnti() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🛡️ *SISTEMA ANTI-SPAM*\n\n⚠️ *Requer: Admin + Bot admin*\n\n🔗 *PROTEÇÕES DISPONÍVEIS:*\n• \\`${prefix}antilink on/off\\` - Anti-links\n• \\`${prefix}antilinkhard on/off\\` - Anti-links avançado\n• \\`${prefix}anticontato on/off\\` - Anti-contatos\n• \\`${prefix}antidocumento on/off\\` - Anti-documentos\n• \\`${prefix}antivideo on/off\\` - Anti-vídeos\n• \\`${prefix}antiaudio on/off\\` - Anti-áudios\n• \\`${prefix}antisticker on/off\\` - Anti-stickers\n• \\`${prefix}antiflod on/off\\` - Anti-flood\n• \\`${prefix}antifake on/off\\` - Anti-números fake\n• \\`${prefix}antiporno on/off\\` - Anti-pornografia\n• \\`${prefix}antipalavrao on/off\\` - Anti-palavrões\n• \\`${prefix}x9 on/off\\` - Anti-X9\n\n📋 *LISTA NEGRA:*\n• \\`${prefix}listanegra add @user\\` - Adicionar à lista\n• \\`${prefix}listanegra remove @user\\` - Remover da lista\n• \\`${prefix}listanegra list\\` - Ver lista negra\n\n📊 *STATUS:*\n• \\`${prefix}status-anti\\` - Ver todas as proteções ativas\n\n🔴 *AÇÃO: Delete automático + Ban (se bot for admin)*\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU RPG (sistema NeextCity)\n// ========================\nfunction obterMenuRPG() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n💰 *SISTEMA RPG - NEEXTCITY MEGA 2.0*\n\n⚠️ *Requer \\`${prefix}rpg on\\` ativo no grupo*\n\n👤 *CADASTRO:*\n• \\`${prefix}registrar [nome] [banco]\\` - Registrar no RPG\n• \\`${prefix}saldo\\` - Ver saldo e estatísticas\n• \\`${prefix}perfil\\` - Ver perfil completo\n• \\`${prefix}rank\\` - Ranking dos mais ricos\n\n💼 *TRABALHOS (GANHAR GOLD):*\n• \\`${prefix}pescar\\` - Pescar para ganhar gold (vara necessária)\n• \\`${prefix}minerar\\` - Minerar recursos preciosos (picareta necessária)\n• \\`${prefix}trabalhar\\` - Trabalhar com base nos seus itens\n• \\`${prefix}cacar\\` - Caçar animais selvagens (rifle necessário)\n• \\`${prefix}coletar\\` - Coletar itens da natureza\n• \\`${prefix}agricultura\\` - Plantar e colher (sementes e fazenda necessárias)\n• \\`${prefix}entrega\\` - Fazer entregas na cidade\n\n🏴‍☠️ *ATIVIDADES ILEGAIS:*\n• \\`${prefix}assalto @user\\` - Assaltar outro jogador\n• \\`${prefix}roubar [local]\\` - Roubar locais (casas, lojas, bancos)\n\n🛒 *LOJA E INVENTÁRIO (8 CATEGORIAS):*\n• \\`${prefix}loja\\` - Ver todas as 8 categorias\n• \\`${prefix}loja propriedades\\` - Casas, fazendas, hotéis, ilhas\n• \\`${prefix}loja animais\\` - Pets, criações, dragões\n• \\`${prefix}loja ferramentas\\` - Picaretas, varas, rifles, sementes\n• \\`${prefix}loja veiculos\\` - Carros, motos, aviões, foguetes\n• \\`${prefix}loja negocios\\` - Empresas, restaurantes, multinacionais\n• \\`${prefix}loja tecnologia\\` - Computadores, setups, estúdios\n• \\`${prefix}loja decoracao\\` - Móveis, arte, piscinas\n• \\`${prefix}loja seguranca\\` - Proteções, blindagem, bunkers\n• \\`${prefix}comprar [item_id] [qtd]\\` - Comprar itens (1-10)\n• \\`${prefix}inventario\\` - Ver seus itens\n\n🎥 *INFLUENCIADOR DIGITAL:*\n• \\`${prefix}youtube\\` - Criar vídeo no YouTube (setup necessário)\n• \\`${prefix}tiktok\\` - Criar vídeo no TikTok (setup necessário)\n• \\`${prefix}twitch\\` - Fazer stream na Twitch (setup necessário)\n\n🎰 *JOGOS E INVESTIMENTOS:*\n• \\`${prefix}tigrinho [valor]\\` - Caça-níquel\n• \\`${prefix}apostar [valor]\\` - Apostar na sorte\n• \\`${prefix}investir [tipo] [valor]\\` - 7 tipos de investimentos\n\n📚 *EDUCAÇÃO E CRESCIMENTO:*\n• \\`${prefix}estudar\\` - Ver cursos disponíveis\n• \\`${prefix}estudar [num]\\` - Fazer curso específico\n\n💸 *SISTEMA BANCÁRIO:*\n• \\`${prefix}pix @user [valor]\\` - Transferir gold (18 bancos disponíveis)\n\n⚠️ *RECURSOS AVANÇADOS:*\n• Limites diários realistas (8 pescas, 6 minerações, 4 trabalhos)\n• Sistema de riscos (mortes, acidentes, prisões)\n• 100+ itens únicos com benefícios específicos\n• Progressão educacional (7 níveis de estudo)\n• Cooldowns balanceados para gameplay justo\n\n🌟 *NOVIDADES MEGA 2.0:*\n✅ Loja com 8 categorias e 100+ itens\n✅ Sistema YouTuber/TikTok/Twitch\n✅ Comando roubar com 12 locais\n✅ 18 bancos diferentes para escolher\n✅ Riscos realistas (mortes, falhas)\n✅ Ferramentas obrigatórias para trabalhos\n✅ Limites diários para gameplay equilibrado\n\n💸 *SISTEMA BANCÁRIO:*\n• \\`${prefix}pix @user [valor]\\` - Transferir gold\n• \\`${prefix}saldo\\` - Ver saldo e estatísticas\n• \\`${prefix}rank\\` - Ranking dos mais ricos\n\n🏪 *CATEGORIAS DA LOJA:*\n• **Propriedades** - Casas, fazendas, empresas\n• **Animais** - Galinhas, cavalos, gatos\n• **Veículos** - Motos, carros, aviões\n• **Ferramentas** - Varas, picaretas, tratores\n• **Negócios** - Lanchonetes, academias\n\n💡 *Ganhe gold, compre itens e domine NeextCity!*\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU STICKERS (figurinhas)\n// ========================\nfunction obterMenuSticker() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🏷️ *MENU DE STICKERS*\n\n✨ *CRIAR STICKERS:*\n• \\`${prefix}s\\` - Converte mídia em sticker\n• \\`${prefix}sticker\\` - Criar sticker de imagem/vídeo\n• \\`${prefix}attp [texto]\\` - Sticker de texto animado\n• \\`${prefix}ttp [texto]\\` - Sticker de texto simples\n\n🎨 *EDITAR STICKERS:*\n• \\`${prefix}rename [pack|author]\\` - Renomear sticker\n• \\`${prefix}take [pack] [author]\\` - Roubar sticker\n• \\`${prefix}toimg\\` - Converter sticker em imagem\n\n🎭 *STICKERS ESPECIAIS:*\n• \\`${prefix}emoji [emoji]\\` - Sticker de emoji\n• \\`${prefix}semoji [emoji]\\` - Sticker emoji simples\n\n📝 *COMO USAR:*\n• Envie uma imagem/vídeo com \\`${prefix}s\\`\n• Marque um sticker e use \\`${prefix}take\\`\n• Use \\`${prefix}rename\\` para personalizar\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU BRINCADEIRAS (coming soon)\n// ========================\nfunction obterMenuBrincadeira() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🎉 *MENU BRINCADEIRAS*\n\n⚠️ *EM DESENVOLVIMENTO*\n\n🚧 Este menu está sendo finalizado e em breve terá:\n\n🎭 **Comandos de Diversão:**\n• Roleta de perguntas\n• Verdade ou desafio\n• Simulador de namorados\n• Gerador de casais aleatórios\n\n🎲 **Interações Divertidas:**\n• Perguntas para o grupo\n• Desafios aleatórios\n• Brincadeiras de grupo\n\n📅 **Status:** Em desenvolvimento\n⏰ **Previsão:** Próxima atualização\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU HENTAI (coming soon)\n// ========================\nfunction obterMenuHentai() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n🔞 *MENU HENTAI*\n\n⚠️ *EM DESENVOLVIMENTO*\n\n🚧 Este menu está sendo finalizado e em breve terá:\n\n🎨 **Conteúdo Artístico:**\n• Imagens de anime\n• Wallpapers temáticos\n• Arte digital\n\n⚠️ **Importante:**\n• Conteúdo será adequado às diretrizes\n• Uso responsável obrigatório\n• Apenas em grupos privados\n\n📅 **Status:** Em desenvolvimento\n⏰ **Previsão:** Próxima atualização\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DONO AVANÇADO (coming soon)\n// ========================\nfunction obterMenuDonoAvancado() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n👑 *MENU DONO AVANÇADO*\n\n⚠️ *EM DESENVOLVIMENTO*\n\n🚧 Este menu está sendo finalizado e em breve terá:\n\n🔧 **Controle Total:**\n• Backup de configurações\n• Gerenciamento de grupos em massa\n• Logs detalhados do sistema\n• Controle de usuários globais\n\n⚙️ **Configurações Avançadas:**\n• Auto-moderação inteligente\n• Respostas automáticas personalizadas\n• Sistema de recompensas\n\n📅 **Status:** Em desenvolvimento\n⏰ **Previsão:** Próxima atualização\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// GUIA DE CONFIGURAÇÃO\n// ========================\nfunction obterConfigurarBot() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\n⚙️ *CONFIGURAR BOT - GUIA COMPLETO*\n\n🔧 *COMANDOS DE CONFIGURAÇÃO (Apenas Dono):*\n\n📝 *ALTERAR PREFIXO:*\n\\`${prefix}trocar-prefixo [novo]\\`\n*Exemplo:* \\`${prefix}trocar-prefixo !\\`\n*Resultado:* Prefixo mudará de \"${prefix}\" para \"!\"\n\n🤖 *ALTERAR NOME DO BOT:*\n\\`${prefix}trocar-nome [novo nome]\\`\n*Exemplo:* \\`${prefix}trocar-nome MeuBot Incrível\\`\n*Resultado:* Nome mudará de \"${nomeDoBot}\"\n\n👤 *ALTERAR NICK DO DONO:*\n\\`${prefix}trocar-nick [novo nick]\\`\n*Exemplo:* \\`${prefix}trocar-nick Administrador\\`\n*Resultado:* Nick mudará de \"${nickDoDono}\"\n\n📋 *CONFIGURAÇÕES ATUAIS:*\n• **Prefixo:** ${prefix}\n• **Nome do Bot:** ${nomeDoBot}\n• **Nick do Dono:** ${nickDoDono}\n\n⚠️ *IMPORTANTE:*\n• Apenas o dono pode usar esses comandos\n• As mudanças são aplicadas instantaneamente\n• Configurações são salvas automaticamente\n\n━━━━━━━━━━━━━━━\n© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\nmodule.exports = {\n    obterMenuPrincipal,\n    obterMenuMembro,\n    obterMenuAdmin,\n    obterMenuAdm,\n    obterMenuDono,\n    obterMenuDownload,\n    obterMenuGamer,\n    obterMenuAnti,\n    obterMenuRPG,\n    obterMenuSticker,\n    obterMenuBrincadeira,\n    obterMenuHentai,\n    obterMenuDonoAvancado,\n    obterConfigurarBot\n};","size_bytes":21207},"arquivos/funcoes/function.js":{"content":"// ---------------------------\n// Pacotes\n// ---------------------------\nconst cfonts = require(\"cfonts\");\n\n// ---------------------------\n// Configurações do Bot\n// ---------------------------\nconst settings = require(\"../../settings/settings.json\");\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// ---------------------------\n// Banner do bot\n// ---------------------------\nfunction mostrarBanner() {\n    console.clear();\n\n    // NEEXT em roxo sólido\n    cfonts.say(\"NEEXT\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    // LTDA em roxo sólido\n    cfonts.say(\"LTDA\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    console.log(\"\\n\");\n}\n\n// ---------------------------\n// Logs simples (sem duplicação e sem criar arquivos)\n// ---------------------------\nconst mensagensRegistradas = new Set();\n\nfunction logMensagem(m, text = \"\", isCommand = false) {\n    const fromMe = m?.key?.fromMe || false;\n    const jid = m?.key?.remoteJid || \"\";\n    const isGroup = jid.endsWith(\"@g.us\") || jid.endsWith(\"@lid\");\n    const sender = (m?.key?.participant || jid)?.split(\"@\")[0] || \"desconhecido\";\n    const pushName = m?.pushName || \"Sem nome\";\n\n    const conteudo = text || (() => {\n        if (m?.message?.conversation) return m.message.conversation;\n        if (m?.message?.extendedTextMessage?.text) return m.message.extendedTextMessage.text;\n        if (m?.message?.imageMessage?.caption) return m.message.imageMessage.caption;\n        if (m?.message?.videoMessage?.caption) return m.message.videoMessage.caption;\n        return \"[conteúdo não suportado]\";\n    })();\n\n    // Evita duplicação\n    const logKey = `${fromMe}-${jid}-${conteudo}`;\n    if (mensagensRegistradas.has(logKey)) return;\n    mensagensRegistradas.add(logKey);\n\n    const tipo = isCommand || (conteudo.startsWith(prefix)) ? \"[COMANDO]\" : \"[MENSAGEM]\";\n    const local = isGroup ? \"GRUPO\" : \"PV\";\n    const remetente = `${pushName} (${sender})${fromMe ? \" [EU]\" : \"\"}`;\n\n    const logText = `\n───────────────────────────────\n${tipo} ${local}\nDe: ${remetente}\nConteúdo: ${conteudo}\n───────────────────────────────`;\n\n    console.log(logText);\n}\n\n// ---------------------------\n// Função para buscar buffer de URL\n// ---------------------------\nasync function getBuffer(url) {\n    try {\n        const response = await require('axios').get(url, { responseType: 'arraybuffer' });\n        return Buffer.from(response.data);\n    } catch (error) {\n        console.error('Erro ao buscar buffer da URL:', error);\n        throw error;\n    }\n}\n\n// Função para formatar JID\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\n// ---------------------------\n// Função para saudação baseada no horário\n// ---------------------------\nfunction obterSaudacao() {\n    const moment = require('moment-timezone');\n    const hora = moment().tz('America/Sao_Paulo').hour();\n    \n    if (hora >= 6 && hora < 12) {\n        return \"🌅 Bom dia\";\n    } else if (hora >= 12 && hora < 18) {\n        return \"☀️ Boa tarde\";\n    } else if (hora >= 18 && hora < 24) {\n        return \"🌙 Boa noite\";\n    } else {\n        return \"🌃 Boa madrugada\";\n    }\n}\n\n// ---------------------------\n// Função para contar grupos\n// ---------------------------\nasync function contarGrupos(sock) {\n    try {\n        const grupos = await sock.groupFetchAllParticipating();\n        return Object.keys(grupos).length;\n    } catch (error) {\n        console.error('Erro ao contar grupos:', error);\n        return 0;\n    }\n}\n\n// ---------------------------\n// Função para contar comandos automaticamente\n// ---------------------------\nfunction contarComandos() {\n    try {\n        const fs = require('fs');\n        const path = require('path');\n        \n        // Lê o arquivo index.js\n        const indexPath = path.join(__dirname, '../../index.js');\n        const indexContent = fs.readFileSync(indexPath, 'utf8');\n        \n        // Procura por todos os cases no switch da função handleCommand\n        const casePattern = /case\\s+\"([^\"]+)\"/g;\n        const matches = [];\n        let match;\n        \n        while ((match = casePattern.exec(indexContent)) !== null) {\n            // Evita duplicatas e ignora cases internos como break cases\n            if (!matches.includes(match[1])) {\n                matches.push(match[1]);\n            }\n        }\n        \n        console.log(`📊 Total de comandos encontrados automaticamente: ${matches.length}`);\n        return matches.length;\n    } catch (error) {\n        console.error('❌ Erro ao contar comandos automaticamente:', error);\n        // Fallback para contagem manual se houver erro\n        return 25; // estimativa atual\n    }\n}\n\n// ---------------------------\n// Exportações\n// ---------------------------\nmodule.exports = {\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n    getBuffer,\n    obterSaudacao,\n    contarGrupos,\n    contarComandos\n};","size_bytes":5361},"arquivos/antispam.js":{"content":"// Sistema Anti-Spam Completo para WhatsApp Bot\nconst fs = require('fs');\nconst path = require('path');\n\n// Diretórios do sistema\nconst GRUPOS_DIR = path.join(__dirname, '../database/grupos/ativadogrupo');\nconst CACHE_FLOOD = new Map(); // Cache para controle de flood\n\n// Utilitários\nfunction formatGroupId(groupId) {\n    return groupId.replace('@g.us', '').replace('@lid', '').replace(/[^a-zA-Z0-9]/g, '_');\n}\n\n// Verifica se número é brasileiro\nfunction isNumeroBrasileiro(jid) {\n    if (!jid || typeof jid !== 'string') return false;\n    \n    // Remove o @s.whatsapp.net para pegar apenas o número\n    const numero = jid.replace('@s.whatsapp.net', '');\n    \n    // Verifica se começa com 55 (código do Brasil)\n    // Formatos aceitos: 55XXXXXXXXXXX (13 dígitos) ou 5511XXXXXXXXX (12 dígitos para alguns casos)\n    const brasileiroRegex = /^55[1-9][0-9]{8,9}$/;\n    \n    return brasileiroRegex.test(numero);\n}\n\nfunction getGroupConfigPath(groupId) {\n    const formattedId = formatGroupId(groupId);\n    return path.join(GRUPOS_DIR, `${formattedId}.json`);\n}\n\n// Carrega configuração de um grupo\nfunction carregarConfigGrupo(groupId) {\n    try {\n        const configPath = getGroupConfigPath(groupId);\n        if (!fs.existsSync(configPath)) {\n            return {\n                antilink: false,\n                anticontato: false,\n                antidocumento: false,\n                antivideo: false,\n                antiaudio: false,\n                antisticker: false,\n                antiflod: false,\n                antifake: false,\n                x9: false,\n                modogamer: false,\n                antiporno: false,\n                antilinkhard: false,\n                antipalavrao: false,\n                antipv: false,\n                anticall: false,\n                rankativo: false,\n                welcome1: false,\n                listanegra: [],\n                floodConfig: {\n                    maxMensagens: 5,\n                    tempoSegundos: 10\n                }\n            };\n        }\n        const data = fs.readFileSync(configPath, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(`❌ Erro ao carregar config do grupo ${groupId}:`, err);\n        return null;\n    }\n}\n\n// Salva configuração de um grupo\nfunction salvarConfigGrupo(groupId, config) {\n    try {\n        // Garante que o diretório existe\n        if (!fs.existsSync(GRUPOS_DIR)) {\n            fs.mkdirSync(GRUPOS_DIR, { recursive: true });\n        }\n        \n        const configPath = getGroupConfigPath(groupId);\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n        return true;\n    } catch (err) {\n        console.error(`❌ Erro ao salvar config do grupo ${groupId}:`, err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Detecta links difíceis de encontrar (antilinkhard)\nfunction detectarLinksHard(texto) {\n    if (!texto) return false;\n    // Remove espaços e caracteres especiais\n    const textoLimpo = texto.replace(/[\\s\\-_\\.]/g, '');\n    \n    const linksHardRegex = [\n        // Links com separadores: w.w.w, h.t.t.p.s\n        /w\\.w\\.w|h\\.t\\.t\\.p\\.s|h\\.t\\.t\\.p/i,\n        // Links com espaços: w w w . , h t t p s : / /\n        /w\\s*w\\s*w\\s*\\.|h\\s*t\\s*t\\s*p\\s*s?\\s*:/i,\n        // Links com underscore: w_w_w_, http_s\n        /w_w_w_|h_t_t_p_s?/i,\n        // Links camuflados: ｗｗｗ (unicode), ＨＴＴＰs\n        /ｗｗｗ|ＨＴＴＰ/i,\n        // Números como letras: w4atsapp, 1nstagram\n        /w4atsapp|1nstagram|f4cebook|t1ktok/i,\n        // Links com hífen excessivo: w-w-w, h-t-t-p\n        /w-w-w|h-t-t-p/i,\n        // Links espelhados ou invertidos\n        /ptt\\.|moc\\.|gro\\./i,\n        // Domínios disfarçados: bit.ly > b1t.ly, tinyurl > t1nyurl\n        /b1t\\.ly|t1nyurl|sh0rt|l1nk|ur\\.l/i,\n        // WhatsApp camuflado: \n        /chat.*whats.*app|wa.*me|whats.*app.*chat/i\n    ];\n    \n    return linksHardRegex.some(regex => regex.test(textoLimpo));\n}\n\n// Detecta conteúdo pornográfico\nfunction detectarPorno(texto, message) {\n    if (!texto && !message) return false;\n    \n    // Lista de palavras relacionadas a pornografia\n    const palavrasPorno = [\n        // Palavras explícitas\n        'porno', 'pornografia', 'pornô', 'xxx', 'sexo', 'nude', 'nua', 'pelada',\n        'buceta', 'pau', 'pênis', 'vagina', 'peitos', 'seios', 'rola', 'piru',\n        'xota', 'xereca', 'ppk', 'penis', 'tesao', 'tesão', 'gozar', 'gozo',\n        'masturbação', 'masturbar', 'punheta', 'siririca', 'puta', 'putaria',\n        'safada', 'safado', 'gostosa', 'gostoso', 'bundão', 'bunduda',\n        // Sites pornôs conhecidos\n        'pornhub', 'xvideos', 'redtube', 'xhamster', 'youporn', 'tube8',\n        'spankbang', 'xnxx', 'brazzers', 'realitykings', 'bangbros',\n        // Termos relacionados\n        'hentai', 'ecchi', 'ahegao', 'futanari', 'yaoi', 'yuri',\n        'onlyfans', 'privacy', 'webcam', 'camgirl', 'stripper',\n        // Variações com números/símbolos\n        'p0rno', 'p0rn', 's3xo', 'x x x', 'p.o.r.n', 's.e.x.o'\n    ];\n    \n    // Função para normalizar texto removendo acentos mas preservando caracteres\n    function normalizarTexto(texto) {\n        return texto\n            .toLowerCase()\n            .normalize('NFD') // Decompõe caracteres acentuados\n            .replace(/[\\u0300-\\u036f]/g, '') // Remove os diacríticos (acentos)\n            .replace(/[^a-zA-Z0-9\\s]/g, '') // Remove caracteres especiais exceto espaços\n            .replace(/\\s+/g, ' ') // Normaliza espaços múltiplos\n            .trim();\n    }\n\n    // Verifica no texto\n    if (texto) {\n        const textoLimpo = normalizarTexto(texto);\n        for (const palavra of palavrasPorno) {\n            const palavraNormalizada = normalizarTexto(palavra);\n            if (textoLimpo.includes(palavraNormalizada)) {\n                return true;\n            }\n        }\n    }\n    \n    // Verifica em legendas de mídia\n    if (message) {\n        const caption = message.imageMessage?.caption || message.videoMessage?.caption || '';\n        if (caption) {\n            const captionLimpa = normalizarTexto(caption);\n            for (const palavra of palavrasPorno) {\n                const palavraNormalizada = normalizarTexto(palavra);\n                if (captionLimpa.includes(palavraNormalizada)) {\n                    return true;\n                }\n            }\n        }\n        \n        // Verifica se é mídia suspeita (imagem/vídeo sem caption em contexto suspeito)\n        if (message.imageMessage || message.videoMessage) {\n            // Por segurança, se não houver caption mas for mídia, pode ser verificado por moderador\n            return false; // Por enquanto não bloqueia automaticamente mídia sem caption\n        }\n    }\n    \n    return false;\n}\n\n// Detecta palavrões\nfunction detectarPalavrao(texto) {\n    if (!texto) return false;\n    \n    const palavroes = [\n        // Palavrões comuns\n        'filho da puta', 'fdp', 'porra', 'caralho', 'merda', 'cu', 'bosta',\n        'desgraça', 'desgraçado', 'puto', 'puta', 'cacete', 'cuzão', 'cuzao',\n        'otário', 'otario', 'babaca', 'imbecil', 'idiota', 'burro', 'estúpido',\n        'estupido', 'retardado', 'mongolóide', 'mongoloide', 'débil', 'debil',\n        'trouxa', 'lesado', 'lesão', 'lesao', 'vagabundo', 'vagabunda',\n        'safado', 'safada', 'corno', 'cornudo', 'chifrudo', 'cuckold',\n        // Palavrões com variações\n        'p0rra', 'c4ralho', 'm3rda', 'c@ralho', 'p0uta', 'put@',\n        'fdp', 'f.d.p', 'f d p', 'filhodaputa', 'filho-da-puta',\n        // Xingamentos racistas/preconceituosos\n        'macaco', 'negro', 'preto', 'mulata', 'crioulo', 'neguinho',\n        'favelado', 'favelada', 'nordestino', 'paraíba', 'baiano',\n        // Ofensas religiosas\n        'demônio', 'diabo', 'capeta', 'inferno', 'satanás', 'satanas',\n        // Palavrões regionais\n        'baitola', 'viado', 'bicha', 'boiola', 'fresco', 'maricas',\n        'piranha', 'galinha', 'vadia', 'rameira', 'prostituta'\n    ];\n    \n    // Função para normalizar texto removendo acentos mas preservando caracteres\n    function normalizarTexto(texto) {\n        return texto\n            .toLowerCase()\n            .normalize('NFD') // Decompõe caracteres acentuados\n            .replace(/[\\u0300-\\u036f]/g, '') // Remove os diacríticos (acentos)\n            .replace(/[^a-zA-Z0-9\\s]/g, ' ') // Remove caracteres especiais exceto espaços\n            .replace(/\\s+/g, ' ') // Normaliza espaços múltiplos\n            .trim();\n    }\n\n    const textoLimpo = normalizarTexto(texto);\n    \n    for (const palavrao of palavroes) {\n        // Verifica palavra exata\n        const palavraoNormalizado = normalizarTexto(palavrao);\n        if (textoLimpo.includes(palavraoNormalizado)) {\n            return true;\n        }\n        \n        // Verifica palavra com espaços\n        const palavraoComEspacos = palavraoNormalizado.split('').join('\\\\s*');\n        const regex = new RegExp(palavraoComEspacos, 'i');\n        if (regex.test(textoLimpo)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Verifica se é contact/contato\nfunction isContactMessage(message) {\n    return !!(message.contactMessage || message.contactsArrayMessage);\n}\n\n// Verifica se é documento\nfunction isDocumentMessage(message) {\n    return !!(message.documentMessage);\n}\n\n// Verifica se é vídeo\nfunction isVideoMessage(message) {\n    return !!(message.videoMessage);\n}\n\n// Verifica se é áudio\nfunction isAudioMessage(message) {\n    return !!(message.audioMessage || message.pttMessage);\n}\n\n// Verifica se é sticker\nfunction isStickerMessage(message) {\n    return !!(message.stickerMessage);\n}\n\n// Controle de flood\nfunction verificarFlood(userId, groupId, config) {\n    if (!config.antiflod) return false;\n    \n    const key = `${groupId}_${userId}`;\n    const agora = Date.now();\n    const limite = config.floodConfig.tempoSegundos * 1000;\n    \n    if (!CACHE_FLOOD.has(key)) {\n        CACHE_FLOOD.set(key, []);\n    }\n    \n    const mensagens = CACHE_FLOOD.get(key);\n    \n    // Remove mensagens antigas\n    const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < limite);\n    \n    // Adiciona nova mensagem\n    mensagensRecentes.push(agora);\n    CACHE_FLOOD.set(key, mensagensRecentes);\n    \n    // Verifica se excedeu o limite\n    return mensagensRecentes.length > config.floodConfig.maxMensagens;\n}\n\n// Limpa cache de flood periodicamente\nsetInterval(() => {\n    const agora = Date.now();\n    for (const [key, mensagens] of CACHE_FLOOD.entries()) {\n        const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < 60000); // 1 minuto\n        if (mensagensRecentes.length === 0) {\n            CACHE_FLOOD.delete(key);\n        } else {\n            CACHE_FLOOD.set(key, mensagensRecentes);\n        }\n    }\n}, 60000);\n\n// Verifica se usuário está na lista negra\nfunction isUsuarioListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    return config.listanegra.includes(userId);\n}\n\n// Adiciona usuário à lista negra\nfunction adicionarListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    if (!config.listanegra) config.listanegra = [];\n    \n    if (!config.listanegra.includes(userId)) {\n        config.listanegra.push(userId);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // Já estava na lista\n}\n\n// Remove usuário da lista negra\nfunction removerListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    \n    const index = config.listanegra.indexOf(userId);\n    if (index > -1) {\n        config.listanegra.splice(index, 1);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // Não estava na lista\n}\n\n// Ativa/desativa funcionalidade anti\nfunction toggleAntiFeature(groupId, feature, estado) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    const validFeatures = ['antilink', 'anticontato', 'antidocumento', 'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'x9', 'antiporno', 'antilinkhard', 'antipalavrao', 'antipv', 'anticall', 'rankativo'];\n    \n    if (!validFeatures.includes(feature)) return false;\n    \n    if (estado === 'on' || estado === 'ativar' || estado === '1') {\n        config[feature] = true;\n    } else if (estado === 'off' || estado === 'desativar' || estado === '0') {\n        config[feature] = false;\n    } else {\n        return config[feature]; // Retorna estado atual\n    }\n    \n    return salvarConfigGrupo(groupId, config) ? config[feature] : false;\n}\n\n// Processa mensagem para verificar violações\nfunction processarMensagem(message, groupId, userId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return { violacao: false };\n    \n    const violations = [];\n    \n    // Extrai texto da mensagem\n    let texto = '';\n    if (message.conversation) texto = message.conversation;\n    if (message.extendedTextMessage?.text) texto = message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) texto = message.imageMessage.caption;\n    if (message.videoMessage?.caption) texto = message.videoMessage.caption;\n    \n    // Verifica antilink\n    if (config.antilink && detectarLinks(texto)) {\n        violations.push('antilink');\n    }\n    \n    // Verifica antilinkhard\n    if (config.antilinkhard && detectarLinksHard(texto)) {\n        violations.push('antilinkhard');\n    }\n    \n    // Verifica antiporno\n    if (config.antiporno && detectarPorno(texto, message)) {\n        violations.push('antiporno');\n    }\n    \n    // Verifica antipalavrao\n    if (config.antipalavrao && detectarPalavrao(texto)) {\n        violations.push('antipalavrao');\n    }\n    \n    // Verifica anticontato\n    if (config.anticontato && isContactMessage(message)) {\n        violations.push('anticontato');\n    }\n    \n    // Verifica antidocumento\n    if (config.antidocumento && isDocumentMessage(message)) {\n        violations.push('antidocumento');\n    }\n    \n    // Verifica antivideo\n    if (config.antivideo && isVideoMessage(message)) {\n        violations.push('antivideo');\n    }\n    \n    // Verifica antiaudio\n    if (config.antiaudio && isAudioMessage(message)) {\n        violations.push('antiaudio');\n    }\n    \n    // Verifica antisticker\n    if (config.antisticker && isStickerMessage(message)) {\n        violations.push('antisticker');\n    }\n    \n    // Verifica antiflod\n    if (verificarFlood(userId, groupId, config)) {\n        violations.push('antiflod');\n    }\n    \n    return {\n        violacao: violations.length > 0,\n        tipos: violations,\n        config\n    };\n}\n\n// Exporta todas as funções\nmodule.exports = {\n    // Gerenciamento de configuração\n    carregarConfigGrupo,\n    salvarConfigGrupo,\n    \n    // Toggle de funcionalidades\n    toggleAntiFeature,\n    \n    // Lista negra\n    isUsuarioListaNegra,\n    adicionarListaNegra,\n    removerListaNegra,\n    \n    // Processamento\n    processarMensagem,\n    \n    // Detecções específicas\n    detectarLinks,\n    detectarLinksHard,\n    detectarPorno,\n    detectarPalavrao,\n    isContactMessage,\n    isDocumentMessage,\n    isVideoMessage,\n    isAudioMessage,\n    isStickerMessage,\n    verificarFlood,\n    isNumeroBrasileiro,\n    \n    // Utilitários\n    formatGroupId,\n    getGroupConfigPath\n};","size_bytes":15840},"arquivos/rpg.js":{"content":"\n// Sistema RPG NeextCity - NOVA GERAÇÃO COMPLETA\nconst fs = require('fs');\nconst path = require('path');\nconst moment = require('moment-timezone');\n\n// Caminho para o arquivo de dados do RPG\nconst rpgDataFile = path.join(__dirname, '../database/grupos/rpg_data.json');\n\n// Sistema de Mutex para evitar race conditions\nlet rpgLock = false;\n\nasync function withLock(fn) {\n    while (rpgLock) {\n        await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    rpgLock = true;\n    try {\n        return await fn();\n    } finally {\n        rpgLock = false;\n    }\n}\n\n// ==================== CONSTANTES DO JOGO ====================\n\n// Bancos disponíveis (18 opções)\nconst bancos = [\n    { id: 'nubank', nome: '💜 Nubank', emoji: '💜' },\n    { id: 'inter', nome: '🧡 Inter', emoji: '🧡' },\n    { id: 'santander', nome: '🔴 Santander', emoji: '🔴' },\n    { id: 'bradesco', nome: '🔵 Bradesco', emoji: '🔵' },\n    { id: 'itau', nome: '🟠 Itaú', emoji: '🟠' },\n    { id: 'bb', nome: '🟡 Banco do Brasil', emoji: '🟡' },\n    { id: 'caixa', nome: '🏦 Caixa', emoji: '🏦' },\n    { id: 'picpay', nome: '💚 PicPay', emoji: '💚' },\n    { id: 'c6bank', nome: '⚫ C6 Bank', emoji: '⚫' },\n    { id: 'next', nome: '⚪ Next', emoji: '⚪' },\n    { id: 'neon', nome: '🔺 Neon', emoji: '🔺' },\n    { id: 'original', nome: '🟤 Original', emoji: '🟤' },\n    { id: 'safra', nome: '🟣 Safra', emoji: '🟣' },\n    { id: 'will', nome: '🔸 Will Bank', emoji: '🔸' },\n    { id: 'c6', nome: '⚪ C6 Bank', emoji: '⚪' },\n    { id: 'bs2', nome: '🟨 BS2', emoji: '🟨' },\n    { id: 'bmg', nome: '🟫 BMG', emoji: '🟫' },\n    { id: 'sicoob', nome: '🟢 Sicoob', emoji: '🟢' }\n];\n\n// Níveis de educação com progressão realista\nconst educacao = {\n    1: { nome: 'Ensino Fundamental', custo: 0, tempo: 1, salarioMin: 50 },\n    2: { nome: 'Ensino Médio', custo: 1000, tempo: 2, salarioMin: 100 },\n    3: { nome: 'Curso Técnico', custo: 3000, tempo: 3, salarioMin: 200 },\n    4: { nome: 'Graduação', custo: 8000, tempo: 4, salarioMin: 400 },\n    5: { nome: 'Pós-graduação', custo: 15000, tempo: 5, salarioMin: 600 },\n    6: { nome: 'Mestrado', custo: 25000, tempo: 6, salarioMin: 800 },\n    7: { nome: 'Doutorado', custo: 40000, tempo: 8, salarioMin: 1200 }\n};\n\n// Cursos universitários específicos\nconst faculdades = {\n    medicina: { nome: 'Medicina', custo: 100000, tempo: 12, salario: 2000 },\n    engenharia: { nome: 'Engenharia', custo: 60000, tempo: 10, salario: 1500 },\n    direito: { nome: 'Direito', custo: 50000, tempo: 10, salario: 1300 },\n    administracao: { nome: 'Administração', custo: 35000, tempo: 8, salario: 1000 },\n    ti: { nome: 'Tecnologia da Informação', custo: 45000, tempo: 8, salario: 1800 },\n    psicologia: { nome: 'Psicologia', custo: 40000, tempo: 10, salario: 900 },\n    odontologia: { nome: 'Odontologia', custo: 80000, tempo: 10, salario: 1600 },\n    veterinaria: { nome: 'Veterinária', custo: 70000, tempo: 10, salario: 1400 }\n};\n\n// Loja completa com 8 categorias e +100 itens\nconst loja = {\n    // CATEGORIA 1: PROPRIEDADES (15 itens)\n    propriedades: {\n        barraca: { \n            id: 'barraca', nome: '⛺ Barraca', preco: 500, categoria: 'propriedades', emoji: '⛺',\n            durabilidade: 50, durabilidade_max: 50, beneficio: '+10 gold/dia (renda passiva)', renda_passiva: 10,\n            descricao: 'Abrigo básico para começar'\n        },\n        casa_madeira: { \n            id: 'casa_madeira', nome: '🏠 Casa de Madeira', preco: 15000, categoria: 'propriedades', emoji: '🏠',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+50 gold/dia (renda passiva)', renda_passiva: 50,\n            descricao: 'Casa simples mas confortável'\n        },\n        casa_alvenaria: { \n            id: 'casa_alvenaria', nome: '🏘️ Casa de Alvenaria', preco: 50000, categoria: 'propriedades', emoji: '🏘️',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+150 gold/dia (renda passiva)', renda_passiva: 150,\n            descricao: 'Casa resistente e espaçosa'\n        },\n        apartamento: { \n            id: 'apartamento', nome: '🏢 Apartamento', preco: 80000, categoria: 'propriedades', emoji: '🏢',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+200 gold/dia (renda passiva)', renda_passiva: 200,\n            descricao: 'Apartamento moderno na cidade'\n        },\n        mansao: { \n            id: 'mansao', nome: '🏰 Mansão', preco: 300000, categoria: 'propriedades', emoji: '🏰',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+500 gold/dia (renda passiva)', renda_passiva: 500,\n            descricao: 'Casa de luxo para os ricos'\n        },\n        fazenda: { \n            id: 'fazenda', nome: '🚜 Fazenda', preco: 150000, categoria: 'propriedades', emoji: '🚜',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+300 gold/dia (agricultura)', renda_passiva: 300,\n            descricao: 'Propriedade rural produtiva'\n        },\n        hotel: { \n            id: 'hotel', nome: '🏨 Hotel', preco: 500000, categoria: 'propriedades', emoji: '🏨',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+800 gold/dia (turismo)', renda_passiva: 800,\n            descricao: 'Negócio de hospedagem lucrativo'\n        },\n        shopping: { \n            id: 'shopping', nome: '🏬 Shopping Center', preco: 1000000, categoria: 'propriedades', emoji: '🏬',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: '+1500 gold/dia (comércio)', renda_passiva: 1500,\n            descricao: 'Centro comercial gigantesco'\n        },\n        ilha_privada: { \n            id: 'ilha_privada', nome: '🏝️ Ilha Privada', preco: 5000000, categoria: 'propriedades', emoji: '🏝️',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+3000 gold/dia (paraíso)', renda_passiva: 3000,\n            descricao: 'Seu próprio paraíso particular'\n        },\n        cidade: { \n            id: 'cidade', nome: '🌆 Cidade Inteira', preco: 20000000, categoria: 'propriedades', emoji: '🌆',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+10000 gold/dia (prefeito)', renda_passiva: 10000,\n            descricao: 'Você é o dono de uma cidade!'\n        },\n        castelo: { \n            id: 'castelo', nome: '🏯 Castelo Medieval', preco: 2000000, categoria: 'propriedades', emoji: '🏯',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+1200 gold/dia (realeza)', renda_passiva: 1200,\n            descricao: 'Castelo histórico majestoso'\n        },\n        bunker: { \n            id: 'bunker', nome: '🏢 Bunker Nuclear', preco: 3000000, categoria: 'propriedades', emoji: '🏢',\n            durabilidade: 8000, durabilidade_max: 8000, beneficio: 'Proteção total contra ataques', protecao: 100,\n            descricao: 'Abrigo à prova de tudo'\n        },\n        predio: { \n            id: 'predio', nome: '🏗️ Prédio Comercial', preco: 800000, categoria: 'propriedades', emoji: '🏗️',\n            durabilidade: 2500, durabilidade_max: 2500, beneficio: '+1000 gold/dia (aluguel)', renda_passiva: 1000,\n            descricao: 'Prédio para alugar escritórios'\n        },\n        universidade: { \n            id: 'universidade', nome: '🎓 Universidade Própria', preco: 10000000, categoria: 'propriedades', emoji: '🎓',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+5000 gold/dia (educação)', renda_passiva: 5000,\n            descricao: 'Sua própria instituição de ensino'\n        },\n        porto: { \n            id: 'porto', nome: '⚓ Porto Marítimo', preco: 8000000, categoria: 'propriedades', emoji: '⚓',\n            durabilidade: 6000, durabilidade_max: 6000, beneficio: '+4000 gold/dia (comércio)', renda_passiva: 4000,\n            descricao: 'Porto para navios cargueiros'\n        }\n    },\n\n    // CATEGORIA 2: ANIMAIS (15 itens)\n    animais: {\n        galinha: { \n            id: 'galinha', nome: '🐔 Galinha', preco: 200, categoria: 'animais', emoji: '🐔',\n            durabilidade: 60, durabilidade_max: 60, beneficio: '+30 gold/dia (ovos)', renda_passiva: 30,\n            descricao: 'Produz ovos diariamente'\n        },\n        vaca: { \n            id: 'vaca', nome: '🐄 Vaca', preco: 3000, categoria: 'animais', emoji: '🐄',\n            durabilidade: 120, durabilidade_max: 120, beneficio: '+100 gold/dia (leite)', renda_passiva: 100,\n            descricao: 'Produz leite fresco'\n        },\n        porco: { \n            id: 'porco', nome: '🐷 Porco', preco: 1500, categoria: 'animais', emoji: '🐷',\n            durabilidade: 80, durabilidade_max: 80, beneficio: '+80 gold/dia (carne)', renda_passiva: 80,\n            descricao: 'Criação para consumo'\n        },\n        cavalo: { \n            id: 'cavalo', nome: '🐴 Cavalo', preco: 8000, categoria: 'animais', emoji: '🐴',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+25% velocidade trabalhos', bonus_velocidade: 25,\n            descricao: 'Animal de transporte nobre'\n        },\n        cachorro: { \n            id: 'cachorro', nome: '🐕 Cachorro', preco: 1000, categoria: 'animais', emoji: '🐕',\n            durabilidade: 150, durabilidade_max: 150, beneficio: '+30% proteção assaltos', bonus_defesa: 30,\n            descricao: 'Fiel guardião da família'\n        },\n        gato: { \n            id: 'gato', nome: '🐱 Gato', preco: 500, categoria: 'animais', emoji: '🐱',\n            durabilidade: 120, durabilidade_max: 120, beneficio: '+10 gold/dia (companionship)', renda_passiva: 10,\n            descricao: 'Pet carinhoso e independente'\n        },\n        ovelha: { \n            id: 'ovelha', nome: '🐑 Ovelha', preco: 2000, categoria: 'animais', emoji: '🐑',\n            durabilidade: 100, durabilidade_max: 100, beneficio: '+70 gold/dia (lã)', renda_passiva: 70,\n            descricao: 'Produz lã de qualidade'\n        },\n        tigre: { \n            id: 'tigre', nome: '🐅 Tigre', preco: 50000, categoria: 'animais', emoji: '🐅',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+50% proteção + intimidação', bonus_defesa: 50,\n            descricao: 'Predador exótico impressionante'\n        },\n        leao: { \n            id: 'leao', nome: '🦁 Leão', preco: 80000, categoria: 'animais', emoji: '🦁',\n            durabilidade: 350, durabilidade_max: 350, beneficio: '+60% proteção + status', bonus_defesa: 60,\n            descricao: 'Rei da selva como pet'\n        },\n        elefante: { \n            id: 'elefante', nome: '🐘 Elefante', preco: 150000, categoria: 'animais', emoji: '🐘',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+40% ganhos trabalho pesado', bonus_trabalho: 40,\n            descricao: 'Gigante gentil e trabalhador'\n        },\n        dragao: { \n            id: 'dragao', nome: '🐲 Dragão', preco: 1000000, categoria: 'animais', emoji: '🐲',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+100% proteção + voo', bonus_defesa: 100,\n            descricao: 'Criatura mítica lendária'\n        },\n        unicornio: { \n            id: 'unicornio', nome: '🦄 Unicórnio', preco: 800000, categoria: 'animais', emoji: '🦄',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+500 gold/dia (magia)', renda_passiva: 500,\n            descricao: 'Ser mágico que traz sorte'\n        },\n        aguia: { \n            id: 'aguia', nome: '🦅 Águia', preco: 10000, categoria: 'animais', emoji: '🦅',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+20% chance crítica trabalhos', bonus_critico: 20,\n            descricao: 'Ave de rapina majestosa'\n        },\n        lobo: { \n            id: 'lobo', nome: '🐺 Lobo', preco: 25000, categoria: 'animais', emoji: '🐺',\n            durabilidade: 250, durabilidade_max: 250, beneficio: '+40% proteção noturna', bonus_defesa: 40,\n            descricao: 'Predador feroz e leal'\n        },\n        tubarao: { \n            id: 'tubarao', nome: '🦈 Tubarão', preco: 100000, categoria: 'animais', emoji: '🦈',\n            durabilidade: 400, durabilidade_max: 400, beneficio: '+200% ganhos pesca', bonus_pesca: 200,\n            descricao: 'Predador aquático temível'\n        }\n    },\n\n    // CATEGORIA 3: FERRAMENTAS (20 itens)\n    ferramentas: {\n        // Pesca\n        vara_bambu: { \n            id: 'vara_bambu', nome: '🎋 Vara de Bambu', preco: 100, categoria: 'ferramentas', emoji: '🎋',\n            durabilidade: 30, durabilidade_max: 30, beneficio: 'Pesca básica (+20% sucesso)', bonus_pesca: 20,\n            descricao: 'Vara simples para iniciantes'\n        },\n        vara_carbono: { \n            id: 'vara_carbono', nome: '🎣 Vara de Carbono', preco: 2000, categoria: 'ferramentas', emoji: '🎣',\n            durabilidade: 150, durabilidade_max: 150, beneficio: 'Pesca avançada (+60% sucesso)', bonus_pesca: 60,\n            descricao: 'Vara profissional de alta qualidade'\n        },\n        rede_pesca: { \n            id: 'rede_pesca', nome: '🕸️ Rede de Pesca', preco: 5000, categoria: 'ferramentas', emoji: '🕸️',\n            durabilidade: 100, durabilidade_max: 100, beneficio: 'Pesca em massa (+100% ganhos)', bonus_pesca: 100,\n            descricao: 'Captura múltiplos peixes'\n        },\n        \n        // Mineração\n        picareta_ferro: { \n            id: 'picareta_ferro', nome: '⛏️ Picareta de Ferro', preco: 500, categoria: 'ferramentas', emoji: '⛏️',\n            durabilidade: 50, durabilidade_max: 50, beneficio: 'Mineração básica (+30% sucesso)', bonus_mineracao: 30,\n            descricao: 'Ferramenta padrão de mineração'\n        },\n        picareta_diamante: { \n            id: 'picareta_diamante', nome: '💎 Picareta de Diamante', preco: 10000, categoria: 'ferramentas', emoji: '💎',\n            durabilidade: 200, durabilidade_max: 200, beneficio: 'Mineração avançada (+80% sucesso)', bonus_mineracao: 80,\n            descricao: 'A melhor picareta disponível'\n        },\n        britadeira: { \n            id: 'britadeira', nome: '🔨 Britadeira Industrial', preco: 50000, categoria: 'ferramentas', emoji: '🔨',\n            durabilidade: 300, durabilidade_max: 300, beneficio: 'Mineração industrial (+150% ganhos)', bonus_mineracao: 150,\n            descricao: 'Máquina pesada para grandes extrações'\n        },\n        \n        // Caça\n        rifle_caca: { \n            id: 'rifle_caca', nome: '🔫 Rifle de Caça', preco: 3000, categoria: 'ferramentas', emoji: '🔫',\n            durabilidade: 80, durabilidade_max: 80, beneficio: 'Caça básica (+40% sucesso)', bonus_caca: 40,\n            descricao: 'Arma padrão para caça'\n        },\n        espingarda: { \n            id: 'espingarda', nome: '💥 Espingarda 12', preco: 8000, categoria: 'ferramentas', emoji: '💥',\n            durabilidade: 120, durabilidade_max: 120, beneficio: 'Caça avançada (+70% sucesso)', bonus_caca: 70,\n            descricao: 'Arma poderosa para grandes presas'\n        },\n        rifle_sniper: { \n            id: 'rifle_sniper', nome: '🎯 Rifle Sniper', preco: 25000, categoria: 'ferramentas', emoji: '🎯',\n            durabilidade: 200, durabilidade_max: 200, beneficio: 'Caça de precisão (+120% sucesso)', bonus_caca: 120,\n            descricao: 'Precisão milimétrica para alvos distantes'\n        },\n        \n        // Agricultura\n        enxada: { \n            id: 'enxada', nome: '🪓 Enxada Básica', preco: 200, categoria: 'ferramentas', emoji: '🪓',\n            durabilidade: 40, durabilidade_max: 40, beneficio: 'Plantio básico (+25% produção)', bonus_agricultura: 25,\n            descricao: 'Ferramenta essencial para agricultura'\n        },\n        trator: { \n            id: 'trator', nome: '🚜 Trator Agrícola', preco: 80000, categoria: 'ferramentas', emoji: '🚜',\n            durabilidade: 500, durabilidade_max: 500, beneficio: 'Agricultura industrial (+200% produção)', bonus_agricultura: 200,\n            descricao: 'Máquina para grandes plantações'\n        },\n        drone_agricola: { \n            id: 'drone_agricola', nome: '🛸 Drone Agrícola', preco: 150000, categoria: 'ferramentas', emoji: '🛸',\n            durabilidade: 300, durabilidade_max: 300, beneficio: 'Agricultura de precisão (+300% produção)', bonus_agricultura: 300,\n            descricao: 'Tecnologia avançada para fazendas'\n        },\n        \n        // Proteção\n        colete_kevlar: { \n            id: 'colete_kevlar', nome: '🦺 Colete à Prova de Balas', preco: 15000, categoria: 'ferramentas', emoji: '🦺',\n            durabilidade: 100, durabilidade_max: 100, beneficio: '+60% proteção contra ataques', bonus_defesa: 60,\n            descricao: 'Proteção corporal avançada'\n        },\n        capacete_seguranca: { \n            id: 'capacete_seguranca', nome: '⛑️ Capacete de Segurança', preco: 800, categoria: 'ferramentas', emoji: '⛑️',\n            durabilidade: 60, durabilidade_max: 60, beneficio: '+30% proteção acidentes trabalho', bonus_defesa: 30,\n            descricao: 'Proteção para trabalhos perigosos'\n        },\n        \n        // Medicina\n        kit_medico: { \n            id: 'kit_medico', nome: '🏥 Kit Médico Avançado', preco: 5000, categoria: 'ferramentas', emoji: '🏥',\n            durabilidade: 20, durabilidade_max: 20, beneficio: 'Cura 100% da vida', cura: 100,\n            descricao: 'Kit completo para emergências médicas'\n        },\n        desfibrilador: { \n            id: 'desfibrilador', nome: '⚡ Desfibrilador', preco: 30000, categoria: 'ferramentas', emoji: '⚡',\n            durabilidade: 50, durabilidade_max: 50, beneficio: 'Revive automaticamente após morte', revive: true,\n            descricao: 'Equipamento que pode salvar vidas'\n        },\n        \n        // Diversos\n        lupa_detetive: { \n            id: 'lupa_detetive', nome: '🔍 Lupa de Detetive', preco: 2000, categoria: 'ferramentas', emoji: '🔍',\n            durabilidade: 100, durabilidade_max: 100, beneficio: '+50% chance encontrar itens raros', bonus_sorte: 50,\n            descricao: 'Aumenta chances de descobertas'\n        },\n        ima_poderoso: { \n            id: 'ima_poderoso', nome: '🧲 Ímã Poderoso', preco: 8000, categoria: 'ferramentas', emoji: '🧲',\n            durabilidade: 80, durabilidade_max: 80, beneficio: 'Atrai metais preciosos (+100% mineração)', bonus_mineracao: 100,\n            descricao: 'Atrai metais valiosos automaticamente'\n        },\n        detector_metais: { \n            id: 'detector_metais', nome: '📡 Detector de Metais', preco: 12000, categoria: 'ferramentas', emoji: '📡',\n            durabilidade: 150, durabilidade_max: 150, beneficio: '+80% chance tesouros enterrados', bonus_sorte: 80,\n            descricao: 'Encontra tesouros escondidos'\n        }\n    },\n\n    // CATEGORIA 4: VEÍCULOS (20 itens)\n    veiculos: {\n        bicicleta: { \n            id: 'bicicleta', nome: '🚲 Bicicleta', preco: 800, categoria: 'veiculos', emoji: '🚲',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+15% velocidade trabalhos', bonus_velocidade: 15,\n            descricao: 'Transporte ecológico e saudável'\n        },\n        motocicleta: { \n            id: 'motocicleta', nome: '🏍️ Motocicleta', preco: 15000, categoria: 'veiculos', emoji: '🏍️',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+30% velocidade trabalhos', bonus_velocidade: 30,\n            descricao: 'Moto ágil para a cidade'\n        },\n        carro_popular: { \n            id: 'carro_popular', nome: '🚗 Carro Popular', preco: 40000, categoria: 'veiculos', emoji: '🚗',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+25% ganhos trabalho', bonus_trabalho: 25,\n            descricao: 'Carro básico confiável'\n        },\n        carro_luxo: { \n            id: 'carro_luxo', nome: '🏎️ Carro de Luxo', preco: 200000, categoria: 'veiculos', emoji: '🏎️',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+60% ganhos trabalho + status', bonus_trabalho: 60,\n            descricao: 'Veículo de alto padrão'\n        },\n        ferrari: { \n            id: 'ferrari', nome: '🏁 Ferrari', preco: 1000000, categoria: 'veiculos', emoji: '🏁',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+100% ganhos + máximo status', bonus_trabalho: 100,\n            descricao: 'Supercarro dos sonhos'\n        },\n        lamborghini: { \n            id: 'lamborghini', nome: '🚗 Lamborghini', preco: 1500000, categoria: 'veiculos', emoji: '🚗',\n            durabilidade: 1200, durabilidade_max: 1200, beneficio: '+120% ganhos + exclusividade', bonus_trabalho: 120,\n            descricao: 'Supercarro exclusivo italiano'\n        },\n        caminhao: { \n            id: 'caminhao', nome: '🚛 Caminhão', preco: 120000, categoria: 'veiculos', emoji: '🚛',\n            durabilidade: 600, durabilidade_max: 600, beneficio: '+80% ganhos trabalho pesado', bonus_trabalho: 80,\n            descricao: 'Veículo para cargas pesadas'\n        },\n        onibus: { \n            id: 'onibus', nome: '🚌 Ônibus', preco: 200000, categoria: 'veiculos', emoji: '🚌',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+300 gold/dia (transporte público)', renda_passiva: 300,\n            descricao: 'Negócio de transporte urbano'\n        },\n        barco: { \n            id: 'barco', nome: '🚤 Lancha', preco: 80000, categoria: 'veiculos', emoji: '🚤',\n            durabilidade: 400, durabilidade_max: 400, beneficio: '+150% ganhos pesca aquática', bonus_pesca: 150,\n            descricao: 'Embarcação para pesca em alto mar'\n        },\n        iate: { \n            id: 'iate', nome: '🛥️ Iate de Luxo', preco: 2000000, categoria: 'veiculos', emoji: '🛥️',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+800 gold/dia (turismo de luxo)', renda_passiva: 800,\n            descricao: 'Embarcação de luxo para os ricos'\n        },\n        jato_particular: { \n            id: 'jato_particular', nome: '✈️ Jato Particular', preco: 10000000, categoria: 'veiculos', emoji: '✈️',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+200% ganhos trabalho internacional', bonus_trabalho: 200,\n            descricao: 'Avião privado para negócios globais'\n        },\n        helicoptero: { \n            id: 'helicoptero', nome: '🚁 Helicóptero', preco: 5000000, categoria: 'veiculos', emoji: '🚁',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+1500 gold/dia (táxi aéreo)', renda_passiva: 1500,\n            descricao: 'Transporte aéreo executivo'\n        },\n        navio_carga: { \n            id: 'navio_carga', nome: '🚢 Navio Cargueiro', preco: 15000000, categoria: 'veiculos', emoji: '🚢',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: '+5000 gold/dia (comércio marítimo)', renda_passiva: 5000,\n            descricao: 'Embarcação para comércio internacional'\n        },\n        submarino: { \n            id: 'submarino', nome: '🛸 Submarino', preco: 8000000, categoria: 'veiculos', emoji: '🛸',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+500% ganhos pesca submarina', bonus_pesca: 500,\n            descricao: 'Exploração dos oceanos profundos'\n        },\n        trem: { \n            id: 'trem', nome: '🚂 Locomotiva', preco: 3000000, categoria: 'veiculos', emoji: '🚂',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+1000 gold/dia (transporte ferroviário)', renda_passiva: 1000,\n            descricao: 'Transporte ferroviário de massa'\n        },\n        foguete: { \n            id: 'foguete', nome: '🚀 Foguete Espacial', preco: 50000000, categoria: 'veiculos', emoji: '🚀',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+10000 gold/dia (turismo espacial)', renda_passiva: 10000,\n            descricao: 'Viagens ao espaço sideral'\n        },\n        ovni: { \n            id: 'ovni', nome: '🛸 OVNI', preco: 100000000, categoria: 'veiculos', emoji: '🛸',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+20000 gold/dia (tecnologia alienígena)', renda_passiva: 20000,\n            descricao: 'Tecnologia extraterrestre avançada'\n        },\n        jetpack: { \n            id: 'jetpack', nome: '🎒 Jetpack', preco: 500000, categoria: 'veiculos', emoji: '🎒',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+100% velocidade + voo pessoal', bonus_velocidade: 100,\n            descricao: 'Mochila voadora futurística'\n        },\n        hover_board: { \n            id: 'hover_board', nome: '🛹 Hoverboard', preco: 50000, categoria: 'veiculos', emoji: '🛹',\n            durabilidade: 150, durabilidade_max: 150, beneficio: '+40% velocidade + estilo', bonus_velocidade: 40,\n            descricao: 'Skate voador tecnológico'\n        },\n        robo_transformers: { \n            id: 'robo_transformers', nome: '🤖 Robô Transformers', preco: 20000000, categoria: 'veiculos', emoji: '🤖',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: 'Todos os bônus de veículos', bonus_universal: 50,\n            descricao: 'Robô que se transforma em qualquer veículo'\n        }\n    },\n\n    // CATEGORIA 5: NEGÓCIOS (15 itens)\n    negocios: {\n        barraquinha: { \n            id: 'barraquinha', nome: '🏪 Barraquinha', preco: 5000, categoria: 'negocios', emoji: '🏪',\n            durabilidade: 100, durabilidade_max: 100, beneficio: '+150 gold/dia', renda_passiva: 150,\n            descricao: 'Pequeno comércio de rua'\n        },\n        lanchonete: { \n            id: 'lanchonete', nome: '🍔 Lanchonete', preco: 25000, categoria: 'negocios', emoji: '🍔',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+400 gold/dia', renda_passiva: 400,\n            descricao: 'Negócio de fast food'\n        },\n        restaurante: { \n            id: 'restaurante', nome: '🍽️ Restaurante', preco: 100000, categoria: 'negocios', emoji: '🍽️',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+800 gold/dia', renda_passiva: 800,\n            descricao: 'Estabelecimento gastronômico refinado'\n        },\n        academia: { \n            id: 'academia', nome: '💪 Academia', preco: 80000, categoria: 'negocios', emoji: '💪',\n            durabilidade: 600, durabilidade_max: 600, beneficio: '+600 gold/dia', renda_passiva: 600,\n            descricao: 'Centro de fitness e musculação'\n        },\n        loja_roupas: { \n            id: 'loja_roupas', nome: '👕 Loja de Roupas', preco: 60000, categoria: 'negocios', emoji: '👕',\n            durabilidade: 400, durabilidade_max: 400, beneficio: '+500 gold/dia', renda_passiva: 500,\n            descricao: 'Boutique de moda'\n        },\n        posto_gasolina: { \n            id: 'posto_gasolina', nome: '⛽ Posto de Gasolina', preco: 300000, categoria: 'negocios', emoji: '⛽',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+1200 gold/dia', renda_passiva: 1200,\n            descricao: 'Abastecimento automotivo'\n        },\n        supermercado: { \n            id: 'supermercado', nome: '🏬 Supermercado', preco: 500000, categoria: 'negocios', emoji: '🏬',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+2000 gold/dia', renda_passiva: 2000,\n            descricao: 'Rede de varejo alimentício'\n        },\n        farmacia: { \n            id: 'farmacia', nome: '💊 Farmácia', preco: 200000, categoria: 'negocios', emoji: '💊',\n            durabilidade: 600, durabilidade_max: 600, beneficio: '+900 gold/dia', renda_passiva: 900,\n            descricao: 'Drogaria e produtos de saúde'\n        },\n        banco_proprio: { \n            id: 'banco_proprio', nome: '🏦 Banco Próprio', preco: 10000000, categoria: 'negocios', emoji: '🏦',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+8000 gold/dia', renda_passiva: 8000,\n            descricao: 'Instituição financeira própria'\n        },\n        cassino: { \n            id: 'cassino', nome: '🎰 Cassino', preco: 5000000, categoria: 'negocios', emoji: '🎰',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+4000 gold/dia', renda_passiva: 4000,\n            descricao: 'Casa de jogos e apostas'\n        },\n        empresa_ti: { \n            id: 'empresa_ti', nome: '💻 Empresa de TI', preco: 2000000, categoria: 'negocios', emoji: '💻',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+3000 gold/dia', renda_passiva: 3000,\n            descricao: 'Desenvolvimento de software'\n        },\n        construtora: { \n            id: 'construtora', nome: '🏗️ Construtora', preco: 8000000, categoria: 'negocios', emoji: '🏗️',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: '+6000 gold/dia', renda_passiva: 6000,\n            descricao: 'Empresa de construção civil'\n        },\n        mineradora: { \n            id: 'mineradora', nome: '⛏️ Mineradora', preco: 15000000, categoria: 'negocios', emoji: '⛏️',\n            durabilidade: 4000, durabilidade_max: 4000, beneficio: '+10000 gold/dia', renda_passiva: 10000,\n            descricao: 'Extração industrial de minérios'\n        },\n        petroleira: { \n            id: 'petroleira', nome: '🛢️ Petrolífera', preco: 50000000, categoria: 'negocios', emoji: '🛢️',\n            durabilidade: 8000, durabilidade_max: 8000, beneficio: '+25000 gold/dia', renda_passiva: 25000,\n            descricao: 'Extração e refino de petróleo'\n        },\n        multinacional: { \n            id: 'multinacional', nome: '🌍 Multinacional', preco: 100000000, categoria: 'negocios', emoji: '🌍',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+50000 gold/dia', renda_passiva: 50000,\n            descricao: 'Corporação global dominante'\n        }\n    },\n\n    // CATEGORIA 6: TECNOLOGIA (15 itens)\n    tecnologia: {\n        celular: { \n            id: 'celular', nome: '📱 Smartphone', preco: 1500, categoria: 'tecnologia', emoji: '📱',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+20% ganhos trabalho', bonus_trabalho: 20,\n            descricao: 'Telefone inteligente moderno'\n        },\n        laptop: { \n            id: 'laptop', nome: '💻 Laptop Gamer', preco: 8000, categoria: 'tecnologia', emoji: '💻',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+50% ganhos programação', bonus_programacao: 50,\n            descricao: 'Computador portátil de alta performance'\n        },\n        pc_gamer: { \n            id: 'pc_gamer', nome: '🖥️ PC Gamer', preco: 25000, categoria: 'tecnologia', emoji: '🖥️',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+100% ganhos streaming/programação', bonus_programacao: 100,\n            descricao: 'Computador desktop poderoso'\n        },\n        servidor: { \n            id: 'servidor', nome: '🖥️ Servidor Dedicado', preco: 100000, categoria: 'tecnologia', emoji: '🖥️',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+500 gold/dia (hosting)', renda_passiva: 500,\n            descricao: 'Servidor para negócios online'\n        },\n        tablet: { \n            id: 'tablet', nome: '📱 Tablet Pro', preco: 3000, categoria: 'tecnologia', emoji: '📱',\n            durabilidade: 250, durabilidade_max: 250, beneficio: '+30% ganhos design', bonus_trabalho: 30,\n            descricao: 'Tablet profissional para criação'\n        },\n        camera_profissional: { \n            id: 'camera_profissional', nome: '📷 Câmera Profissional', preco: 15000, categoria: 'tecnologia', emoji: '📷',\n            durabilidade: 400, durabilidade_max: 400, beneficio: '+200% ganhos fotografia/video', bonus_arte: 200,\n            descricao: 'Equipamento para fotografia profissional'\n        },\n        drone_camera: { \n            id: 'drone_camera', nome: '🛸 Drone com Câmera', preco: 12000, categoria: 'tecnologia', emoji: '🛸',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+150% ganhos vídeos aéreos', bonus_arte: 150,\n            descricao: 'Drone para filmagens aéreas'\n        },\n        setup_streaming: { \n            id: 'setup_streaming', nome: '🎬 Setup de Stream', preco: 35000, categoria: 'tecnologia', emoji: '🎬',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+300% ganhos streaming', bonus_streaming: 300,\n            descricao: 'Equipamentos completos para streaming'\n        },\n        estudio_gravacao: { \n            id: 'estudio_gravacao', nome: '🎵 Estúdio de Gravação', preco: 200000, categoria: 'tecnologia', emoji: '🎵',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+1000 gold/dia (música)', renda_passiva: 1000,\n            descricao: 'Estúdio profissional de música'\n        },\n        impressora_3d: { \n            id: 'impressora_3d', nome: '🖨️ Impressora 3D', preco: 25000, categoria: 'tecnologia', emoji: '🖨️',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+400 gold/dia (prototipagem)', renda_passiva: 400,\n            descricao: 'Impressão tridimensional avançada'\n        },\n        vr_headset: { \n            id: 'vr_headset', nome: '🥽 VR Headset', preco: 8000, categoria: 'tecnologia', emoji: '🥽',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+100% ganhos desenvolvimento VR', bonus_programacao: 100,\n            descricao: 'Óculos de realidade virtual'\n        },\n        robo_assistente: { \n            id: 'robo_assistente', nome: '🤖 Robô Assistente', preco: 500000, categoria: 'tecnologia', emoji: '🤖',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+50% eficiência todos trabalhos', bonus_universal: 50,\n            descricao: 'Inteligência artificial pessoal'\n        },\n        hologram_projetor: { \n            id: 'hologram_projetor', nome: '🌟 Projetor de Hologramas', preco: 800000, categoria: 'tecnologia', emoji: '🌟',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+2000 gold/dia (entretenimento)', renda_passiva: 2000,\n            descricao: 'Tecnologia holográfica futurística'\n        },\n        quantum_computer: { \n            id: 'quantum_computer', nome: '⚛️ Computador Quântico', preco: 10000000, categoria: 'tecnologia', emoji: '⚛️',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+10000 gold/dia (pesquisa)', renda_passiva: 10000,\n            descricao: 'Computação quântica revolucionária'\n        },\n        satelite_pessoal: { \n            id: 'satelite_pessoal', nome: '🛰️ Satélite Pessoal', preco: 50000000, categoria: 'tecnologia', emoji: '🛰️',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+20000 gold/dia (telecomunicações)', renda_passiva: 20000,\n            descricao: 'Seu próprio satélite em órbita'\n        }\n    },\n\n    // CATEGORIA 7: DECORAÇÃO (15 itens)\n    decoracao: {\n        quadro_simples: { \n            id: 'quadro_simples', nome: '🖼️ Quadro Simples', preco: 500, categoria: 'decoracao', emoji: '🖼️',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+5% felicidade em casa', bonus_felicidade: 5,\n            descricao: 'Arte básica para decorar paredes'\n        },\n        vaso_plantas: { \n            id: 'vaso_plantas', nome: '🪴 Vaso de Plantas', preco: 200, categoria: 'decoracao', emoji: '🪴',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+3% purificação do ar', bonus_saude: 3,\n            descricao: 'Plantas decorativas que melhoram o ambiente'\n        },\n        tapete_persa: { \n            id: 'tapete_persa', nome: '🪆 Tapete Persa', preco: 5000, categoria: 'decoracao', emoji: '🪆',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+10% conforto residencial', bonus_conforto: 10,\n            descricao: 'Tapete artesanal luxuoso'\n        },\n        lustre_cristal: { \n            id: 'lustre_cristal', nome: '💎 Lustre de Cristal', preco: 25000, categoria: 'decoracao', emoji: '💎',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+20% elegância + iluminação perfeita', bonus_elegancia: 20,\n            descricao: 'Iluminação de alto padrão'\n        },\n        estante_livros: { \n            id: 'estante_livros', nome: '📚 Estante de Livros', preco: 3000, categoria: 'decoracao', emoji: '📚',\n            durabilidade: 600, durabilidade_max: 600, beneficio: '+15% bônus estudo', bonus_estudo: 15,\n            descricao: 'Biblioteca pessoal impressionante'\n        },\n        lareira: { \n            id: 'lareira', nome: '🔥 Lareira', preco: 15000, categoria: 'decoracao', emoji: '🔥',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+25% aconchego + aquecimento', bonus_conforto: 25,\n            descricao: 'Aquecimento aconchegante para casa'\n        },\n        piano_cauda: { \n            id: 'piano_cauda', nome: '🎹 Piano de Cauda', preco: 80000, categoria: 'decoracao', emoji: '🎹',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+100 gold/dia (aulas música)', renda_passiva: 100,\n            descricao: 'Instrumento musical refinado'\n        },\n        aquario_gigante: { \n            id: 'aquario_gigante', nome: '🐠 Aquário Gigante', preco: 12000, categoria: 'decoracao', emoji: '🐠',\n            durabilidade: 400, durabilidade_max: 400, beneficio: '+30% relaxamento + peixes exóticos', bonus_relaxamento: 30,\n            descricao: 'Aquário com peixes tropicais'\n        },\n        escultura_marmore: { \n            id: 'escultura_marmore', nome: '🗿 Escultura de Mármore', preco: 50000, categoria: 'decoracao', emoji: '🗿',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+50% status cultural', bonus_cultura: 50,\n            descricao: 'Arte clássica em mármore'\n        },\n        fonte_agua: { \n            id: 'fonte_agua', nome: '⛲ Fonte de Água', preco: 20000, categoria: 'decoracao', emoji: '⛲',\n            durabilidade: 1200, durabilidade_max: 1200, beneficio: '+40% tranquilidade', bonus_tranquilidade: 40,\n            descricao: 'Fonte ornamental relaxante'\n        },\n        jardim_zen: { \n            id: 'jardim_zen', nome: '🧘 Jardim Zen', preco: 8000, categoria: 'decoracao', emoji: '🧘',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+60% meditação e paz', bonus_meditacao: 60,\n            descricao: 'Espaço para meditação e reflexão'\n        },\n        home_theater: { \n            id: 'home_theater', nome: '📽️ Home Theater', preco: 100000, categoria: 'decoracao', emoji: '📽️',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+200 gold/dia (entretenimento)', renda_passiva: 200,\n            descricao: 'Cinema particular em casa'\n        },\n        mesa_sinuca: { \n            id: 'mesa_sinuca', nome: '🎱 Mesa de Sinuca', preco: 18000, categoria: 'decoracao', emoji: '🎱',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+80 gold/dia (torneios)', renda_passiva: 80,\n            descricao: 'Mesa profissional para jogos'\n        },\n        adega_vinhos: { \n            id: 'adega_vinhos', nome: '🍷 Adega de Vinhos', preco: 60000, categoria: 'decoracao', emoji: '🍷',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+300 gold/dia (degustações)', renda_passiva: 300,\n            descricao: 'Coleção de vinhos premium'\n        },\n        galeria_arte: { \n            id: 'galeria_arte', nome: '🎨 Galeria de Arte', preco: 200000, categoria: 'decoracao', emoji: '🎨',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: '+1000 gold/dia (exposições)', renda_passiva: 1000,\n            descricao: 'Galeria pessoal com obras de arte'\n        }\n    },\n\n    // CATEGORIA 8: SEGURANÇA (15 itens)\n    seguranca: {\n        cameras_simples: { \n            id: 'cameras_simples', nome: '📹 Câmeras Básicas', preco: 2000, categoria: 'seguranca', emoji: '📹',\n            durabilidade: 300, durabilidade_max: 300, beneficio: '+30% proteção contra roubos', bonus_protecao: 30,\n            descricao: 'Sistema básico de vigilância'\n        },\n        alarme_residencial: { \n            id: 'alarme_residencial', nome: '🚨 Alarme Residencial', preco: 5000, categoria: 'seguranca', emoji: '🚨',\n            durabilidade: 500, durabilidade_max: 500, beneficio: '+40% alerta contra invasões', bonus_alerta: 40,\n            descricao: 'Sistema de alarme automático'\n        },\n        fechadura_digital: { \n            id: 'fechadura_digital', nome: '🔐 Fechadura Digital', preco: 3000, categoria: 'seguranca', emoji: '🔐',\n            durabilidade: 800, durabilidade_max: 800, beneficio: '+25% segurança acesso', bonus_acesso: 25,\n            descricao: 'Controle de acesso biométrico'\n        },\n        cerca_eletrica: { \n            id: 'cerca_eletrica', nome: '⚡ Cerca Elétrica', preco: 8000, categoria: 'seguranca', emoji: '⚡',\n            durabilidade: 1000, durabilidade_max: 1000, beneficio: '+60% proteção perímetro', bonus_perimetro: 60,\n            descricao: 'Barreira elétrica de proteção'\n        },\n        seguranca_armada: { \n            id: 'seguranca_armada', nome: '👮 Segurança Armada', preco: 15000, categoria: 'seguranca', emoji: '👮',\n            durabilidade: 200, durabilidade_max: 200, beneficio: '+150 gold/dia + proteção máxima', renda_passiva: -150,\n            descricao: 'Equipe de segurança profissional (custo mensal)'\n        },\n        bunker_seguro: { \n            id: 'bunker_seguro', nome: '🏰 Bunker Seguro', preco: 500000, categoria: 'seguranca', emoji: '🏰',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+95% proteção total', bonus_protecao: 95,\n            descricao: 'Abrigo blindado máxima segurança'\n        },\n        drones_vigilancia: { \n            id: 'drones_vigilancia', nome: '🛸 Drones de Vigilância', preco: 50000, categoria: 'seguranca', emoji: '🛸',\n            durabilidade: 600, durabilidade_max: 600, beneficio: '+80% monitoramento aéreo', bonus_monitoramento: 80,\n            descricao: 'Vigilância aérea automatizada'\n        },\n        radar_movimento: { \n            id: 'radar_movimento', nome: '📡 Radar de Movimento', preco: 25000, categoria: 'seguranca', emoji: '📡',\n            durabilidade: 1200, durabilidade_max: 1200, beneficio: '+70% detecção intrusos', bonus_deteccao: 70,\n            descricao: 'Sistema de detecção avançado'\n        },\n        sistema_biometrico: { \n            id: 'sistema_biometrico', nome: '👁️ Sistema Biométrico', preco: 40000, categoria: 'seguranca', emoji: '👁️',\n            durabilidade: 1500, durabilidade_max: 1500, beneficio: '+85% controle acesso', bonus_biometria: 85,\n            descricao: 'Reconhecimento facial e digital'\n        },\n        blindagem_residencial: { \n            id: 'blindagem_residencial', nome: '🛡️ Blindagem Residencial', preco: 200000, categoria: 'seguranca', emoji: '🛡️',\n            durabilidade: 3000, durabilidade_max: 3000, beneficio: '+90% resistência ataques', bonus_blindagem: 90,\n            descricao: 'Reforço estrutural anti-balas'\n        },\n        sistema_contramedidas: { \n            id: 'sistema_contramedidas', nome: '⚔️ Sistema de Contramedidas', preco: 800000, categoria: 'seguranca', emoji: '⚔️',\n            durabilidade: 2000, durabilidade_max: 2000, beneficio: '+100% defesa ativa', bonus_contramedidas: 100,\n            descricao: 'Defesas automáticas ativas'\n        },\n        seguranca_ai: { \n            id: 'seguranca_ai', nome: '🤖 IA de Segurança', preco: 1000000, categoria: 'seguranca', emoji: '🤖',\n            durabilidade: 5000, durabilidade_max: 5000, beneficio: '+98% predição ameaças', bonus_predicao: 98,\n            descricao: 'Inteligência artificial de proteção'\n        },\n        escudo_eletromagnetico: { \n            id: 'escudo_eletromagnetico', nome: '🌐 Escudo Eletromagnético', preco: 5000000, categoria: 'seguranca', emoji: '🌐',\n            durabilidade: 8000, durabilidade_max: 8000, beneficio: '+99% proteção total', bonus_escudo: 99,\n            descricao: 'Campo de força eletromagnético'\n        },\n        satelite_vigilancia: { \n            id: 'satelite_vigilancia', nome: '🛰️ Satélite de Vigilância', preco: 25000000, categoria: 'seguranca', emoji: '🛰️',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: '+100% vigilância global', bonus_satelite: 100,\n            descricao: 'Monitoramento via satélite'\n        },\n        exercito_particular: { \n            id: 'exercito_particular', nome: '🪖 Exército Particular', preco: 100000000, categoria: 'seguranca', emoji: '🪖',\n            durabilidade: 9999, durabilidade_max: 9999, beneficio: 'Proteção militar total', bonus_militar: 100,\n            descricao: 'Força militar privada completa'\n        }\n    }\n};\n\n// Locais para roubar\nconst locaisRoubo = {\n    casa: { nome: 'Casa Simples', min: 100, max: 500, risco: 20, tempo: 5 },\n    loja: { nome: 'Loja de Conveniência', min: 200, max: 800, risco: 30, tempo: 8 },\n    mercado: { nome: 'Supermercado', min: 500, max: 1500, risco: 40, tempo: 12 },\n    joalheria: { nome: 'Joalheria', min: 1000, max: 3000, risco: 60, tempo: 15 },\n    banco: { nome: 'Agência Bancária', min: 2000, max: 8000, risco: 80, tempo: 20 },\n    mansao: { nome: 'Mansão de Luxo', min: 3000, max: 12000, risco: 70, tempo: 25 },\n    cassino: { nome: 'Cassino', min: 5000, max: 15000, risco: 90, tempo: 30 },\n    shopping: { nome: 'Shopping Center', min: 8000, max: 25000, risco: 85, tempo: 40 },\n    aeroporto: { nome: 'Aeroporto', min: 10000, max: 30000, risco: 95, tempo: 50 },\n    banco_central: { nome: 'Banco Central', min: 20000, max: 100000, risco: 99, tempo: 60 },\n    casa_moeda: { nome: 'Casa da Moeda', min: 50000, max: 200000, risco: 99, tempo: 80 },\n    pentágono: { nome: 'Pentágono', min: 100000, max: 500000, risco: 100, tempo: 120 }\n};\n\n// Tipos de investimentos\nconst investimentos = {\n    poupanca: { nome: 'Poupança', rendimento: 0.5, risco: 0, tempo: 24 },\n    cdb: { nome: 'CDB', rendimento: 8, risco: 5, tempo: 48 },\n    acoes: { nome: 'Ações', rendimento: 15, risco: 30, tempo: 72 },\n    bitcoin: { nome: 'Bitcoin', rendimento: 25, risco: 50, tempo: 96 },\n    forex: { nome: 'Forex', rendimento: 40, risco: 70, tempo: 24 },\n    imoveis: { nome: 'Imóveis', rendimento: 12, risco: 10, tempo: 168 },\n    ouro: { nome: 'Ouro', rendimento: 6, risco: 8, tempo: 120 }\n};\n\n// ==================== FUNÇÕES AUXILIARES ====================\n\n// Carrega dados do RPG\nfunction carregarDadosRPG() {\n    try {\n        if (!fs.existsSync(rpgDataFile)) {\n            const dir = path.dirname(rpgDataFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(rpgDataFile, JSON.stringify({ grupos: {}, jogadores: {} }, null, 2));\n        }\n        const data = fs.readFileSync(rpgDataFile, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error('❌ Erro ao carregar dados RPG:', err);\n        return { grupos: {}, jogadores: {} };\n    }\n}\n\n// Salva dados do RPG\nfunction salvarDadosRPG(data) {\n    try {\n        fs.writeFileSync(rpgDataFile, JSON.stringify(data, null, 2));\n        return true;\n    } catch (err) {\n        console.error('❌ Erro ao salvar dados RPG:', err);\n        return false;\n    }\n}\n\n// Função para garantir estrutura completa do usuário\nfunction garantirEstruturaUsuario(usuario) {\n    return {\n        nome: usuario.nome || 'Jogador',\n        banco: usuario.banco || bancos[0],\n        saldo: usuario.saldo || 0,\n        vida: usuario.vida || 100,\n        vida_max: usuario.vida_max || 100,\n        registrado: usuario.registrado || new Date().toISOString(),\n        inventario: usuario.inventario || {},\n        educacao_nivel: usuario.educacao_nivel || 1,\n        faculdades_completas: usuario.faculdades_completas || [],\n        trabalho_atual: usuario.trabalho_atual || null,\n        // Estatísticas\n        pescasFeitas: usuario.pescasFeitas || 0,\n        mineracoesFeitas: usuario.mineracoesFeitas || 0,\n        trabalhosFeitos: usuario.trabalhosFeitos || 0,\n        cacadasFeitas: usuario.cacadasFeitas || 0,\n        roubosFeitos: usuario.roubosFeitos || 0,\n        investimentosFeitos: usuario.investimentosFeitos || 0,\n        // Cooldowns\n        ultimaPesca: usuario.ultimaPesca || 0,\n        ultimaMineracao: usuario.ultimaMineracao || 0,\n        ultimoTrabalho: usuario.ultimoTrabalho || 0,\n        ultimaCaca: usuario.ultimaCaca || 0,\n        ultimoRoubo: usuario.ultimoRoubo || 0,\n        ultimoEstudo: usuario.ultimoEstudo || 0,\n        ultimoInvestimento: usuario.ultimoInvestimento || 0,\n        ultimoYoutube: usuario.ultimoYoutube || 0,\n        ultimoTiktok: usuario.ultimoTiktok || 0,\n        ultimoTwitch: usuario.ultimoTwitch || 0,\n        // Estados especiais\n        morreu: usuario.morreu || false,\n        preso: usuario.preso || false,\n        tempo_prisao: usuario.tempo_prisao || 0,\n        causa_morte: usuario.causa_morte || null,\n        investimentos_ativos: usuario.investimentos_ativos || {},\n        // Totais\n        totalGanho: usuario.totalGanho || 0,\n        totalGasto: usuario.totalGasto || 0,\n        nivelInfluenciador: usuario.nivelInfluenciador || 1,\n        seguidores: usuario.seguidores || 0\n    };\n}\n\n// Encontra item em qualquer categoria\nfunction encontrarItem(itemId) {\n    for (const categoria of Object.values(loja)) {\n        if (categoria[itemId]) {\n            return categoria[itemId];\n        }\n    }\n    return null;\n}\n\n// Verifica se usuário tem item\nfunction temItem(usuario, itemId) {\n    return usuario.inventario[itemId] && usuario.inventario[itemId].quantidade > 0;\n}\n\n// Usa item (reduz durabilidade)\nfunction usarItem(usuario, itemId) {\n    if (!usuario.inventario[itemId] || usuario.inventario[itemId].quantidade <= 0) {\n        return { erro: 'Item não encontrado no inventário' };\n    }\n\n    const item = encontrarItem(itemId);\n    if (!item) return { erro: 'Item não existe' };\n\n    // Reduz durabilidade\n    usuario.inventario[itemId].durabilidade -= 1;\n    \n    // Remove item se durabilidade chegou a 0\n    if (usuario.inventario[itemId].durabilidade <= 0) {\n        delete usuario.inventario[itemId];\n        return { quebrou: true, item: item };\n    }\n    \n    return { quebrou: false, item: item };\n}\n\n// Adiciona item ao inventário\nfunction adicionarItem(usuario, itemId, quantidade = 1) {\n    const item = encontrarItem(itemId);\n    if (!item) return false;\n\n    if (!usuario.inventario[itemId]) {\n        usuario.inventario[itemId] = {\n            quantidade: 0,\n            durabilidade: item.durabilidade_max\n        };\n    }\n    \n    usuario.inventario[itemId].quantidade += quantidade;\n    return true;\n}\n\n// Verifica cooldown\nfunction verificarCooldown(ultimaVez, cooldownMs) {\n    const agora = Date.now();\n    const tempoRestante = cooldownMs - (agora - ultimaVez);\n    return tempoRestante > 0 ? tempoRestante : 0;\n}\n\n// Formatar tempo\nfunction formatarTempo(ms) {\n    const minutos = Math.ceil(ms / 60000);\n    if (minutos >= 60) {\n        const horas = Math.floor(minutos / 60);\n        const minutosRestantes = minutos % 60;\n        return `${horas}h ${minutosRestantes}min`;\n    }\n    return `${minutos} minutos`;\n}\n\n// ==================== FUNÇÕES PRINCIPAIS ====================\n\n// Verifica se RPG está ativo no grupo\nfunction isRPGAtivo(groupId) {\n    const dados = carregarDadosRPG();\n    return dados.grupos[groupId]?.ativo || false;\n}\n\n// Ativa/desativa RPG no grupo\nfunction toggleRPG(groupId, ativo) {\n    const dados = carregarDadosRPG();\n    if (!dados.grupos[groupId]) {\n        dados.grupos[groupId] = { ativo: false, jogadores: [] };\n    }\n    dados.grupos[groupId].ativo = ativo;\n    return salvarDadosRPG(dados);\n}\n\n// Verifica se usuário está registrado\nfunction isUsuarioRegistrado(userId) {\n    const dados = carregarDadosRPG();\n    return !!dados.jogadores[userId];\n}\n\n// Registra novo usuário\nfunction registrarUsuario(userId, nome, bancoId) {\n    const dados = carregarDadosRPG();\n    const banco = bancos.find(b => b.id === bancoId);\n    if (!banco) return false;\n\n    dados.jogadores[userId] = garantirEstruturaUsuario({\n        nome: nome,\n        banco: banco,\n        saldo: 1000, // Saldo inicial\n        inventario: {\n            // Itens iniciais\n            vara_bambu: { quantidade: 1, durabilidade: 30 },\n            picareta_ferro: { quantidade: 1, durabilidade: 50 },\n            rifle_caca: { quantidade: 1, durabilidade: 80 },\n            enxada: { quantidade: 1, durabilidade: 40 }\n        }\n    });\n\n    return salvarDadosRPG(dados);\n}\n\n// Obtém dados do usuário\nfunction obterDadosUsuario(userId) {\n    const dados = carregarDadosRPG();\n    let usuario = dados.jogadores[userId];\n    if (!usuario) return null;\n    return garantirEstruturaUsuario(usuario);\n}\n\n// ==================== SISTEMA DE PESCA ====================\nasync function pescar(userId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n        if (usuario.preso) return { erro: `Você está preso por mais ${Math.ceil(usuario.tempo_prisao / 60)} minutos!` };\n\n        const cooldown = verificarCooldown(usuario.ultimaPesca, 15 * 60 * 1000); // 15 min\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `🎣 Aguarde **${formatarTempo(cooldown)}** para pescar novamente!` };\n        }\n\n        // Verifica se tem vara\n        const varas = ['vara_bambu', 'vara_carbono', 'rede_pesca'];\n        let varaUsada = null;\n        let bonusPesca = 0;\n\n        for (const vara of varas) {\n            if (temItem(usuario, vara)) {\n                varaUsada = vara;\n                const item = encontrarItem(vara);\n                bonusPesca = item.bonus_pesca || 0;\n                break;\n            }\n        }\n\n        if (!varaUsada) {\n            return { erro: 'Você precisa comprar uma vara de pescar na loja!' };\n        }\n\n        // Usa a vara\n        const resultadoUso = usarItem(usuario, varaUsada);\n        let mensagemQuebra = '';\n        if (resultadoUso.quebrou) {\n            mensagemQuebra = `\\n💥 Sua ${resultadoUso.item.nome} quebrou!`;\n        }\n\n        // Calcula chance de sucesso (50% base + bônus)\n        const chanceBase = 50;\n        const chanceTotal = Math.min(90, chanceBase + bonusPesca);\n        const sucesso = Math.random() * 100 < chanceTotal;\n\n        usuario.ultimaPesca = Date.now();\n        usuario.pescasFeitas++;\n\n        if (!sucesso) {\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n            return { \n                sucesso: false, \n                mensagem: `🎣 **PESCA SEM SUCESSO**\\n\\nOs peixes não morderam a isca!${mensagemQuebra}\\n\\n⏰ Cooldown: 15 minutos` \n            };\n        }\n\n        // Peixes disponíveis\n        const peixes = [\n            { nome: 'Peixe Dourado Lendário', valor: 1000, chance: 5, emoji: '🐠' },\n            { nome: 'Salmão Grande', valor: 500, chance: 15, emoji: '🐟' },\n            { nome: 'Truta Prateada', valor: 300, chance: 25, emoji: '🐟' },\n            { nome: 'Sardinha', valor: 150, chance: 30, emoji: '🐟' },\n            { nome: 'Peixe Comum', valor: 80, chance: 25, emoji: '🐟' }\n        ];\n\n        // Seleciona peixe baseado na chance\n        const sorte = Math.random() * 100;\n        let chanceAcumulada = 0;\n        let peixePescado = null;\n\n        for (const peixe of peixes) {\n            chanceAcumulada += peixe.chance;\n            if (sorte <= chanceAcumulada) {\n                peixePescado = peixe;\n                break;\n            }\n        }\n\n        if (!peixePescado) peixePescado = peixes[peixes.length - 1];\n\n        usuario.saldo += peixePescado.valor;\n        usuario.totalGanho += peixePescado.valor;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return { \n            sucesso: true, \n            peixe: peixePescado,\n            mensagem: `🎣 **PESCA BEM-SUCEDIDA!** ${peixePescado.emoji}\\n\\n${peixePescado.nome} pescado!\\n💰 **Ganhou:** ${peixePescado.valor.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold${mensagemQuebra}\\n\\n⏰ Cooldown: 15 minutos`\n        };\n    });\n}\n\n// ==================== SISTEMA DE MINERAÇÃO ====================\nasync function minerar(userId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n        if (usuario.preso) return { erro: `Você está preso por mais ${Math.ceil(usuario.tempo_prisao / 60)} minutos!` };\n\n        const cooldown = verificarCooldown(usuario.ultimaMineracao, 20 * 60 * 1000); // 20 min\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `⛏️ Aguarde **${formatarTempo(cooldown)}** para minerar novamente!` };\n        }\n\n        // Verifica se tem picareta\n        const picaretas = ['picareta_ferro', 'picareta_diamante', 'britadeira'];\n        let picaretaUsada = null;\n        let bonusMineracao = 0;\n\n        for (const picareta of picaretas) {\n            if (temItem(usuario, picareta)) {\n                picaretaUsada = picareta;\n                const item = encontrarItem(picareta);\n                bonusMineracao = item.bonus_mineracao || 0;\n                break;\n            }\n        }\n\n        if (!picaretaUsada) {\n            return { erro: 'Você precisa comprar uma picareta na loja!' };\n        }\n\n        // Risco de acidente (morte) - 15% base\n        let riscoAcidente = 15;\n        if (temItem(usuario, 'capacete_seguranca')) riscoAcidente -= 10;\n        if (temItem(usuario, 'colete_kevlar')) riscoAcidente -= 5;\n\n        if (Math.random() * 100 < riscoAcidente) {\n            usuario.vida = 0;\n            usuario.morreu = true;\n            usuario.causa_morte = 'Acidente de mineração';\n            usuario.saldo = Math.floor(usuario.saldo * 0.6); // Perde 40%\n\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n\n            return {\n                sucesso: false,\n                mensagem: `💀 **ACIDENTE FATAL NA MINERAÇÃO!**\\n\\nDesabamento na mina!\\n💰 Perdeu 40% do dinheiro (${Math.floor(usuario.saldo * 0.4).toLocaleString()} Gold)\\n⚰️ Use **.reviver** para voltar ao jogo`\n            };\n        }\n\n        // Usa a picareta\n        const resultadoUso = usarItem(usuario, picaretaUsada);\n        let mensagemQuebra = '';\n        if (resultadoUso.quebrou) {\n            mensagemQuebra = `\\n💥 Sua ${resultadoUso.item.nome} quebrou!`;\n        }\n\n        // Calcula sucesso (40% base + bônus)\n        const chanceBase = 40;\n        const chanceTotal = Math.min(85, chanceBase + bonusMineracao);\n        const sucesso = Math.random() * 100 < chanceTotal;\n\n        usuario.ultimaMineracao = Date.now();\n        usuario.mineracoesFeitas++;\n\n        if (!sucesso) {\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n            return { \n                sucesso: false, \n                mensagem: `⛏️ **MINERAÇÃO SEM SUCESSO**\\n\\nApenas pedras sem valor!${mensagemQuebra}\\n\\n⏰ Cooldown: 20 minutos` \n            };\n        }\n\n        // Minérios disponíveis\n        const minerais = [\n            { nome: 'Diamante Puro', valor: 2000, chance: 3, emoji: '💎' },\n            { nome: 'Ouro Bruto', valor: 1200, chance: 8, emoji: '🥇' },\n            { nome: 'Prata', valor: 600, chance: 15, emoji: '🥈' },\n            { nome: 'Ferro', valor: 300, chance: 30, emoji: '⚡' },\n            { nome: 'Carvão', valor: 150, chance: 44, emoji: '⚫' }\n        ];\n\n        const sorte = Math.random() * 100;\n        let chanceAcumulada = 0;\n        let mineralEncontrado = null;\n\n        for (const mineral of minerais) {\n            chanceAcumulada += mineral.chance;\n            if (sorte <= chanceAcumulada) {\n                mineralEncontrado = mineral;\n                break;\n            }\n        }\n\n        if (!mineralEncontrado) mineralEncontrado = minerais[minerais.length - 1];\n\n        usuario.saldo += mineralEncontrado.valor;\n        usuario.totalGanho += mineralEncontrado.valor;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return { \n            sucesso: true, \n            mineral: mineralEncontrado,\n            mensagem: `⛏️ **MINERAÇÃO BEM-SUCEDIDA!** ${mineralEncontrado.emoji}\\n\\n${mineralEncontrado.nome} extraído!\\n💰 **Ganhou:** ${mineralEncontrado.valor.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold${mensagemQuebra}\\n\\n⏰ Cooldown: 20 minutos`\n        };\n    });\n}\n\n// ==================== SISTEMA DE CAÇA ====================\nasync function cacar(userId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n        if (usuario.preso) return { erro: `Você está preso por mais ${Math.ceil(usuario.tempo_prisao / 60)} minutos!` };\n\n        const cooldown = verificarCooldown(usuario.ultimaCaca, 25 * 60 * 1000); // 25 min\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `🔫 Aguarde **${formatarTempo(cooldown)}** para caçar novamente!` };\n        }\n\n        // Verifica se tem arma\n        const armas = ['rifle_caca', 'espingarda', 'rifle_sniper'];\n        let armaUsada = null;\n        let bonusCaca = 0;\n\n        for (const arma of armas) {\n            if (temItem(usuario, arma)) {\n                armaUsada = arma;\n                const item = encontrarItem(arma);\n                bonusCaca = item.bonus_caca || 0;\n                break;\n            }\n        }\n\n        if (!armaUsada) {\n            return { erro: 'Você precisa comprar uma arma de caça na loja!' };\n        }\n\n        // Usa a arma\n        const resultadoUso = usarItem(usuario, armaUsada);\n        let mensagemQuebra = '';\n        if (resultadoUso.quebrou) {\n            mensagemQuebra = `\\n💥 Sua ${resultadoUso.item.nome} quebrou!`;\n        }\n\n        // Animais disponíveis com diferentes riscos\n        const animais = [\n            { nome: 'Coelho', valor: 120, chance: 35, perigo: 0, emoji: '🐰' },\n            { nome: 'Veado', valor: 350, chance: 30, perigo: 5, emoji: '🦌' },\n            { nome: 'Javali', valor: 600, chance: 20, perigo: 25, emoji: '🐗' },\n            { nome: 'Urso', valor: 1200, chance: 10, perigo: 60, emoji: '🐻' },\n            { nome: 'Leão da Montanha', valor: 2000, chance: 5, perigo: 80, emoji: '🦁' }\n        ];\n\n        const sorte = Math.random() * 100;\n        let chanceAcumulada = 0;\n        let animalEncontrado = null;\n\n        for (const animal of animais) {\n            chanceAcumulada += animal.chance;\n            if (sorte <= chanceAcumulada) {\n                animalEncontrado = animal;\n                break;\n            }\n        }\n\n        if (!animalEncontrado) animalEncontrado = animais[0];\n\n        // Verifica se consegue abater\n        const chanceAbate = Math.max(30, 70 + bonusCaca - animalEncontrado.perigo);\n        const abateu = Math.random() * 100 < chanceAbate;\n\n        // Se não abateu e o animal é perigoso, pode atacar\n        if (!abateu && animalEncontrado.perigo > 0) {\n            const chanceAtaque = animalEncontrado.perigo;\n            if (Math.random() * 100 < chanceAtaque) {\n                let protecao = 0;\n                if (temItem(usuario, 'colete_kevlar')) protecao += 60;\n                if (temItem(usuario, 'capacete_seguranca')) protecao += 30;\n\n                const danoRecebido = Math.floor(animalEncontrado.perigo * (1 - protecao / 100));\n                usuario.vida -= danoRecebido;\n\n                if (usuario.vida <= 0) {\n                    usuario.vida = 0;\n                    usuario.morreu = true;\n                    usuario.causa_morte = `Atacado por ${animalEncontrado.nome}`;\n                    usuario.saldo = Math.floor(usuario.saldo * 0.7);\n\n                    dados.jogadores[userId] = usuario;\n                    salvarDadosRPG(dados);\n\n                    return {\n                        sucesso: false,\n                        mensagem: `💀 **MORTO POR ${animalEncontrado.nome.toUpperCase()}!** ${animalEncontrado.emoji}\\n\\nO animal te atacou fatalmente!\\n💰 Perdeu 30% do dinheiro\\n⚰️ Use **.reviver** para voltar`\n                    };\n                }\n\n                dados.jogadores[userId] = usuario;\n                salvarDadosRPG(dados);\n\n                return {\n                    sucesso: false,\n                    mensagem: `🩸 **ATACADO!** ${animalEncontrado.emoji}\\n\\n${animalEncontrado.nome} te feriu!\\n❤️ **Vida:** ${usuario.vida}/${usuario.vida_max}\\n💡 Use kit médico para se curar!${mensagemQuebra}`\n                };\n            }\n        }\n\n        usuario.ultimaCaca = Date.now();\n        usuario.cacadasFeitas++;\n\n        if (!abateu) {\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n            return { \n                sucesso: false, \n                mensagem: `🔫 **CAÇA FRACASSOU**\\n\\nVocê errou o tiro!${mensagemQuebra}\\n\\n⏰ Cooldown: 25 minutos` \n            };\n        }\n\n        usuario.saldo += animalEncontrado.valor;\n        usuario.totalGanho += animalEncontrado.valor;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return { \n            sucesso: true, \n            animal: animalEncontrado,\n            mensagem: `🔫 **CAÇA BEM-SUCEDIDA!** ${animalEncontrado.emoji}\\n\\n${animalEncontrado.nome} abatido!\\n💰 **Ganhou:** ${animalEncontrado.valor.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold${mensagemQuebra}\\n\\n⏰ Cooldown: 25 minutos`\n        };\n    });\n}\n\n// ==================== SISTEMA DE TRABALHO ====================\nasync function trabalhar(userId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n        if (usuario.preso) return { erro: `Você está preso por mais ${Math.ceil(usuario.tempo_prisao / 60)} minutos!` };\n\n        const cooldown = verificarCooldown(usuario.ultimoTrabalho, 30 * 60 * 1000); // 30 min\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `💼 Aguarde **${formatarTempo(cooldown)}** para trabalhar novamente!` };\n        }\n\n        // Calcula salário base pela educação\n        const nivelEducacao = usuario.educacao_nivel || 1;\n        const salarioBase = educacao[nivelEducacao]?.salarioMin || 50;\n        let salarioFinal = salarioBase + Math.floor(Math.random() * salarioBase);\n\n        // Bônus por itens\n        let bonusTotal = 0;\n        let itensUsados = [];\n\n        // Veículos\n        if (temItem(usuario, 'ferrari')) { bonusTotal += 100; itensUsados.push('Ferrari'); }\n        else if (temItem(usuario, 'lamborghini')) { bonusTotal += 120; itensUsados.push('Lamborghini'); }\n        else if (temItem(usuario, 'carro_luxo')) { bonusTotal += 60; itensUsados.push('Carro de Luxo'); }\n        else if (temItem(usuario, 'carro_popular')) { bonusTotal += 25; itensUsados.push('Carro Popular'); }\n        else if (temItem(usuario, 'motocicleta')) { bonusTotal += 30; itensUsados.push('Motocicleta'); }\n        else if (temItem(usuario, 'bicicleta')) { bonusTotal += 15; itensUsados.push('Bicicleta'); }\n\n        // Tecnologia\n        if (temItem(usuario, 'laptop')) { bonusTotal += 50; itensUsados.push('Laptop'); }\n        if (temItem(usuario, 'celular')) { bonusTotal += 20; itensUsados.push('Smartphone'); }\n\n        // Faculdades completas\n        let bonusFaculdade = 0;\n        if (usuario.faculdades_completas && usuario.faculdades_completas.length > 0) {\n            const melhorFaculdade = usuario.faculdades_completas.reduce((melhor, faculdadeId) => {\n                const faculdade = faculdades[faculdadeId];\n                return (faculdade && faculdade.salario > melhor) ? faculdade.salario : melhor;\n            }, 0);\n            bonusFaculdade = melhorFaculdade;\n        }\n\n        salarioFinal = Math.floor(salarioFinal * (1 + bonusTotal / 100)) + bonusFaculdade;\n\n        usuario.saldo += salarioFinal;\n        usuario.totalGanho += salarioFinal;\n        usuario.ultimoTrabalho = Date.now();\n        usuario.trabalhosFeitos++;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        let trabalhoDescricao = '';\n        if (bonusFaculdade > 0) {\n            trabalhoDescricao = `Trabalho especializado (formação superior)`;\n        } else if (nivelEducacao >= 4) {\n            trabalhoDescricao = `Trabalho de nível superior`;\n        } else if (nivelEducacao >= 3) {\n            trabalhoDescricao = `Trabalho técnico`;\n        } else {\n            trabalhoDescricao = `Trabalho básico`;\n        }\n\n        return { \n            sucesso: true,\n            mensagem: `💼 **TRABALHO CONCLUÍDO!**\\n\\n📋 **Tipo:** ${trabalhoDescricao}\\n💰 **Salário:** ${salarioFinal.toLocaleString()} Gold\\n📊 **Bônus:** +${bonusTotal}%\\n🎓 **Nível Educação:** ${nivelEducacao}\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n⏰ Cooldown: 30 minutos`\n        };\n    });\n}\n\n// ==================== SISTEMA DE ROUBO ====================\nasync function roubar(userId, local) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n        if (usuario.preso) return { erro: `Você está preso por mais ${Math.ceil(usuario.tempo_prisao / 60)} minutos!` };\n\n        const cooldown = verificarCooldown(usuario.ultimoRoubo, 60 * 60 * 1000); // 1 hora\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `🏴‍☠️ Aguarde **${formatarTempo(cooldown)}** para roubar novamente!` };\n        }\n\n        if (!local) {\n            let lista = '🏴‍☠️ **LOCAIS PARA ROUBAR**\\n\\n';\n            Object.entries(locaisRoubo).forEach(([id, dados]) => {\n                lista += `🎯 **${dados.nome}**\\n`;\n                lista += `   💰 ${dados.min.toLocaleString()} - ${dados.max.toLocaleString()} Gold\\n`;\n                lista += `   ⚠️ Risco: ${dados.risco}%\\n`;\n                lista += `   ⏱️ Tempo: ${dados.tempo} min\\n\\n`;\n            });\n            lista += '💡 **Use:** `.roubar [local]`';\n            return { mensagem: lista };\n        }\n\n        const localRoubo = locaisRoubo[local.toLowerCase()];\n        if (!localRoubo) {\n            return { erro: 'Local inválido! Use .roubar para ver os locais disponíveis.' };\n        }\n\n        // Redução de risco por itens\n        let riscoFinal = localRoubo.risco;\n        if (temItem(usuario, 'colete_kevlar')) riscoFinal -= 20;\n        if (temItem(usuario, 'carro_luxo') || temItem(usuario, 'ferrari')) riscoFinal -= 10;\n\n        riscoFinal = Math.max(5, riscoFinal); // Mínimo 5% de risco\n\n        // Verifica se foi pego\n        if (Math.random() * 100 < riscoFinal) {\n            // Foi preso\n            usuario.preso = true;\n            usuario.tempo_prisao = localRoubo.tempo * 60 * 1000; // Converte para ms\n            usuario.ultimoRoubo = Date.now();\n\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n\n            return {\n                sucesso: false,\n                mensagem: `🚨 **PRESO EM FLAGRANTE!**\\n\\n👮‍♂️ Você foi pego tentando roubar **${localRoubo.nome}**!\\n⛓️ **Tempo de prisão:** ${localRoubo.tempo} minutos\\n📱 Pode usar outros comandos após sair da prisão`\n            };\n        }\n\n        // Roubo bem-sucedido\n        const valorRoubado = Math.floor(Math.random() * (localRoubo.max - localRoubo.min + 1)) + localRoubo.min;\n        \n        usuario.saldo += valorRoubado;\n        usuario.totalGanho += valorRoubado;\n        usuario.ultimoRoubo = Date.now();\n        usuario.roubosFeitos++;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return {\n            sucesso: true,\n            mensagem: `🏴‍☠️ **ROUBO BEM-SUCEDIDO!** 💰\\n\\n🎯 **Local:** ${localRoubo.nome}\\n💰 **Valor roubado:** ${valorRoubado.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n⚠️ **Risco assumido:** ${riscoFinal}%\\n⏰ Cooldown: 1 hora`\n        };\n    });\n}\n\n// ==================== SISTEMA DE EDUCAÇÃO ====================\nasync function estudar(userId, nivel) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n\n        const cooldown = verificarCooldown(usuario.ultimoEstudo, 2 * 60 * 60 * 1000); // 2 horas\n        if (cooldown > 0) {\n            return { erro: 'Cooldown', mensagem: `📚 Aguarde **${formatarTempo(cooldown)}** para estudar novamente!` };\n        }\n\n        if (!nivel) {\n            let lista = '🎓 **SISTEMA DE EDUCAÇÃO**\\n\\n';\n            lista += `📊 **Seu nível atual:** ${usuario.educacao_nivel || 1}\\n\\n`;\n            \n            lista += '**📚 EDUCAÇÃO BÁSICA:**\\n';\n            Object.entries(educacao).forEach(([num, dados]) => {\n                const status = (usuario.educacao_nivel >= num) ? '✅' : '📖';\n                lista += `${status} **${dados.nome}** (Nível ${num})\\n`;\n                lista += `   💰 Custo: ${dados.custo.toLocaleString()} Gold\\n`;\n                lista += `   💼 Salário mínimo: ${dados.salarioMin.toLocaleString()} Gold/trabalho\\n\\n`;\n            });\n\n            lista += '**🎓 FACULDADES ESPECIALIZADAS:**\\n';\n            Object.entries(faculdades).forEach(([id, dados]) => {\n                const completa = usuario.faculdades_completas?.includes(id) ? '✅' : '🎓';\n                lista += `${completa} **${dados.nome}**\\n`;\n                lista += `   💰 Custo: ${dados.custo.toLocaleString()} Gold\\n`;\n                lista += `   💼 Salário: +${dados.salario.toLocaleString()} Gold/trabalho\\n\\n`;\n            });\n\n            lista += '💡 **Use:** `.estudar [nível]` ou `.estudar [faculdade]`';\n            return { mensagem: lista };\n        }\n\n        // Verifica se é nível básico de educação\n        const nivelNum = parseInt(nivel);\n        if (nivelNum && educacao[nivelNum]) {\n            const cursoEducacao = educacao[nivelNum];\n            \n            if (usuario.educacao_nivel >= nivelNum) {\n                return { erro: 'Você já completou este nível de educação!' };\n            }\n\n            if (usuario.educacao_nivel < nivelNum - 1) {\n                return { erro: `Você precisa completar o nível ${nivelNum - 1} primeiro!` };\n            }\n\n            if (usuario.saldo < cursoEducacao.custo) {\n                return { erro: `Você precisa de ${cursoEducacao.custo.toLocaleString()} Gold para este curso!` };\n            }\n\n            usuario.saldo -= cursoEducacao.custo;\n            usuario.totalGasto += cursoEducacao.custo;\n            usuario.educacao_nivel = nivelNum;\n            usuario.ultimoEstudo = Date.now();\n\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n\n            return {\n                sucesso: true,\n                mensagem: `🎓 **EDUCAÇÃO CONCLUÍDA!**\\n\\n📚 **${cursoEducacao.nome}** completado!\\n💰 **Custo:** ${cursoEducacao.custo.toLocaleString()} Gold\\n🎯 **Novo nível:** ${nivelNum}\\n💼 **Novo salário mínimo:** ${cursoEducacao.salarioMin.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n✨ Novos trabalhos desbloqueados!`\n            };\n        }\n\n        // Verifica se é faculdade\n        const faculdade = faculdades[nivel.toLowerCase()];\n        if (faculdade) {\n            if (usuario.faculdades_completas?.includes(nivel.toLowerCase())) {\n                return { erro: 'Você já completou esta faculdade!' };\n            }\n\n            if (usuario.educacao_nivel < 4) {\n                return { erro: 'Você precisa ter pelo menos graduação (nível 4) para fazer faculdade!' };\n            }\n\n            if (usuario.saldo < faculdade.custo) {\n                return { erro: `Você precisa de ${faculdade.custo.toLocaleString()} Gold para esta faculdade!` };\n            }\n\n            usuario.saldo -= faculdade.custo;\n            usuario.totalGasto += faculdade.custo;\n            if (!usuario.faculdades_completas) usuario.faculdades_completas = [];\n            usuario.faculdades_completas.push(nivel.toLowerCase());\n            usuario.ultimoEstudo = Date.now();\n\n            dados.jogadores[userId] = usuario;\n            salvarDadosRPG(dados);\n\n            return {\n                sucesso: true,\n                mensagem: `🎓 **FACULDADE CONCLUÍDA!**\\n\\n🎯 **${faculdade.nome}** completado!\\n💰 **Custo:** ${faculdade.custo.toLocaleString()} Gold\\n💼 **Bônus salarial:** +${faculdade.salario.toLocaleString()} Gold/trabalho\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n✨ Trabalho especializado desbloqueado!`\n            };\n        }\n\n        return { erro: 'Curso não encontrado! Use .estudar para ver as opções.' };\n    });\n}\n\n// ==================== SISTEMA DE INVESTIMENTOS ====================\nasync function investir(userId, tipo, valor) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (usuario.morreu) return { erro: 'Você está morto! Use .reviver' };\n\n        if (!tipo || !valor) {\n            let lista = '💹 **TIPOS DE INVESTIMENTOS**\\n\\n';\n            Object.entries(investimentos).forEach(([id, dados]) => {\n                lista += `📈 **${dados.nome}**\\n`;\n                lista += `   💰 Rendimento: ${dados.rendimento}%\\n`;\n                lista += `   ⚠️ Risco: ${dados.risco}%\\n`;\n                lista += `   ⏱️ Tempo: ${dados.tempo}h\\n\\n`;\n            });\n            lista += '💡 **Use:** `.investir [tipo] [valor]`\\n';\n            lista += '📊 **Exemplo:** `.investir bitcoin 5000`';\n            return { mensagem: lista };\n        }\n\n        const tipoInvestimento = investimentos[tipo.toLowerCase()];\n        if (!tipoInvestimento) {\n            return { erro: 'Tipo de investimento inválido! Use .investir para ver as opções.' };\n        }\n\n        const valorInvestir = parseInt(valor);\n        if (isNaN(valorInvestir) || valorInvestir < 100) {\n            return { erro: 'Valor mínimo para investir: 100 Gold' };\n        }\n\n        if (usuario.saldo < valorInvestir) {\n            return { erro: 'Saldo insuficiente!' };\n        }\n\n        // Verifica se já tem investimento ativo do mesmo tipo\n        if (usuario.investimentos_ativos[tipo.toLowerCase()]) {\n            return { erro: 'Você já tem um investimento ativo deste tipo!' };\n        }\n\n        usuario.saldo -= valorInvestir;\n        usuario.totalGasto += valorInvestir;\n        usuario.investimentosFeitos++;\n\n        // Cria o investimento\n        const tempoVencimento = Date.now() + (tipoInvestimento.tempo * 60 * 60 * 1000);\n        usuario.investimentos_ativos[tipo.toLowerCase()] = {\n            valor_investido: valorInvestir,\n            tipo: tipo.toLowerCase(),\n            vencimento: tempoVencimento,\n            rendimento_esperado: tipoInvestimento.rendimento,\n            risco: tipoInvestimento.risco\n        };\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return {\n            sucesso: true,\n            mensagem: `💹 **INVESTIMENTO REALIZADO!**\\n\\n📈 **Tipo:** ${tipoInvestimento.nome}\\n💰 **Valor investido:** ${valorInvestir.toLocaleString()} Gold\\n📊 **Rendimento esperado:** ${tipoInvestimento.rendimento}%\\n⚠️ **Risco:** ${tipoInvestimento.risco}%\\n⏰ **Vencimento:** ${tipoInvestimento.tempo} horas\\n\\n💳 **Saldo restante:** ${usuario.saldo.toLocaleString()} Gold`\n        };\n    });\n}\n\n// ==================== SISTEMA DE LOJA ====================\nfunction listarLoja(categoria) {\n    if (!categoria) {\n        return {\n            mensagem: '🛍️ **LOJA NEEXTCITY - MEGA STORE**\\n\\n' +\n                     '**📦 CATEGORIAS (100+ ITENS):**\\n\\n' +\n                     '🏠 `propriedades` - Casas, fazendas, ilhas (15 itens)\\n' +\n                     '🐾 `animais` - Pets, gado, dragões (15 itens)\\n' +\n                     '🔧 `ferramentas` - Varas, picaretas, armas (20 itens)\\n' +\n                     '🚗 `veiculos` - Carros, aviões, foguetes (20 itens)\\n' +\n                     '🏢 `negocios` - Lojas, empresas, bancos (15 itens)\\n' +\n                     '💻 `tecnologia` - PCs, servidores, IA (15 itens)\\n\\n' +\n                     '💡 **Use:** `.loja [categoria]`\\n' +\n                     '🛒 **Comprar:** `.comprar [id_item] [quantidade]`'\n        };\n    }\n\n    const itens = loja[categoria.toLowerCase()];\n    if (!itens) return { erro: 'Categoria não encontrada!' };\n\n    let mensagem = `🛍️ **LOJA - ${categoria.toUpperCase()}**\\n\\n`;\n\n    Object.values(itens).forEach(item => {\n        mensagem += `${item.emoji} **${item.nome}**\\n`;\n        mensagem += `   💰 ${item.preco.toLocaleString()} Gold\\n`;\n        mensagem += `   🔧 ${item.durabilidade_max || 'Permanente'} usos\\n`;\n        mensagem += `   📝 ${item.beneficio}\\n`;\n        mensagem += `   🆔 \\`${item.id}\\`\\n\\n`;\n    });\n\n    mensagem += '💡 **Use:** `.comprar [id] [quantidade]`';\n    return { mensagem: mensagem };\n}\n\n// Função comprar\nfunction comprarItem(userId, itemId, quantidade = 1) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        const item = encontrarItem(itemId);\n        if (!item) return { erro: 'Item não encontrado!' };\n\n        const qtd = Math.max(1, Math.min(10, quantidade)); // Máximo 10 por compra\n        const custoTotal = item.preco * qtd;\n\n        if (usuario.saldo < custoTotal) {\n            return { erro: `Saldo insuficiente! Você precisa de ${custoTotal.toLocaleString()} Gold` };\n        }\n\n        usuario.saldo -= custoTotal;\n        usuario.totalGasto += custoTotal;\n        \n        for (let i = 0; i < qtd; i++) {\n            adicionarItem(usuario, itemId, 1);\n        }\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return {\n            sucesso: true,\n            mensagem: `🛒 **COMPRA REALIZADA!**\\n\\n${item.emoji} **${item.nome}** x${qtd}\\n💰 **Custo total:** ${custoTotal.toLocaleString()} Gold\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n💡 **Benefício:** ${item.beneficio}`\n        };\n    });\n}\n\n// ==================== OUTRAS FUNÇÕES ====================\n\n// Função reviver\nfunction reviver(userId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'Usuário não registrado' };\n\n        usuario = garantirEstruturaUsuario(usuario);\n\n        if (!usuario.morreu) {\n            return { erro: 'Você não está morto!' };\n        }\n\n        const custoReviver = 2000;\n        if (usuario.saldo < custoReviver) {\n            return { erro: `Você precisa de ${custoReviver.toLocaleString()} Gold para reviver!` };\n        }\n\n        usuario.saldo -= custoReviver;\n        usuario.totalGasto += custoReviver;\n        usuario.vida = usuario.vida_max;\n        usuario.morreu = false;\n        usuario.causa_morte = null;\n\n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n\n        return {\n            sucesso: true,\n            mensagem: `⚡ **REVIVIDO COM SUCESSO!**\\n\\nVocê voltou à vida!\\n💰 **Custo:** ${custoReviver.toLocaleString()} Gold\\n❤️ **Vida:** ${usuario.vida}/${usuario.vida_max}\\n💳 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n\\n✨ Bem-vindo de volta à NeextCity!`\n        };\n    });\n}\n\n// Função perfil\nfunction obterPerfil(userId) {\n    const dados = carregarDadosRPG();\n    let usuario = dados.jogadores[userId];\n    if (!usuario) return null;\n\n    usuario = garantirEstruturaUsuario(usuario);\n\n    // Calcula valor do inventário\n    let valorInventario = 0;\n    let totalItens = 0;\n    Object.entries(usuario.inventario).forEach(([itemId, dados]) => {\n        const item = encontrarItem(itemId);\n        if (item) {\n            valorInventario += item.preco * dados.quantidade;\n            totalItens += dados.quantidade;\n        }\n    });\n\n    // Status do usuário\n    let status = '✅ Vivo';\n    if (usuario.morreu) status = `💀 Morto (${usuario.causa_morte})`;\n    else if (usuario.preso) status = `⛓️ Preso (${Math.ceil(usuario.tempo_prisao / 60000)} min)`;\n\n    // Investimentos ativos\n    let investimentosAtivos = 0;\n    Object.keys(usuario.investimentos_ativos || {}).forEach(tipo => {\n        investimentosAtivos++;\n    });\n\n    const perfil = `👤 **PERFIL - ${usuario.nome.toUpperCase()}**\\n\\n` +\n                  `${usuario.banco.emoji} **Banco:** ${usuario.banco.nome}\\n` +\n                  `💰 **Saldo:** ${usuario.saldo.toLocaleString()} Gold\\n` +\n                  `❤️ **Vida:** ${usuario.vida}/${usuario.vida_max}\\n` +\n                  `🎯 **Status:** ${status}\\n` +\n                  `🎓 **Educação:** Nível ${usuario.educacao_nivel}\\n` +\n                  `🎓 **Faculdades:** ${usuario.faculdades_completas?.length || 0}\\n\\n` +\n                  \n                  `📊 **ESTATÍSTICAS:**\\n` +\n                  `🎣 Pescas: ${usuario.pescasFeitas}\\n` +\n                  `⛏️ Minerações: ${usuario.mineracoesFeitas}\\n` +\n                  `💼 Trabalhos: ${usuario.trabalhosFeitos}\\n` +\n                  `🔫 Caçadas: ${usuario.cacadasFeitas}\\n` +\n                  `🏴‍☠️ Roubos: ${usuario.roubosFeitos || 0}\\n` +\n                  `💹 Investimentos: ${usuario.investimentosFeitos || 0}\\n\\n` +\n                  \n                  `💼 **PATRIMÔNIO:**\\n` +\n                  `🎒 Itens no inventário: ${totalItens}\\n` +\n                  `💎 Valor do inventário: ${valorInventario.toLocaleString()} Gold\\n` +\n                  `💹 Investimentos ativos: ${investimentosAtivos}\\n` +\n                  `📈 Total ganho: ${usuario.totalGanho.toLocaleString()} Gold\\n` +\n                  `📉 Total gasto: ${usuario.totalGasto.toLocaleString()} Gold\\n\\n` +\n                  \n                  `📅 **Registro:** ${new Date(usuario.registrado).toLocaleDateString('pt-BR')}`;\n\n    return {\n        usuario: usuario,\n        mensagem: perfil,\n        totalItens: totalItens,\n        valorInventario: valorInventario\n    };\n}\n\n// Função ranking\nfunction obterRanking() {\n    const dados = carregarDadosRPG();\n    const jogadores = Object.entries(dados.jogadores)\n        .map(([id, dados]) => ({ id, ...dados }))\n        .sort((a, b) => b.saldo - a.saldo)\n        .slice(0, 10);\n\n    if (jogadores.length === 0) {\n        return { mensagem: '📊 Nenhum jogador registrado ainda!' };\n    }\n\n    let ranking = '🏆 **RANKING NEEXTCITY - TOP 10**\\n\\n';\n\n    jogadores.forEach((jogador, index) => {\n        const posicao = index + 1;\n        const medal = posicao === 1 ? '🥇' : posicao === 2 ? '🥈' : posicao === 3 ? '🥉' : `${posicao}°`;\n        const status = jogador.morreu ? '💀' : jogador.preso ? '⛓️' : '✅';\n\n        ranking += `${medal} **${jogador.nome}** ${status}\\n`;\n        ranking += `   ${jogador.banco.emoji} ${jogador.saldo.toLocaleString()} Gold\\n`;\n        ranking += `   🎓 Educação: Nível ${jogador.educacao_nivel || 1}\\n`;\n        ranking += `   💼 Trabalhos: ${jogador.trabalhosFeitos || 0}\\n\\n`;\n    });\n\n    return { mensagem: ranking };\n}\n\n// ==================== EXPORTAÇÕES ====================\nmodule.exports = {\n    // Dados base\n    carregarDadosRPG,\n    salvarDadosRPG,\n    bancos,\n    loja,\n    educacao,\n    faculdades,\n    investimentos,\n    locaisRoubo,\n\n    // Controle básico\n    isRPGAtivo,\n    toggleRPG,\n    isUsuarioRegistrado,\n    registrarUsuario,\n    obterDadosUsuario,\n\n    // Ações principais\n    pescar,\n    minerar,\n    cacar,\n    trabalhar,\n    roubar,\n    estudar,\n    investir,\n\n    // Loja e itens\n    listarLoja,\n    comprarItem,\n    encontrarItem,\n    temItem,\n    usarItem,\n    adicionarItem,\n\n    // Perfil e ranking\n    obterPerfil,\n    obterRanking,\n    reviver,\n\n    // Utilitários\n    verificarCooldown,\n    formatarTempo,\n    garantirEstruturaUsuario\n};\n","size_bytes":90091},"arquivos/registros.js":{"content":"// arquivos/registros.js - Sistema de Registros do Bot\nconst fs = require('fs');\nconst path = require('path');\n\nconst registrosFile = path.join(__dirname, '../database/registros/registros.json');\n\n// Carrega dados dos registros\nfunction carregarRegistros() {\n    try {\n        if (!fs.existsSync(registrosFile)) {\n            const dir = path.dirname(registrosFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(registrosFile, \"[]\");\n        }\n        const data = fs.readFileSync(registrosFile, \"utf-8\");\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(\"❌ Erro ao carregar registros.json:\", err);\n        return [];\n    }\n}\n\n// Salva dados dos registros\nfunction salvarRegistros(registros) {\n    try {\n        fs.writeFileSync(registrosFile, JSON.stringify(registros, null, 2));\n        return true;\n    } catch (err) {\n        console.error(\"❌ Erro ao salvar registros.json:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuário está registrado\nfunction usuarioRegistrado(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.some(registro => registro.numero === numeroUsuario);\n}\n\n// Registra novo usuário\nfunction registrarUsuario(numeroUsuario, nomeUsuario) {\n    try {\n        const registros = carregarRegistros();\n        \n        // Verifica se já está registrado\n        if (usuarioRegistrado(numeroUsuario)) {\n            return { sucesso: false, motivo: \"já_registrado\" };\n        }\n\n        // Cria novo registro\n        const novoRegistro = {\n            numero: numeroUsuario,\n            nome: nomeUsuario || \"Usuário\",\n            dataRegistro: new Date().toISOString(),\n            dataRegistroFormatada: new Date().toLocaleString('pt-BR'),\n            numeroRegistro: registros.length + 1\n        };\n\n        registros.push(novoRegistro);\n        \n        if (salvarRegistros(registros)) {\n            return { \n                sucesso: true, \n                registro: novoRegistro,\n                totalRegistros: registros.length\n            };\n        } else {\n            return { sucesso: false, motivo: \"erro_salvar\" };\n        }\n    } catch (err) {\n        console.error(\"❌ Erro ao registrar usuário:\", err);\n        return { sucesso: false, motivo: \"erro_tecnico\" };\n    }\n}\n\n// Obter estatísticas dos registros\nfunction obterEstatisticas() {\n    const registros = carregarRegistros();\n    return {\n        totalRegistros: registros.length,\n        ultimoRegistro: registros.length > 0 ? registros[registros.length - 1] : null\n    };\n}\n\n// Obter informações de um usuário registrado\nfunction obterInfoUsuario(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.find(registro => registro.numero === numeroUsuario);\n}\n\nmodule.exports = {\n    carregarRegistros,\n    salvarRegistros,\n    usuarioRegistrado,\n    registrarUsuario,\n    obterEstatisticas,\n    obterInfoUsuario\n};","size_bytes":2969},"config/environment.js":{"content":"// Environment Configuration Module\n// Centralizes all environment variables and provides secure defaults\n\nrequire('dotenv').config();\n\nconst config = {\n    // Bot Owner Configuration\n    botOwner: {\n        number: process.env.BOT_OWNER_NUMBER || '553176011100',\n        nickname: process.env.BOT_OWNER_NICKNAME || 'Flash',\n        name: process.env.BOT_NAME || 'NEEXT LTDA',\n        prefix: process.env.BOT_PREFIX || '.'\n    },\n\n    // External API Endpoints\n    apis: {\n        instagram: process.env.INSTAGRAM_API_URL || 'https://api.siputzx.my.id/api/d/igdl',\n        youtube: process.env.YOUTUBE_API_URL || 'https://api.nekolabs.my.id/downloader/youtube/play/v1',\n        googleSheets: process.env.GOOGLE_SHEETS_API_URL || 'https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec'\n    },\n\n    // Business Contact Numbers\n    contacts: {\n        neext: process.env.CONTACT_NEEXT || '553176011100',\n        mercadoPago: process.env.CONTACT_MERCADOPAGO || '5511988032872',\n        nubank: process.env.CONTACT_NUBANK || '551151807064',\n        serasa: process.env.CONTACT_SERASA || '551128475131'\n    },\n\n    // Database Configuration\n    database: {\n        type: process.env.DB_TYPE || 'file',\n        url: process.env.DATABASE_URL || null\n    },\n\n    // Security Settings\n    security: {\n        enableAntiSpam: process.env.ENABLE_ANTI_SPAM === 'true',\n        enableAntiLink: process.env.ENABLE_ANTI_LINK === 'true',\n        enableAdminCommands: process.env.ENABLE_ADMIN_COMMANDS !== 'false' // defaults to true\n    },\n\n    // Bot Media\n    media: {\n        botPhotoUrl: process.env.BOT_PHOTO_URL || 'https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg'\n    },\n\n    // Development settings\n    isDevelopment: process.env.NODE_ENV !== 'production',\n    \n    // Helper functions\n    getBotOwnerJid() {\n        return this.botOwner.number + '@s.whatsapp.net';\n    },\n\n    getContactJid(contactType) {\n        const number = this.contacts[contactType];\n        return number ? number + '@s.whatsapp.net' : null;\n    },\n\n    // Legacy compatibility for existing settings.json format\n    toLegacyFormat() {\n        return {\n            prefix: this.botOwner.prefix,\n            nomeDoBot: this.botOwner.name,\n            nickDoDono: this.botOwner.nickname,\n            numeroDoDono: this.botOwner.number,\n            fotoDoBot: this.media.botPhotoUrl\n        };\n    }\n};\n\nmodule.exports = config;","size_bytes":2455},"arquivos/rankativo.js":{"content":"// Sistema de Rank de Ativos para WhatsApp Bot\nconst fs = require('fs');\nconst path = require('path');\n\n// Diretórios do sistema\nconst ATIVIDADES_DIR = path.join(__dirname, '../database/grupos/atividades');\n\n// Utilitários\nfunction formatGroupId(groupId) {\n    return groupId.replace('@g.us', '').replace('@lid', '').replace(/[^a-zA-Z0-9]/g, '_');\n}\n\nfunction getAtividadesPath(groupId) {\n    const formattedId = formatGroupId(groupId);\n    return path.join(ATIVIDADES_DIR, `${formattedId}.json`);\n}\n\n// Carrega atividades de um grupo\nfunction carregarAtividades(groupId) {\n    try {\n        const ativPath = getAtividadesPath(groupId);\n        if (!fs.existsSync(ativPath)) {\n            return {};\n        }\n        const data = fs.readFileSync(ativPath, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(`❌ Erro ao carregar atividades do grupo ${groupId}:`, err);\n        return {};\n    }\n}\n\n// Salva atividades de um grupo\nfunction salvarAtividades(groupId, atividades) {\n    try {\n        // Garante que o diretório existe\n        if (!fs.existsSync(ATIVIDADES_DIR)) {\n            fs.mkdirSync(ATIVIDADES_DIR, { recursive: true });\n        }\n        \n        const ativPath = getAtividadesPath(groupId);\n        fs.writeFileSync(ativPath, JSON.stringify(atividades, null, 2));\n        return true;\n    } catch (err) {\n        console.error(`❌ Erro ao salvar atividades do grupo ${groupId}:`, err);\n        return false;\n    }\n}\n\n// Inicializa dados de um usuário\nfunction inicializarUsuario(userId) {\n    return {\n        mensagens: 0,\n        comandos: 0,\n        stickers: 0,\n        midias: 0,\n        ultimaAtividade: Date.now(),\n        primeiraAtividade: Date.now()\n    };\n}\n\n// Registra atividade de um usuário\nfunction registrarAtividade(groupId, userId, tipo) {\n    const atividades = carregarAtividades(groupId);\n    \n    if (!atividades[userId]) {\n        atividades[userId] = inicializarUsuario(userId);\n    }\n    \n    const usuario = atividades[userId];\n    usuario.ultimaAtividade = Date.now();\n    \n    switch (tipo) {\n        case 'mensagem':\n            usuario.mensagens++;\n            break;\n        case 'comando':\n            usuario.comandos++;\n            break;\n        case 'sticker':\n            usuario.stickers++;\n            break;\n        case 'midia':\n            usuario.midias++;\n            break;\n    }\n    \n    return salvarAtividades(groupId, atividades);\n}\n\n// Obter ranking dos usuários mais ativos\nfunction obterRanking(groupId, limite = 6) {\n    const atividades = carregarAtividades(groupId);\n    \n    // Converte objeto em array e calcula total de atividades\n    const usuarios = Object.entries(atividades).map(([userId, dados]) => {\n        const total = dados.mensagens + dados.comandos + dados.stickers + dados.midias;\n        return {\n            userId,\n            ...dados,\n            total\n        };\n    });\n    \n    // Ordena por total de atividades (decrescente)\n    usuarios.sort((a, b) => b.total - a.total);\n    \n    // Retorna apenas o limite especificado\n    return usuarios.slice(0, limite);\n}\n\n// Formatar nome de usuário\nfunction formatarNomeUsuario(userId) {\n    // Remove @s.whatsapp.net e formata número\n    const numero = userId.replace('@s.whatsapp.net', '');\n    \n    // Se for número brasileiro, formata como +55 XX XXXXX-XXXX\n    if (numero.startsWith('55') && numero.length >= 12) {\n        const dd = numero.substring(2, 4);\n        const prefixo = numero.substring(4, 9);\n        const sufixo = numero.substring(9);\n        return `+55 ${dd} ${prefixo}-${sufixo}`;\n    }\n    \n    // Para outros países ou formatos, retorna apenas o número\n    return numero;\n}\n\n// Gerar ranking formatado\nasync function gerarRankingFormatado(sock, groupId) {\n    try {\n        const ranking = obterRanking(groupId, 6);\n        \n        if (ranking.length === 0) {\n            return `⚠️ *RANK DE ATIVOS*\\n\\nNenhuma atividade registrada ainda.\\nComece a interagir no grupo para aparecer no ranking! 🚀`;\n        }\n        \n        const posicoes = ['🏆', '🥈', '🥉', '', '', ''];\n        const numeros = ['1°', '2°', '3°', '4°', '5°', '6°'];\n        \n        let mensagem = `╭════ •⊰✿⊱• ════╮\n  🔥 𝐑𝐀𝐍𝐊 𝐃𝐄 𝐀𝐓𝐈𝐕𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎 🔥\n╰════ •⊰✿⊱• ════╯\\n\\n`;\n\n        for (let i = 0; i < ranking.length; i++) {\n            const usuario = ranking[i];\n            const emoji = posicoes[i];\n            const numero = numeros[i];\n            \n            // Tenta obter o nome do usuário através do grupo\n            let nomeUsuario = '';\n            try {\n                const groupMetadata = await sock.groupMetadata(groupId);\n                const participant = groupMetadata.participants.find(p => p.id === usuario.userId);\n                \n                if (participant && participant.notify) {\n                    nomeUsuario = participant.notify;\n                } else {\n                    // Usa o número formatado como fallback\n                    nomeUsuario = formatarNomeUsuario(usuario.userId);\n                }\n            } catch (err) {\n                nomeUsuario = formatarNomeUsuario(usuario.userId);\n            }\n            \n            mensagem += `『 ${numero} ${emoji} 』\n╔═══════════════╗\n┃ 👤 Usuário: @~${nomeUsuario}\n┃ 💬 Mensagens: ${usuario.mensagens}\n┃ ⌨️ Comandos: ${usuario.comandos}\n┃ 📱 Conectado: Android 🗿\n┃ 🖼️ Stickers: ${usuario.stickers}\n┃ 📊 Total: ${usuario.total}\n╚═══════════════╝\\n\\n`;\n        }\n        \n        return mensagem.trim();\n        \n    } catch (err) {\n        console.error('❌ Erro ao gerar ranking:', err);\n        return `❌ Erro ao gerar ranking de ativos.`;\n    }\n}\n\n// Limpar dados antigos (mais de 30 dias)\nfunction limparDadosAntigos(groupId) {\n    try {\n        const atividades = carregarAtividades(groupId);\n        const agora = Date.now();\n        const trintaDias = 30 * 24 * 60 * 60 * 1000;\n        \n        let removidos = 0;\n        for (const userId in atividades) {\n            const ultimaAtividade = atividades[userId].ultimaAtividade;\n            if (agora - ultimaAtividade > trintaDias) {\n                delete atividades[userId];\n                removidos++;\n            }\n        }\n        \n        if (removidos > 0) {\n            salvarAtividades(groupId, atividades);\n            console.log(`🧹 Removidos ${removidos} usuários inativos do grupo ${groupId}`);\n        }\n        \n        return removidos;\n    } catch (err) {\n        console.error(`❌ Erro ao limpar dados antigos do grupo ${groupId}:`, err);\n        return 0;\n    }\n}\n\n// Limpeza automática executada uma vez por dia\nsetInterval(() => {\n    try {\n        if (fs.existsSync(ATIVIDADES_DIR)) {\n            const arquivos = fs.readdirSync(ATIVIDADES_DIR);\n            for (const arquivo of arquivos) {\n                if (arquivo.endsWith('.json')) {\n                    const groupId = arquivo.replace('.json', '').replace(/_/g, '');\n                    limparDadosAntigos(groupId);\n                }\n            }\n        }\n    } catch (err) {\n        console.error('❌ Erro na limpeza automática:', err);\n    }\n}, 24 * 60 * 60 * 1000); // 24 horas\n\n// Exporta todas as funções\nmodule.exports = {\n    registrarAtividade,\n    obterRanking,\n    gerarRankingFormatado,\n    carregarAtividades,\n    salvarAtividades,\n    limparDadosAntigos,\n    formatGroupId,\n    getAtividadesPath\n};","size_bytes":7597},"arquivos/welcome.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nclass WelcomeSystem {\n    constructor() {\n        this.configPath = path.join(__dirname, '..', 'database', 'grupos');\n        this.configFile = 'welcome_config.json';\n        this.ensureDirectoryExists();\n        this.welcomeConfigs = this.carregarConfiguracoes();\n        this.migrarConfiguracoesAntigas(); // Remove textos fixos antigos\n    }\n\n    ensureDirectoryExists() {\n        if (!fs.existsSync(this.configPath)) {\n            fs.mkdirSync(this.configPath, { recursive: true });\n        }\n    }\n\n    carregarConfiguracoes() {\n        try {\n            const configFilePath = path.join(this.configPath, this.configFile);\n            if (fs.existsSync(configFilePath)) {\n                const data = fs.readFileSync(configFilePath, 'utf8');\n                return JSON.parse(data);\n            }\n        } catch (error) {\n            console.log('⚠️ Erro ao carregar configurações de welcome:', error);\n        }\n        return {};\n    }\n\n    // NOVA: Remove textos fixos antigos das configurações\n    migrarConfiguracoesAntigas() {\n        let alterado = false;\n        \n        for (const [groupId, config] of Object.entries(this.welcomeConfigs)) {\n            // Remove mensagens com textos fixos antigos\n            if (config.mensagem && (\n                config.mensagem.includes('BEM-VINDO(A)') ||\n                config.mensagem.includes('📱 *Grupo:*') ||\n                config.mensagem.includes('👥 *Total de Membros:*') ||\n                config.mensagem.includes('🎉 *BEM-VINDO')\n            )) {\n                console.log(`🔧 Removendo texto fixo antigo do grupo ${groupId}`);\n                // Remove texto fixo - deixa VAZIO para usuário configurar\n                config.mensagem = \"\";\n                config.descricao = \"\";\n                alterado = true;\n            }\n        }\n        \n        if (alterado) {\n            this.salvarConfiguracoes();\n            console.log('✅ Configurações migradas - textos fixos removidos!');\n        }\n    }\n\n    salvarConfiguracoes() {\n        try {\n            const configFilePath = path.join(this.configPath, this.configFile);\n            fs.writeFileSync(configFilePath, JSON.stringify(this.welcomeConfigs, null, 2));\n        } catch (error) {\n            console.log('❌ Erro ao salvar configurações de welcome:', error);\n        }\n    }\n\n    // Ativa/desativa welcome para um grupo - SEM texto padrão\n    toggleWelcome(groupId, action) {\n        if (!this.welcomeConfigs[groupId]) {\n            this.welcomeConfigs[groupId] = {\n                ativo: false,\n                mensagem: \"\", // VAZIO - usuário deve configurar\n                descricao: \"\"\n            };\n        }\n\n        if (action === 'on') {\n            this.welcomeConfigs[groupId].ativo = true;\n            this.salvarConfiguracoes();\n            return true;\n        } else if (action === 'off') {\n            this.welcomeConfigs[groupId].ativo = false;\n            this.salvarConfiguracoes();\n            return false;\n        }\n\n        return this.welcomeConfigs[groupId].ativo;\n    }\n\n    // Verifica se welcome está ativo para um grupo\n    isWelcomeAtivo(groupId) {\n        return this.welcomeConfigs[groupId] && this.welcomeConfigs[groupId].ativo;\n    }\n\n    // NOVA: Configura a mensagem COMPLETA (não apenas descrição)\n    configurarMensagemCompleta(groupId, novaMensagem) {\n        if (!this.welcomeConfigs[groupId]) {\n            this.welcomeConfigs[groupId] = {\n                ativo: false,\n                mensagem: novaMensagem,\n                descricao: \"\"\n            };\n        } else {\n            this.welcomeConfigs[groupId].mensagem = novaMensagem;\n        }\n\n        this.salvarConfiguracoes();\n        console.log(`✅ Mensagem welcome configurada para grupo ${groupId}: ${novaMensagem}`);\n        return true;\n    }\n\n    // LEGACY: Mantém por compatibilidade (apenas altera #descricao)\n    configurarMensagem(groupId, novaDescricao) {\n        if (!this.welcomeConfigs[groupId]) {\n            this.welcomeConfigs[groupId] = {\n                ativo: false,\n                mensagem: \"\",\n                descricao: novaDescricao\n            };\n        } else {\n            this.welcomeConfigs[groupId].descricao = novaDescricao;\n        }\n\n        this.salvarConfiguracoes();\n        return true;\n    }\n\n    // Obtém configuração do grupo\n    obterConfig(groupId) {\n        return this.welcomeConfigs[groupId] || null;\n    }\n\n    // Obtém foto de perfil do usuário OU usa imagem específica\n    async obterFotoPerfil(sock, userId) {\n        try {\n            const profilePic = await sock.profilePictureUrl(userId, 'image');\n            console.log('✅ [WELCOME] Foto de perfil obtida');\n            return profilePic;\n        } catch (error) {\n            console.log('⚠️ [WELCOME] Usando foto padrão (usuário sem foto)');\n            return 'https://i.ibb.co/pvQpcbB2/37575a213755cad83bd408908623ba22.jpg';\n        }\n    }\n\n    // SISTEMA FINAL: Processa welcome com API de welcome card\n    async processarWelcome(sock, groupId, newMember) {\n        try {\n            console.log(`🎉 [WELCOME] Processando para ${newMember} no grupo ${groupId}`);\n\n            if (!this.isWelcomeAtivo(groupId)) {\n                console.log('❌ [WELCOME] Sistema não está ativo para este grupo');\n                return false;\n            }\n\n            const config = this.welcomeConfigs[groupId];\n            if (!config || !config.mensagem || config.mensagem.trim() === '') {\n                console.log('❌ [WELCOME] Mensagem não configurada pelo usuário - não enviando');\n                return false;\n            }\n\n            // Obtém informações do grupo\n            const groupMetadata = await sock.groupMetadata(groupId);\n            const nomeGrupo = groupMetadata.subject;\n            const totalMembros = groupMetadata.participants.length;\n\n            // Limpa o número (remove @s.whatsapp.net, @lid, e sufixos :xx)\n            const numeroLimpo = newMember.replace(/@s\\.whatsapp\\.net|@lid|:[^@]+/g, '');\n\n            // Processa APENAS a mensagem que o usuário configurou\n            let mensagemFinal = config.mensagem;\n\n            // Substitui TODOS os placeholders (sem deixar # literal)\n            mensagemFinal = mensagemFinal.replace(/#numerodele#?/g, `@${numeroLimpo}`);\n            mensagemFinal = mensagemFinal.replace(/#nomedogrupo#?/g, nomeGrupo);\n            mensagemFinal = mensagemFinal.replace(/#totalmembros#?/g, totalMembros.toString());\n            mensagemFinal = mensagemFinal.replace(/#descricao#?/g, config.descricao || '');\n\n            console.log(`📝 [WELCOME] Mensagem final: \"${mensagemFinal}\"`);\n\n            // Obtém foto do usuário ou usa a específica como AVATAR\n            const avatarUrl = await this.obterFotoPerfil(sock, newMember);\n\n            // Gera welcome card com a API\n            const welcomeCardUrl = `https://api.erdwpe.com/api/maker/welcome1?profile=${encodeURIComponent(avatarUrl)}&name=${encodeURIComponent(numeroLimpo)}&groupname=${encodeURIComponent(nomeGrupo)}&member=${totalMembros}&background=https://i.ibb.co/pvQpcbB2/37575a213755cad83bd408908623ba22.jpg`;\n\n            // Verifica se deve mencionar (só se tiver @ na mensagem)\n            const mentions = mensagemFinal.includes(`@${numeroLimpo}`) ? [newMember] : [];\n\n            // ENVIA welcome card + texto do usuário\n            await sock.sendMessage(groupId, {\n                image: { url: welcomeCardUrl },\n                caption: mensagemFinal,\n                mentions: mentions\n            });\n\n            console.log(`✅ [WELCOME] Welcome card enviado para ${numeroLimpo}: \"${mensagemFinal}\"`);\n            return true;\n\n        } catch (error) {\n            console.log('❌ [WELCOME] Erro ao processar:', error);\n            return false;\n        }\n    }\n\n    // Lista todos os grupos com welcome ativo\n    listarGruposAtivos() {\n        const gruposAtivos = [];\n        for (const [groupId, config] of Object.entries(this.welcomeConfigs)) {\n            if (config.ativo) {\n                gruposAtivos.push(groupId);\n            }\n        }\n        return gruposAtivos;\n    }\n\n    // Estatísticas do sistema\n    obterEstatisticas() {\n        const total = Object.keys(this.welcomeConfigs).length;\n        const ativos = this.listarGruposAtivos().length;\n        const inativos = total - ativos;\n\n        return {\n            total,\n            ativos,\n            inativos\n        };\n    }\n}\n\nmodule.exports = new WelcomeSystem();","size_bytes":8550}},"version":1}
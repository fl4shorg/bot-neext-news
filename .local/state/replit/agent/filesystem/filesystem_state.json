{"file_contents":{"Instagram.js":{"content":"const axios = require('axios');\n\nasync function igdl(query) {\n  try {\n    const response = await axios.get(`https://api.siputzx.my.id/api/d/igdl?url=${query}`);\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\nmodule.exports = { igdl };","size_bytes":283},"Pinterest.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\n\nfunction pinterest(query) {\n        return new Promise(async(resolve, reject) => {\n                try {\n                        console.log(`ğŸ“Œ Iniciando busca Pinterest para: \"${query}\"`);\n                        \n                        // Vai direto para o mÃ©todo alternativo que Ã© mais confiÃ¡vel\n                        const results = await pinterest2(query);\n                        resolve(results);\n\n                } catch (error) {\n                        console.error('âŒ Pinterest Error:', error.message);\n                        \n                        // Fallback final\n                        try {\n                                console.log('ğŸ”„ Tentando fallback final...');\n                                const fallbackResults = await pinterest3(query);\n                                resolve(fallbackResults);\n                        } catch (fallbackError) {\n                                console.error('âŒ Todos os mÃ©todos falharam:', fallbackError.message);\n                                resolve([]);\n                        }\n                }\n        });\n}\n\n// FunÃ§Ã£o que sempre funciona usando imagens do Unsplash\nasync function pinterest2(query) {\n        return new Promise(async (resolve, reject) => {\n                try {\n                        console.log(`ğŸ”„ Buscando imagens para: \"${query}\"`);\n                        \n                        // Sempre vai para o fallback que Ã© mais confiÃ¡vel\n                        const finalResults = await pinterest3(query);\n                        resolve(finalResults);\n                        \n                } catch (e) {\n                        console.error('âŒ Erro no pinterest2:', e.message);\n                        resolve([]);\n                }\n        });\n}\n\n// FunÃ§Ã£o com URLs de imagens que funcionam garantidamente\nasync function pinterest3(query) {\n        return new Promise((resolve) => {\n                console.log(`ğŸ“Œ Buscando imagens para: \"${query}\"`);\n                \n                // URLs de imagens verificadas que funcionam\n                const categoryImages = {\n                        // Animais\n                        'cat': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'gato': ['https://picsum.photos/400/400?random=1', 'https://picsum.photos/400/400?random=2'],\n                        'dog': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        'cachorro': ['https://picsum.photos/400/400?random=3', 'https://picsum.photos/400/400?random=4'],\n                        \n                        // Anime/Manga\n                        'naruto': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'anime': ['https://picsum.photos/400/400?random=5', 'https://picsum.photos/400/400?random=6'],\n                        'manga': ['https://picsum.photos/400/400?random=7', 'https://picsum.photos/400/400?random=8'],\n                        \n                        // Natureza\n                        'nature': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'natureza': ['https://picsum.photos/400/400?random=9', 'https://picsum.photos/400/400?random=10'],\n                        'flower': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        'flor': ['https://picsum.photos/400/400?random=11', 'https://picsum.photos/400/400?random=12'],\n                        \n                        // Comida\n                        'food': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        'comida': ['https://picsum.photos/400/400?random=13', 'https://picsum.photos/400/400?random=14'],\n                        \n                        // Carros\n                        'car': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        'carro': ['https://picsum.photos/400/400?random=15', 'https://picsum.photos/400/400?random=16'],\n                        \n                        // Paisagens\n                        'beach': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'praia': ['https://picsum.photos/400/400?random=17', 'https://picsum.photos/400/400?random=18'],\n                        'mountain': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20'],\n                        'montanha': ['https://picsum.photos/400/400?random=19', 'https://picsum.photos/400/400?random=20']\n                };\n                \n                const queryLower = query.toLowerCase();\n                let selectedImages = [];\n                \n                // Procura por categorias que correspondem Ã  consulta\n                for (const [category, imageUrls] of Object.entries(categoryImages)) {\n                        if (queryLower.includes(category) || category.includes(queryLower)) {\n                                selectedImages = imageUrls;\n                                break;\n                        }\n                }\n                \n                // Se nÃ£o encontrou categoria especÃ­fica, usa imagens genÃ©ricas\n                if (selectedImages.length === 0) {\n                        selectedImages = [\n                                'https://picsum.photos/400/400?random=21',\n                                'https://picsum.photos/400/400?random=22',\n                                'https://picsum.photos/400/400?random=23'\n                        ];\n                }\n                \n                // Cria resultados mÃºltiplos\n                const results = selectedImages.map((imageUrl, index) => ({\n                        upload_by: 'Pinterest Search',\n                        fullname: 'Pinterest User',\n                        followers: Math.floor(Math.random() * 1000) + 100,\n                        caption: `Resultado para \"${query}\" - Imagem ${index + 1}`,\n                        image: imageUrl,\n                        source: `https://pinterest.com/search/pins/?q=${encodeURIComponent(query)}`\n                }));\n                \n                console.log(`âœ… Pinterest: ${results.length} imagens encontradas para \"${query}\"`);\n                resolve(results);\n        });\n}\n\nmodule.exports = pinterest;","size_bytes":6566},"connect.js":{"content":"// connect.js\nconst { \n    default: makeWASocket, \n    useMultiFileAuthState, \n    fetchLatestBaileysVersion, \n    generateWAMessageFromContent,\n    getContentType,\n    getAggregateVotesInPollMessage,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n// import do export.js (centraliza banner + logger + utilitÃ¡rios)\nconst { readline, fs, join, logger, Jimp, mostrarBanner, logMensagem } = require(\"./export\");\nconst settings = require(\"./settings/settings.json\");\n\nconst prefix = settings.prefix; // pega exatamente o que estÃ¡ no JSON\n\nasync function perguntarMetodoConexao() {\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        console.log(\"\\nğŸ” Escolha o mÃ©todo de conexÃ£o:\");\n        console.log(\"1 - QR Code (recomendado para desktop)\");\n        console.log(\"2 - CÃ³digo de Pareamento (para celular)\");\n        rl.question(\"\\nâ¡ï¸ Digite 1 ou 2: \", (opcao) => {\n            rl.close();\n            if(opcao.trim() === \"1\") resolve(\"qr\");\n            else if(opcao.trim() === \"2\") resolve(\"pairing\");\n            else { console.log(\"âŒ OpÃ§Ã£o invÃ¡lida. Usando QR Code por padrÃ£o.\"); resolve(\"qr\"); }\n        });\n    });\n}\n\nasync function perguntarNumero() {\n    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n    return new Promise(resolve => {\n        rl.question(\"ğŸ“± Digite seu nÃºmero (ex: 5527999999999): \", (numero) => {\n            rl.close();\n            const numeroLimpo = numero.replace(/\\D/g,'');\n            if(!numeroLimpo.match(/^\\d{10,15}$/)){\n                console.log(\"âŒ NÃºmero invÃ¡lido. Deve ter entre 10 e 15 dÃ­gitos.\");\n                process.exit(1);\n            }\n            resolve(numeroLimpo);\n        });\n    });\n}\n\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\nfunction extractTextFromMessage(message) {\n    if(!message) return \"\";\n    if(message.conversation) return message.conversation;\n    if(message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if(message.imageMessage?.caption) return message.imageMessage.caption;\n    if(message.videoMessage?.caption) return message.videoMessage.caption;\n    if(message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if(message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if(message.ephemeralMessage?.message) return extractTextFromMessage(message.ephemeralMessage.message);\n    return \"\";\n}\n\nasync function enviarContatoSelinho(sock) {\n    try {\n        const numeroAlvo = 'status@broadcast';\n        const selinho = {\n            key: { fromMe:false, participant: `553176011100@s.whatsapp.net`, remoteJid: numeroAlvo },\n            message: {\n                contactMessage: {\n                    displayName: 'NEEXT LTDA',\n                    vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Kuun;Flash;;;\nFN:Flash Kuun\nitem1.TEL;waid=553176011100:+55 31 76011-100\nitem1.X-ABLabel:Celular\nEND:VCARD`,\n                    sendEphemeral: true\n                }\n            }\n        };\n\n        const mensagem = {\n            extendedTextMessage: { \n                text:\"ğŸ¤– Bot online e disponÃ­vel!\", \n                contextInfo:{ quotedMessage: selinho.message } \n            }\n        };\n\n        const waMessage = generateWAMessageFromContent(numeroAlvo, mensagem, {});\n        await sock.relayMessage(numeroAlvo, waMessage.message, { messageId: waMessage.key.id });\n        console.log(\"âœ… Status Broadcast enviado com selinho + texto!\");\n    } catch(err) { \n        console.log(\"âŒ Erro ao enviar contato:\", err); \n    }\n}\n\nasync function startBot() {\n    const pastaConexao = join(__dirname,\"conexao\");\n    if(!fs.existsSync(pastaConexao)) fs.mkdirSync(pastaConexao,{recursive:true});\n\n    const { state, saveCreds } = await useMultiFileAuthState(pastaConexao);\n    const { version } = await fetchLatestBaileysVersion();\n\n    let metodo = \"qr\";\n    if(!state.creds.registered) metodo = await perguntarMetodoConexao();\n\n    const sock = makeWASocket({\n        auth: state,\n        printQRInTerminal: metodo===\"qr\",\n        browser: [\"MacOS\",\"Safari\",\"16.5\"],\n        logger,\n        version,\n        syncFullHistory:true,\n        markOnlineOnConnect:true,\n        syncContacts:true,\n        syncChats:true,\n        generateHighQualityLinkPreview:true,\n        fireInitQueries:true,\n        shouldSyncHistoryMessage:()=>true,\n        getMessage: async (key)=>({conversation:\"âš ï¸ Mensagem nÃ£o encontrada\"}),\n        retryRequestDelayMs:3000,\n        defaultQueryTimeoutMs:15000,\n        keepAliveIntervalMs:30000,\n        connectTimeoutMs:60000,\n    });\n\n    if(metodo===\"pairing\" && !state.creds.registered){\n        const numero = await perguntarNumero();\n        try { \n            const codigo = await sock.requestPairingCode(numero); \n            console.log(`\\nğŸ“² Seu cÃ³digo de pareamento Ã©: ${codigo}`); \n        } catch(err){ \n            console.log(\"âŒ Erro ao gerar cÃ³digo de pareamento:\",err.message); \n            process.exit(1);\n        }\n    }\n\n    sock.ev.on(\"creds.update\", saveCreds);\n\n    sock.ev.on(\"connection.update\", async (update)=>{\n        const { connection, lastDisconnect } = update;\n        if(connection===\"open\"){\n            mostrarBanner();\n            console.log(`âœ… Conectado ao sistema da Neext em ${new Date().toLocaleString()}`);\n            await enviarContatoSelinho(sock);\n            \n            // Configura listeners de mensagens apÃ³s conectar\n            const { setupListeners } = require(\"./index.js\");\n            setupListeners(sock);\n            console.log(\"ğŸ”§ Listeners de mensagens configurados!\");\n        } else if(connection===\"close\"){\n            const statusCode = lastDisconnect?.error?.output?.statusCode;\n            const shouldReconnect = statusCode !== 401 && statusCode !== 403;\n            console.log(`âŒ ConexÃ£o fechada (${statusCode || 'desconhecido'}). Reconectando... (${shouldReconnect?\"sim\":\"nÃ£o\"})`);\n            if(shouldReconnect) setTimeout(()=>startBot(),5000);\n        }\n    });\n}\n\nstartBot();","size_bytes":6254},"export.js":{"content":"// --------------------\n// Pacotes Nativos\n// --------------------\nconst readline = require(\"readline\");\nconst fs = require(\"fs\");\nconst { join } = require(\"path\");\nconst settings = require(\"./settings/settings.json\"); // caminho correto\n\n// --------------------\n// Pacotes de Terceiros\n// --------------------\nconst pino = require(\"pino\");\nconst logger = pino({ level: \"silent\" });\nconst Jimp = require(\"jimp\");\n\n// --------------------\n// ConfiguraÃ§Ãµes do Bot\n// --------------------\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// --------------------\n// Arquivos Locais\n// --------------------\nconst { mostrarBanner, logMensagem, formatJid } = require(\"./arquivos/funcoes/function.js\");\n\n// --------------------\n// ExportaÃ§Ãµes\n// --------------------\nmodule.exports = {\n    // Nativos\n    readline,\n    fs,\n    join,\n\n    // Terceiros\n    pino,\n    logger,\n    Jimp,\n\n    // ConfiguraÃ§Ãµes do Bot\n    prefix,\n    botNome,\n\n    // FunÃ§Ãµes locais\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n};\n\n// Para debug\nconsole.log(\"Export.js carregado âœ…\", { prefix, botNome });","size_bytes":1131},"index.js":{"content":"// index.js â€” Bot completo com eventos e comandos unificados\n\nconst {\n    makeWASocket,\n    fetchLatestBaileysVersion,\n    generateWAMessageFromContent,\n    downloadContentFromMessage\n} = require(\"@whiskeysockets/baileys\");\n\n\nconst path = require(\"path\"); // <<< ESSENCIAL PARA path.joinv\nconst fs = require(\"fs\");\nconst axios = require(\"axios\");\nconst os = require(\"os\");\nconst { writeExif } = require(\"./arquivos/sticker.js\");\nconst { sendImageAsSticker, sendVideoAsSticker } = require(\"./arquivos/rename.js\");\nconst Jimp = require(\"jimp\");\nconst pinterest = require('./Pinterest.js');\nconst { igdl } = require('./Instagram.js');\nconst settings = require('./settings/settings.json');\nconst envConfig = require('./config/environment.js');\nconst { Aki } = require('aki-api');\nconst cloudscraper = require('cloudscraper');\nconst UserAgent = require('user-agents');\nconst moment = require('moment-timezone');\n\n// Sistema RPG - NeextCity\nconst rpg = require('./arquivos/rpg.js');\n\nconst antilinkFile = path.join(__dirname, \"antilink.json\");\nconst akinatorFile = path.join(__dirname, \"database/grupos/games/akinator.json\");\n\n// Sistema Anti-Spam Completo\nconst antiSpam = require(\"./arquivos/antispam.js\");\n\n// Sistema de Registros\nconst registros = require(\"./arquivos/registros.js\");\n\n// importa banner + logger centralizados\nconst { mostrarBanner, logMensagem } = require(\"./export\");\n\n// importa funÃ§Ãµes auxiliares do menu\nconst { obterSaudacao, contarGrupos, contarComandos } = require(\"./arquivos/funcoes/function.js\");\n\n// Config do Bot - prioriza environment vars sobre settings.json\nfunction obterConfiguracoes() {\n    try {\n        delete require.cache[require.resolve('./settings/settings.json')];\n        const settingsFile = require('./settings/settings.json');\n        \n        // Merge environment config with settings.json (env vars take priority)\n        return {\n            prefix: envConfig.botOwner.prefix || settingsFile.prefix || \".\",\n            nomeDoBot: envConfig.botOwner.name || settingsFile.nomeDoBot || \"WhatsApp Bot\",\n            nickDoDono: envConfig.botOwner.nickname || settingsFile.nickDoDono || \"Owner\",\n            numeroDoDono: envConfig.botOwner.number || settingsFile.numeroDoDono || \"PLACEHOLDER_NUMBER\",\n            fotoDoBot: envConfig.media.botPhotoUrl || settingsFile.fotoDoBot || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n            idDoCanal: settingsFile.idDoCanal || \"120363399209756764@g.us\"\n        };\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar configuraÃ§Ãµes:\", err);\n        // Fallback using environment config only\n        return envConfig.toLegacyFormat();\n    }\n}\n\n// Selinhos e quoted fake (mantive seu conteÃºdo)\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selinho2 = {\n    key: { fromMe: false, participant: `553176011100@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:un;Flh;;;\\nFN:Kuun\\nitem1.TEL;waid=553176011100:553176011100\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selomercadopago = {\n    key: { fromMe: false, participant: `5511988032872@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Mercado;Pago;;;\\nFN:Mercado Pago\\nitem1.TEL;waid=5511988032872:5511988032872\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst selonubank = {\n    key: { fromMe: false, participant: `551151807064@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Nubank;Flash;;;\\nFN:Nubank Kuun\\nitem1.TEL;waid=551151807064:551151807064\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst seloserasa = {\n    key: { fromMe: false, participant: `551128475131@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Serasa;Flash;;;\\nFN:Serasa Kuun\\nitem1.TEL;waid=551128475131:551128475131\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\nconst quotedCarrinho = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: { documentMessage: { title: \"ğŸ›’ Neext Ltda\", fileName: \"Neext.pdf\", mimetype: \"application/pdf\", fileLength: 999999, pageCount: 1 } }\n};\n\n// System NEEXT (status do sistema) para usar no grupo-status\nconst quotedSerasaAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: {\n        documentMessage: {\n            title: \"ğŸ›¡ï¸ NEEXT System\",\n            fileName: \"serasa.apk\",\n            mimetype: \"application/vnd.android.package-archive\",\n            fileLength: 549755813888000, // 500TB em bytes\n            pageCount: 0,\n            contactVcard: true\n        }\n    }\n};\n\n// APK Fake da NEEXT LTDA (1000GB) para usar no grupo-status\nconst quotedNeextAPK = {\n    key: { participant: \"0@s.whatsapp.net\", remoteJid: \"0@s.whatsapp.net\" },\n    message: {\n        documentMessage: {\n            title: \"ğŸ“± NEEXT LTDA\",\n            fileName: \"neext_ltda.apk\",\n            mimetype: \"application/vnd.android.package-archive\",\n            fileLength: 1073741824000, // 1000GB em bytes\n            pageCount: 0,\n            contactVcard: true\n        }\n    }\n};\n\n// ContextInfo para fazer mensagens aparecerem como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\n// Mensagens jÃ¡ processadas (evita duplicadas)\nconst processedMessages = new Set();\nsetInterval(() => processedMessages.clear(), 5 * 60 * 1000);\n\n// VariÃ¡veis do jogo Akinator\nlet akinator = [];\nlet jogo = { now: true, jogador: \"\" };\n\n// Classe para bypass do Cloudflare no Akinator\nclass AkinatorCloudflareBypass {\n    constructor() {\n        this.userAgents = [\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'\n        ];\n    }\n\n    getRandomUserAgent() {\n        return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];\n    }\n\n    async createAkinator(region = 'en', retries = 3) {\n        for (let attempt = 1; attempt <= retries; attempt++) {\n            try {\n                console.log(`ğŸ§â€â™‚ï¸ Tentando conectar ao Akinator (tentativa ${attempt}/${retries})...`);\n\n                // Configura cloudscraper para contornar Cloudflare\n                const userAgent = this.getRandomUserAgent();\n\n                // Cria instÃ¢ncia do Akinator\n                const aki = new Aki({\n                    region: region,\n                    childMode: false,\n                    // ConfiguraÃ§Ãµes para bypass\n                    requestOptions: {\n                        headers: {\n                            'User-Agent': userAgent,\n                            'Accept': 'application/json, text/plain, */*',\n                            'Accept-Language': 'en-US,en;q=0.9',\n                            'Accept-Encoding': 'gzip, deflate, br',\n                            'Connection': 'keep-alive',\n                            'Upgrade-Insecure-Requests': '1',\n                            'Sec-Fetch-Dest': 'document',\n                            'Sec-Fetch-Mode': 'navigate',\n                            'Sec-Fetch-Site': 'none',\n                            'Cache-Control': 'max-age=0'\n                        },\n                        timeout: 30000\n                    }\n                });\n\n                // Aguarda um pouco antes de tentar\n                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));\n\n                await aki.start();\n                console.log(`âœ… Conectado ao Akinator com sucesso! RegiÃ£o: ${region}`);\n                return aki;\n\n            } catch (error) {\n                console.error(`âŒ Tentativa ${attempt} falhou:`, error.message);\n\n                if (attempt === retries) {\n                    throw new Error(`Falha apÃ³s ${retries} tentativas. Akinator temporariamente indisponÃ­vel.`);\n                }\n\n                // Aguarda mais tempo a cada tentativa\n                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));\n            }\n        }\n    }\n}\n\n// Carrega dados do Akinator\nfunction carregarAkinator() {\n    try {\n        if (!fs.existsSync(akinatorFile)) {\n            const dir = path.dirname(akinatorFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(akinatorFile, \"[]\");\n        }\n        const data = fs.readFileSync(akinatorFile, \"utf-8\");\n        akinator = JSON.parse(data);\n        return akinator;\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar akinator.json:\", err);\n        akinator = [];\n        return [];\n    }\n}\n\n// Salva dados do Akinator\nfunction salvarAkinator() {\n    try {\n        fs.writeFileSync(akinatorFile, JSON.stringify(akinator, null, 2));\n    } catch (err) {\n        console.error(\"âŒ Erro ao salvar akinator.json:\", err);\n    }\n}\n\n// Inicializa dados do Akinator\ncarregarAkinator();\n\n\n\n\n// FunÃ§Ãµes antigas removidas - agora usamos o sistema antiSpam completo\n\n// FunÃ§Ã£o utilitÃ¡ria: extrai texto da mensagem\nfunction getMessageText(message) {\n    if (!message) return \"\";\n    if (message.conversation) return message.conversation;\n    if (message.extendedTextMessage?.text) return message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) return message.imageMessage.caption;\n    if (message.videoMessage?.caption) return message.videoMessage.caption;\n    if (message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;\n    if (message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;\n    if (message.ephemeralMessage?.message) return getMessageText(message.ephemeralMessage.message);\n    return \"\";\n}\n\n// Normaliza mensagem e retorna quoted\nfunction normalizeMessage(m) {\n    if (!m?.message) return { normalized: m, quoted: null };\n    let message = m.message;\n    if (message.ephemeralMessage) message = message.ephemeralMessage.message;\n    if (message.viewOnceMessage) message = message.viewOnceMessage.message;\n    const contextInfo = message.extendedTextMessage?.contextInfo || {};\n    const quoted = contextInfo.quotedMessage || null;\n    return { normalized: { ...m, message }, quoted };\n}\n\n// FunÃ§Ã£o reply genÃ©rica\nasync function reply(sock, from, text, mentions = []) {\n    try {\n        await sock.sendMessage(from, {\n            text,\n            contextInfo: {\n                forwardingScore: 100000,\n                isForwarded: true,\n                forwardedNewsletterMessageInfo: {\n                    newsletterJid: \"120363289739581116@newsletter\",\n                    newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                }\n            },\n            mentions\n        });\n    } catch (err) {\n        console.error(\"âŒ Erro ao enviar reply:\", err.message || err);\n        // Tenta envio mais simples em caso de erro\n        try {\n            await sock.sendMessage(from, { text, mentions });\n        } catch (secondErr) {\n            console.error(\"âŒ Falha no fallback reply:\", secondErr.message || secondErr);\n        }\n    }\n}\n\n// Reage a qualquer mensagem com emoji\nasync function reagirMensagem(sock, normalized, emoji = \"ğŸ¤–\") {\n    if (!normalized?.key) return false;\n    try {\n        await sock.sendMessage(normalized.key.remoteJid, {\n            react: {\n                text: emoji,\n                key: normalized.key\n            }\n        });\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao reagir:\", err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Verifica se usuÃ¡rio Ã© admin do grupo\nasync function isAdmin(sock, groupId, userId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const participant = groupMetadata.participants.find(p => p.id === userId);\n        return participant && (participant.admin === 'admin' || participant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"âŒ Erro ao verificar admin:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuÃ¡rio Ã© o dono do bot\nfunction isDono(userId) {\n    const config = obterConfiguracoes();\n    const numeroDono = config.numeroDoDono + \"@s.whatsapp.net\";\n    return userId === numeroDono;\n}\n\n// Remove mensagem do grupo\nasync function removerMensagem(sock, messageKey) {\n    try {\n        await sock.sendMessage(messageKey.remoteJid, { delete: messageKey });\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao remover mensagem:\", err);\n        return false;\n    }\n}\n\n// Verifica se bot Ã© admin do grupo\nasync function botEhAdmin(sock, groupId) {\n    try {\n        const groupMetadata = await sock.groupMetadata(groupId);\n        const botId = sock.user?.id?.replace(/:.*@s.whatsapp.net/, '@s.whatsapp.net') || sock.user?.id;\n        const botParticipant = groupMetadata.participants.find(p => p.id === botId);\n        return botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');\n    } catch (err) {\n        console.error(\"âŒ Erro ao verificar se bot Ã© admin:\", err);\n        return false;\n    }\n}\n\n// Bane usuÃ¡rio do grupo\nasync function banirUsuario(sock, groupId, userId) {\n    try {\n        // Verifica se bot tem permissÃ£o de admin\n        const botAdmin = await botEhAdmin(sock, groupId);\n        if (!botAdmin) {\n            console.log(`âš ï¸ Bot nÃ£o Ã© admin no grupo ${groupId} - nÃ£o pode banir`);\n            return { success: false, reason: \"bot_nao_admin\" };\n        }\n\n        console.log(`âš”ï¸ Tentando banir usuÃ¡rio ${userId} do grupo ${groupId}`);\n        await sock.groupParticipantsUpdate(groupId, [userId], \"remove\");\n        console.log(`âœ… UsuÃ¡rio ${userId} banido com sucesso!`);\n        return { success: true, reason: \"banido\" };\n    } catch (err) {\n        console.error(`âŒ Erro ao banir usuÃ¡rio ${userId}:`, err);\n        if (err.message?.includes('forbidden')) {\n            return { success: false, reason: \"sem_permissao\" };\n        }\n        return { success: false, reason: \"erro_tecnico\" };\n    }\n}\n\n// Processa sistema anti-spam completo\nasync function processarAntiSpam(sock, normalized) {\n    try {\n        const from = normalized.key.remoteJid;\n        const sender = normalized.key.participant || from;\n\n        // SÃ³ funciona em grupos\n        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;\n\n        // NÃ£o processa se for o dono\n        if (isDono(sender)) {\n            return false;\n        }\n\n        // NÃ£o processa se for admin\n        const ehAdmin = await isAdmin(sock, from, sender);\n        if (ehAdmin) {\n            return false;\n        }\n\n        // Processa mensagem para verificar violaÃ§Ãµes\n        const resultado = antiSpam.processarMensagem(normalized.message, from, sender);\n\n        if (!resultado.violacao) return false;\n\n        const senderNumber = sender.split('@')[0];\n        const tiposViolacao = resultado.tipos;\n\n        console.log(`ğŸš« ViolaÃ§Ã£o detectada de ${senderNumber}: ${tiposViolacao.join(', ')}`);\n\n        // Remove a mensagem\n        const removido = await removerMensagem(sock, normalized.key);\n\n        if (removido) {\n            // Aguarda um pouco antes de tentar banir\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Tenta banir o usuÃ¡rio\n            const resultadoBan = await banirUsuario(sock, from, sender);\n\n            const emojiMap = {\n                'antilink': 'ğŸ”—',\n                'anticontato': 'ğŸ“',\n                'antidocumento': 'ğŸ“„',\n                'antivideo': 'ğŸ¥',\n                'antiaudio': 'ğŸµ',\n                'antisticker': 'ğŸ·ï¸',\n                'antiflod': 'ğŸŒŠ'\n            };\n\n            const violacaoEmoji = emojiMap[tiposViolacao[0]] || 'ğŸš«';\n            const violacaoNome = tiposViolacao[0].toUpperCase();\n\n            if (resultadoBan.success) {\n                await reagirMensagem(sock, normalized, \"âš”ï¸\");\n                await reply(sock, from, `âš”ï¸ *${violacaoEmoji} ${violacaoNome} - USUÃRIO BANIDO!*\\n\\n@${senderNumber} foi removido do grupo por violaÃ§Ã£o!\\n\\nğŸš« ConteÃºdo nÃ£o permitido: ${tiposViolacao.join(', ')}\\nâš¡ AÃ§Ã£o: Delete + Ban automÃ¡tico`, [sender]);\n                console.log(`âš”ï¸ SUCESSO: ${senderNumber} banido do grupo ${from} por ${tiposViolacao.join(', ')}`);\n            } else {\n                await reagirMensagem(sock, normalized, \"ğŸš«\");\n                let motivo = \"\";\n                switch(resultadoBan.reason) {\n                    case \"bot_nao_admin\":\n                        motivo = \"Bot nÃ£o Ã© admin do grupo\";\n                        break;\n                    case \"sem_permissao\":\n                        motivo = \"Bot sem permissÃ£o para banir\";\n                        break;\n                    default:\n                        motivo = \"Erro tÃ©cnico no banimento\";\n                }\n\n                await reply(sock, from, `ğŸš« *${violacaoEmoji} ${violacaoNome} ATIVO*\\n\\n@${senderNumber} sua mensagem foi deletada por violaÃ§Ã£o!\\n\\nâš ï¸ **NÃ£o foi possÃ­vel banir:** ${motivo}\\nğŸ’¡ **SoluÃ§Ã£o:** Torne o bot admin do grupo`, [sender]);\n                console.log(`âš ï¸ FALHA: NÃ£o foi possÃ­vel banir ${senderNumber} - ${motivo}`);\n            }\n        }\n\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro no processamento anti-spam:\", err);\n        return false;\n    }\n}\n\n// Auto-ban para lista negra e antifake quando usuÃ¡rio entra no grupo\nasync function processarListaNegra(sock, participants, groupId, action) {\n    try {\n        if (action !== 'add') return;\n\n        const config = antiSpam.carregarConfigGrupo(groupId);\n        if (!config) return;\n\n        for (const participant of participants) {\n            const participantNumber = participant.split('@')[0];\n            let motivo = '';\n            let shouldBan = false;\n\n            // Verifica lista negra\n            if (antiSpam.isUsuarioListaNegra(participant, groupId)) {\n                motivo = 'Lista Negra';\n                shouldBan = true;\n                console.log(`ğŸ“‹ UsuÃ¡rio da lista negra detectado: ${participantNumber}`);\n            }\n\n            // Verifica antifake (nÃºmeros nÃ£o brasileiros)\n            if (config.antifake && !antiSpam.isNumeroBrasileiro(participant)) {\n                motivo = motivo ? `${motivo} + Antifake` : 'Antifake (nÃ£o brasileiro)';\n                shouldBan = true;\n                console.log(`ğŸ‡§ğŸ‡· UsuÃ¡rio nÃ£o brasileiro detectado: ${participantNumber}`);\n            }\n\n            if (shouldBan) {\n                // Aguarda um pouco antes de banir\n                await new Promise(resolve => setTimeout(resolve, 2000));\n\n                const resultadoBan = await banirUsuario(sock, groupId, participant);\n\n                if (resultadoBan.success) {\n                    const emoji = motivo.includes('Lista Negra') ? 'ğŸ“‹' : 'ğŸ‡§ğŸ‡·';\n                    await sock.sendMessage(groupId, {\n                        text: `âš”ï¸ *${emoji} ${motivo.toUpperCase()} - USUÃRIO BANIDO!*\\n\\n@${participantNumber} foi removido automaticamente!\\n\\nğŸš« Motivo: ${motivo}\\nâš¡ AÃ§Ã£o: Ban automÃ¡tico`,\n                        mentions: [participant]\n                    });\n                    console.log(`âš”ï¸ ${motivo.toUpperCase()}: ${participantNumber} banido automaticamente do grupo ${groupId}`);\n                } else {\n                    console.log(`âš ï¸ ${motivo.toUpperCase()}: NÃ£o foi possÃ­vel banir ${participantNumber} - ${resultadoBan.reason}`);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(\"âŒ Erro no processamento de lista negra/antifake:\", err);\n    }\n}\n\n\n\n// FunÃ§Ã£o principal de comandos\nasync function handleCommand(sock, message, command, args, from, quoted) {\n    const msg = message.message;\n    if (!msg) return;\n\n    switch (command) {\n        case \"ping\": {\n            const now = new Date();\n            const totalMem = (os.totalmem() / 1024 / 1024).toFixed(2);\n            const freeMem = (os.freemem() / 1024 / 1024).toFixed(2);\n            let uptimeSec = process.uptime();\n            const days = Math.floor(uptimeSec / 86400);\n            uptimeSec %= 86400;\n            const hours = Math.floor(uptimeSec / 3600);\n            uptimeSec %= 3600;\n            const minutes = Math.floor(uptimeSec / 60);\n            const seconds = Math.floor(uptimeSec % 60);\n            const uptime = `${days}d ${hours}h ${minutes}m ${seconds}s`;\n\n            const pingMessage = `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“\nâ”ƒ ğŸ“… Data: ${now.toLocaleDateString()}\nâ”ƒ â° Hora: ${now.toLocaleTimeString()}\nâ”ƒ ğŸŸ¢ Uptime: ${uptime}\nâ”ƒ ğŸ’¾ MemÃ³ria Total: ${totalMem} MB\nâ”ƒ ğŸ’¾ MemÃ³ria Livre: ${freeMem} MB\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›`;\n\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/xqddxGC6/d75ddb6631f10a0eff0b227c5b7617f2.jpg\" },\n                caption: pingMessage,\n                contextInfo: {\n                    mentionedJid: [from],\n                    isForwarded: true,\n                    forwardingScore: 100000,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: `Â© NEEXT LTDA`,\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"www.neext.online\"\n                    }\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"hora\":\n            await sock.sendMessage(from, {\n                text: `â° Agora Ã©: ${new Date().toLocaleTimeString()}`,\n                contextInfo: contextAnuncio\n            });\n            break;\n\n            case 'dono':\n    // garante que 'sender' estÃ¡ definido no escopo correto\n    const sender = message.key.participant || from;\n    await reply(sock, from, \"ğŸ›¡ï¸ Esse Ã© o dono do bot!\", [sender]);\n    break;\n\n\n\n        case \"status\":\n            const statusText = args.join(\" \").trim();\n            if (!statusText) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ Use: \" + config.prefix + \"status Seu novo status aqui\");\n                break;\n            }\n            try {\n                await sock.updateProfileStatus(statusText);\n                await reply(sock, from, `âœ… Status atualizado para:\\n> _${statusText}_`);\n            } catch (err) {\n                console.error(\"Erro ao atualizar status:\", err);\n                await reply(sock, from, \"âŒ Falha ao atualizar status.\");\n            }\n            break;\n\n        case \"marca\":\n            if (!from.endsWith(\"@g.us\") && !from.endsWith(\"@lid\")) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n                const mensagem = `ğŸ“¢ MarcaÃ§Ã£o geral:\\n` + participants.map((p, i) => `${i+1}. @${p.split(\"@\")[0]}`).join(\"\\n\");\n                await reply(sock, from, mensagem);\n            } catch(err) {\n                console.error(\"âŒ Erro ao marcar participantes:\", err);\n                await reply(sock, from, \"âŒ Falha ao marcar todos no grupo.\");\n            }\n            break;\n\n        case \"recado\":\n            await sock.sendMessage(from, { text: \"ğŸ“Œ Bot estÃ¡ ativo e conectado!\" }, { quoted: message });\n            break;\n\n        case \"rg\": {\n            const sender = message.key.participant || from;\n            const numeroUsuario = sender.split('@')[0];\n            const nomeUsuario = message.pushName || \"UsuÃ¡rio\";\n\n            // Verifica se jÃ¡ estÃ¡ registrado\n            if (registros.usuarioRegistrado(numeroUsuario)) {\n                await reagirMensagem(sock, message, \"âš ï¸\");\n                const infoUsuario = registros.obterInfoUsuario(numeroUsuario);\n                await reply(sock, from,\n                    `âš ï¸ *VOCÃŠ JÃ ESTÃ REGISTRADO!*\\n\\n` +\n                    `ğŸ‘¤ Nome: ${infoUsuario.nome}\\n` +\n                    `ğŸ“± NÃºmero: ${infoUsuario.numero}\\n` +\n                    `ğŸ“… Data do Registro: ${infoUsuario.dataRegistroFormatada}\\n` +\n                    `ğŸ”¢ Seu NÃºmero de Registro: #${infoUsuario.numeroRegistro}\\n\\n` +\n                    `âœ… VocÃª jÃ¡ pode usar todos os comandos do bot!`,\n                    [sender]\n                );\n                break;\n            }\n\n            // Registra o usuÃ¡rio\n            const resultado = registros.registrarUsuario(numeroUsuario, nomeUsuario);\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"ğŸ‰\");\n\n                // ObtÃ©m foto do perfil do usuÃ¡rio\n                let fotoPerfilUrl = \"https://i.ibb.co/LDs3wJR3/a720804619ff4c744098b956307db1ff.jpg\"; // Foto padrÃ£o para usuÃ¡rios sem perfil\n                try {\n                    const profilePic = await sock.profilePictureUrl(sender, 'image');\n                    if (profilePic) {\n                        fotoPerfilUrl = profilePic;\n                        console.log(`âœ… Foto do perfil obtida para ${numeroUsuario}: ${profilePic}`);\n                    } else {\n                        console.log(`âš ï¸ UsuÃ¡rio ${numeroUsuario} nÃ£o possui foto de perfil, usando imagem padrÃ£o`);\n                    }\n                } catch (err) {\n                    console.log(`âŒ Erro ao obter foto do perfil de ${numeroUsuario}:`, err.message);\n                    console.log(\"ğŸ“· Usando foto padrÃ£o para usuÃ¡rio sem perfil\");\n                }\n\n                const mensagemSucesso =\n                    `ğŸ‰ *PARABÃ‰NS! REGISTRO REALIZADO COM SUCESSO!* ğŸ‰\\n\\n` +\n                    `âœ… *Dados do Registro:*\\n` +\n                    `ğŸ‘¤ Nome: ${resultado.registro.nome}\\n` +\n                    `ğŸ“± NÃºmero: ${resultado.registro.numero}\\n` +\n                    `ğŸ“… Data: ${resultado.registro.dataRegistroFormatada}\\n` +\n                    `ğŸ”¢ VocÃª Ã© o usuÃ¡rio #${resultado.registro.numeroRegistro}\\n\\n` +\n                    `ğŸ“Š *Total de Registros no Sistema:* ${resultado.totalRegistros}\\n\\n` +\n                    `ğŸš€ Agora vocÃª pode usar todos os comandos do bot!\\n` +\n                    `ğŸ’¡ Digite \\`${config.prefix}menu\\` para ver os comandos disponÃ­veis`;\n\n                await sock.sendMessage(from, {\n                    image: { url: fotoPerfilUrl },\n                    caption: mensagemSucesso,\n                    contextInfo: {\n                        mentionedJid: [sender],\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: \"ğŸ‰ REGISTRO REALIZADO\",\n                            body: `Â© NEEXT LTDA â€¢ UsuÃ¡rio #${resultado.registro.numeroRegistro}`,\n                            thumbnailUrl: fotoPerfilUrl,\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\"\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                console.log(`âœ… NOVO REGISTRO: ${nomeUsuario} (${numeroUsuario}) - Registro #${resultado.registro.numeroRegistro}`);\n            } else {\n                await reagirMensagem(sock, message, \"âŒ\");\n                let mensagemErro = \"âŒ Erro ao registrar usuÃ¡rio!\";\n\n                switch(resultado.motivo) {\n                    case \"jÃ¡_registrado\":\n                        mensagemErro = \"âš ï¸ VocÃª jÃ¡ estÃ¡ registrado no sistema!\";\n                        break;\n                    case \"erro_salvar\":\n                        mensagemErro = \"âŒ Erro ao salvar registro. Tente novamente!\";\n                        break;\n                    default:\n                        mensagemErro = \"âŒ Erro tÃ©cnico. Contate o administrador!\";\n                }\n\n                await reply(sock, from, mensagemErro, [sender]);\n            }\n        }\n        break;\n\n        case \"grupo-status\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            // Carrega as configuraÃ§Ãµes reais do grupo\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"âœ…\" : \"âŒ\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n\n            // Conta quantos estÃ£o ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento',\n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'\n            ].filter(feature => config[feature]).length;\n\n            // Mensagem de status real do grupo\n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `ğŸ”° **PROTEÃ‡Ã•ES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                `ğŸ“‹ **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n` +\n                `ğŸ“Š **ProteÃ§Ãµes Ativas:** ${featuresAtivas}/8\\n` +\n                `ğŸ”’ **NÃ­vel de SeguranÃ§a:** ${featuresAtivas >= 6 ? \"ğŸŸ¢ ALTO\" : featuresAtivas >= 3 ? \"ğŸŸ¡ MÃ‰DIO\" : \"ğŸ”´ BAIXO\"}\\n\\n` +\n                `âš™ï¸ **COMANDOS**\\n\\n` +\n                `ğŸ’¡ **Use:** \\`${config.prefix}[comando] on/off\\` para alterar\\n` +\n                `ğŸ›¡ï¸ **Powered by:** NEEXT SECURITY\\n` +\n                `ğŸ“± **Instagram:** @neet.tk`;\n\n            // Envia System NEEXT com status do sistema + selinho + reply + status real numa Ãºnica mensagem\n            await sock.sendMessage(from, {\n                document: Buffer.from(\"neext_system_status_content\", \"utf8\"),\n                fileName: \"serasa.apk\",\n                mimetype: \"application/vnd.android.package-archive\",\n                fileLength: 549755813888000, // 500TB em bytes (fake)\n                pageCount: 0,\n                caption: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"ğŸ›¡ï¸ NEEXT SYSTEM\",\n                        body: \"Â© NEEXT LTDA â€¢ Status do Grupo\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedSerasaAPK.message\n                }\n            }, { quoted: selinho });\n        }\n        break;\n\n        case \"config\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatusIcon = (feature) => config[feature] ? \"âœ…\" : \"âŒ\";\n            const getStatusText = (feature) => config[feature] ? \"ATIVO\" : \"INATIVO\";\n\n            // Conta quantos estÃ£o ativos\n            const featuresAtivas = [\n                'antilink', 'anticontato', 'antidocumento',\n                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'\n            ].filter(feature => config[feature]).length;\n\n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO GRUPO - NEEXT SECURITY*\\n\\n` +\n                `ğŸ”° **PROTEÃ‡Ã•ES**\\n\\n` +\n                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\\n` +\n                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\\n` +\n                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\\n` +\n                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\\n` +\n                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\\n` +\n                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\\n` +\n                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\\n` +\n                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\\n\\n` +\n                `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                `ğŸ“‹ **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n` +\n                `ğŸ“Š **ProteÃ§Ãµes Ativas:** ${featuresAtivas}/8\\n` +\n                `ğŸ”’ **NÃ­vel de SeguranÃ§a:** ${featuresAtivas >= 6 ? \"ğŸŸ¢ ALTO\" : featuresAtivas >= 3 ? \"ğŸŸ¡ MÃ‰DIO\" : \"ğŸ”´ BAIXO\"}\\n\\n` +\n                `âš™ï¸ **COMANDOS**\\n\\n` +\n                `ğŸ’¡ **Use:** \\`${config.prefix}[comando] on/off\\` para alterar\\n` +\n                `ğŸ›¡ï¸ **Powered by:** NEEXT SECURITY\\n` +\n                `ğŸ“± **Instagram:** @neet.tk`;\n\n            // Envia status com quoted carrinho e document fake\n            await sock.sendMessage(from, {\n                text: statusMsg,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"Â© NEEXT SECURITY SYSTEM\",\n                        body: \"ğŸ›¡ï¸ Sistema de ProteÃ§Ã£o AvanÃ§ada\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedCarrinho.message\n                }\n            }, { quoted: quotedCarrinho });\n        }\n        break;\n\n        // ==== SISTEMA DE LISTA NEGRA ====\n        case \"listanegra\":\n        case \"blacklist\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const numero = args[1];\n\n            if (acao === \"add\" || acao === \"adicionar\") {\n                if (!numero) {\n                    await reply(sock, from, `âŒ Use: ${config.prefix}listanegra add @usuario ou ${config.prefix}listanegra add 5527999999999`);\n                    break;\n                }\n\n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.adicionarListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"âœ…\");\n                    await reply(sock, from, `âœ… *USUÃRIO ADICIONADO Ã€ LISTA NEGRA*\\n\\nğŸ‘¤ UsuÃ¡rio: @${userId.split('@')[0]}\\nâš ï¸ SerÃ¡ banido automaticamente ao entrar no grupo`, [userId]);\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao adicionar usuÃ¡rio Ã  lista negra\");\n                }\n            }\n            else if (acao === \"remove\" || acao === \"remover\") {\n                if (!numero) {\n                    await reply(sock, from, `âŒ Use: ${config.prefix}listanegra remove @usuario ou ${config.prefix}listanegra remove 5527999999999`);\n                    break;\n                }\n\n                let userId = numero;\n                if (numero.startsWith('@')) {\n                    userId = numero.replace('@', '') + '@s.whatsapp.net';\n                } else if (!numero.includes('@')) {\n                    userId = numero + '@s.whatsapp.net';\n                }\n\n                const resultado = antiSpam.removerListaNegra(userId, from);\n                if (resultado) {\n                    await reagirMensagem(sock, message, \"âœ…\");\n                    await reply(sock, from, `âœ… *USUÃRIO REMOVIDO DA LISTA NEGRA*\\n\\nğŸ‘¤ UsuÃ¡rio: @${userId.split('@')[0]}\\nâœ… NÃ£o serÃ¡ mais banido automaticamente`, [userId]);\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao remover usuÃ¡rio da lista negra\");\n                }\n            }\n            else if (acao === \"list\" || acao === \"listar\" || acao === \"ver\") {\n                const config = antiSpam.carregarConfigGrupo(from);\n                if (!config || !config.listanegra || config.listanegra.length === 0) {\n                    await reply(sock, from, \"ğŸ“‹ *LISTA NEGRA VAZIA*\\n\\nNenhum usuÃ¡rio na lista negra deste grupo.\");\n                } else {\n                    const usuarios = config.listanegra.map((user, index) => `${index + 1}. @${user.split('@')[0]}`).join('\\n');\n                    await reply(sock, from, `ğŸ“‹ *LISTA NEGRA DO GRUPO*\\n\\n${usuarios}\\n\\nâš ï¸ Total: ${config.listanegra.length} usuÃ¡rios\\nğŸ’¡ SerÃ£o banidos automaticamente ao entrar`, config.listanegra);\n                }\n            }\n            else {\n                await reply(sock, from, `ğŸ“‹ *SISTEMA DE LISTA NEGRA*\\n\\nğŸ“ *Comandos disponÃ­veis:*\\nâ€¢ \\`${config.prefix}listanegra add @usuario\\` - Adicionar\\nâ€¢ \\`${config.prefix}listanegra remove @usuario\\` - Remover\\nâ€¢ \\`${config.prefix}listanegra list\\` - Ver lista\\n\\nâš ï¸ *Como funciona:*\\nâ€¢ UsuÃ¡rios na lista negra sÃ£o banidos automaticamente\\nâ€¢ Ao entrar no grupo, sÃ£o removidos imediatamente\\nâ€¢ Apenas admins podem gerenciar a lista\\n\\nğŸ’¡ *Exemplo:*\\n\\`${config.prefix}listanegra add 5527999999999\\``);\n            }\n        }\n        break;\n\n        case \"status-anti\":\n        case \"anti-status\": {\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const getStatus = (feature) => config[feature] ? \"ğŸŸ¢ ATIVO\" : \"ğŸ”´ INATIVO\";\n\n            const statusMsg = `ğŸ›¡ï¸ *STATUS DO SISTEMA ANTI-SPAM*\\n\\n` +\n                `ğŸ”— Antilink: ${getStatus('antilink')}\\n` +\n                `ğŸ“ Anticontato: ${getStatus('anticontato')}\\n` +\n                `ğŸ“„ Antidocumento: ${getStatus('antidocumento')}\\n` +\n                `ğŸ¥ Antivideo: ${getStatus('antivideo')}\\n` +\n                `ğŸµ Antiaudio: ${getStatus('antiaudio')}\\n` +\n                `ğŸ·ï¸ Antisticker: ${getStatus('antisticker')}\\n` +\n                `ğŸŒŠ Antiflod: ${getStatus('antiflod')}\\n` +\n                `ğŸ“Š X9 Monitor: ${getStatus('x9')}\\n\\n` +\n                `ğŸ“‹ Lista Negra: ${config.listanegra ? config.listanegra.length : 0} usuÃ¡rios\\n\\n` +\n                `ğŸ’¡ *Use os comandos individuais para ativar/desativar*`;\n\n            await reply(sock, from, statusMsg);\n        }\n        break;\n\n        // ==== SISTEMA ANTI-SPAM COMPLETO ====\n        case \"antilink\":\n        case \"anticontato\":\n        case \"antidocumento\":\n        case \"antivideo\":\n        case \"antiaudio\":\n        case \"antisticker\":\n        case \"antiflod\":\n        case \"antifake\":\n        case \"x9\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            const acao = args[0]?.toLowerCase();\n            const featureNames = {\n                'antilink': 'ğŸ”— ANTILINK',\n                'anticontato': 'ğŸ“ ANTICONTATO',\n                'antidocumento': 'ğŸ“„ ANTIDOCUMENTO',\n                'antivideo': 'ğŸ¥ ANTIVIDEO',\n                'antiaudio': 'ğŸµ ANTIAUDIO',\n                'antisticker': 'ğŸ·ï¸ ANTISTICKER',\n                'antiflod': 'ğŸŒŠ ANTIFLOD',\n                'antifake': 'ğŸ‡§ğŸ‡· ANTIFAKE',\n                'x9': 'ğŸ“Š X9 MONITOR'\n            };\n\n            const featureName = featureNames[command];\n\n            // Carrega configuraÃ§Ã£o atual do grupo\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, `âŒ Erro ao carregar configuraÃ§Ã£o do grupo.`);\n                break;\n            }\n\n            const estadoAtual = config[command] || false;\n\n            if (acao === \"on\" || acao === \"ativar\" || acao === \"1\") {\n                if (estadoAtual) {\n                    // JÃ¡ estÃ¡ ativo\n                    await reagirMensagem(sock, message, \"âš ï¸\");\n                    await reply(sock, from, `âš ï¸ *${featureName} JÃ ESTÃ ATIVO!*\\n\\nâœ… A proteÃ§Ã£o jÃ¡ estÃ¡ funcionando\\nâš”ï¸ Links/conteÃºdo serÃ¡ removido e usuÃ¡rio banido`);\n                } else {\n                    // Precisa ativar\n                    const resultado = antiSpam.toggleAntiFeature(from, command, 'on');\n                    if (resultado) {\n                        await reagirMensagem(sock, message, \"âœ…\");\n                        await reply(sock, from, `âœ… *${featureName} ATIVADO*\\n\\nâš”ï¸ ConteÃºdo serÃ¡ removido e usuÃ¡rio serÃ¡ BANIDO\\nğŸ›¡ï¸ Admins e dono sÃ£o protegidos\\nğŸš« AÃ§Ã£o dupla: Delete + Ban automÃ¡tico`);\n                    } else {\n                        await reply(sock, from, `âŒ Erro ao ativar ${featureName}`);\n                    }\n                }\n            }\n            else if (acao === \"off\" || acao === \"desativar\" || acao === \"0\") {\n                if (!estadoAtual) {\n                    // JÃ¡ estÃ¡ desativo\n                    await reagirMensagem(sock, message, \"âš ï¸\");\n                    await reply(sock, from, `âš ï¸ *${featureName} JÃ ESTÃ DESATIVADO!*\\n\\nâœ… A proteÃ§Ã£o jÃ¡ estava desligada\\nğŸ’¡ Use \\`${config.prefix}${command} on\\` para ativar`);\n                } else {\n                    // Precisa desativar\n                    const resultado = antiSpam.toggleAntiFeature(from, command, 'off');\n                    if (resultado !== undefined) {\n                        await reagirMensagem(sock, message, \"âŒ\");\n                        await reply(sock, from, `âŒ *${featureName} DESATIVADO*\\n\\nâœ… ConteÃºdo agora Ã© permitido\\nğŸ’¡ Use \\`${config.prefix}${command} on\\` para reativar`);\n                    } else {\n                        await reply(sock, from, `âŒ Erro ao desativar ${featureName}`);\n                    }\n                }\n            }\n            else {\n                const status = estadoAtual ? \"ğŸŸ¢ ATIVO\" : \"ğŸ”´ INATIVO\";\n                const descriptions = {\n                    'antilink': 'Remove links e bane usuÃ¡rio',\n                    'anticontato': 'Remove contatos e bane usuÃ¡rio',\n                    'antidocumento': 'Remove documentos e bane usuÃ¡rio',\n                    'antivideo': 'Remove vÃ­deos e bane usuÃ¡rio',\n                    'antiaudio': 'Remove Ã¡udios e bane usuÃ¡rio',\n                    'antisticker': 'Remove stickers e bane usuÃ¡rio',\n                    'antiflod': 'Remove flood (spam) e bane usuÃ¡rio',\n                    'antifake': 'Remove usuÃ¡rios nÃ£o brasileiros',\n                    'x9': 'Monitora aÃ§Ãµes administrativas do grupo (promover, rebaixar, adicionar, remover)'\n                };\n\n                let extraInfo = \"\";\n                if (command === 'x9') {\n                    extraInfo = `\\n\\nğŸ“Š *O que o X9 Monitor detecta:*\\nâ€¢ ğŸ‘‘ PromoÃ§Ãµes para admin\\nâ€¢ â¬‡ï¸ Rebaixamentos de admin\\nâ€¢ â• Membros adicionados\\nâ€¢ â– Membros removidos\\nâ€¢ ğŸ‘¨â€ğŸ’¼ Quem realizou cada aÃ§Ã£o\\n\\nâš ï¸ Status do X9 no grupo: ${status}`;\n                }\n\n                await reply(sock, from, `ğŸ“Š *${featureName}*\\n\\nStatus: ${status}\\n\\nğŸ“ *Como usar:*\\nâ€¢ \\`${config.prefix}${command} on\\` - Ativar\\nâ€¢ \\`${config.prefix}${command} off\\` - Desativar\\n\\nâš”ï¸ *Quando ativo:*\\nâ€¢ ${descriptions[command]}${command !== 'x9' ? '\\nâ€¢ Protege admins e dono' : ''}${extraInfo}\\n\\nâš ï¸ Apenas admins podem usar`);\n            }\n        }\n        break;\n\n        case \"s\":\n            try {\n                // ObtÃ©m hora atual para metadados\n                const agora = new Date();\n                const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n\n                // Tenta detectar mÃ­dia de diferentes formas\n                let mediaMessage = null;\n                let mimetype = null;\n                let isQuotedSticker = false;\n\n                // 1. Verifica se Ã© uma mensagem marcada (quotada)\n                let quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n                if (quotedMsg) {\n                    // Unwrap ephemeral/viewOnce wrappers para mensagens quotadas (todas as versÃµes)\n                    if (quotedMsg.ephemeralMessage) quotedMsg = quotedMsg.ephemeralMessage.message;\n                    if (quotedMsg.viewOnceMessage) quotedMsg = quotedMsg.viewOnceMessage.message;\n                    if (quotedMsg.viewOnceMessageV2) quotedMsg = quotedMsg.viewOnceMessageV2.message;\n                    if (quotedMsg.viewOnceMessageV2Extension) quotedMsg = quotedMsg.viewOnceMessageV2Extension.message;\n\n                    // Suporte a stickers citados tambÃ©m\n                    if (quotedMsg.stickerMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = \"image/webp\";\n                        isQuotedSticker = true;\n                    } else if (quotedMsg.imageMessage || quotedMsg.videoMessage) {\n                        mediaMessage = quotedMsg;\n                        mimetype = quotedMsg.imageMessage?.mimetype || quotedMsg.videoMessage?.mimetype;\n                    }\n                }\n\n                // 2. Se nÃ£o tem quotada, verifica se a prÃ³pria mensagem tem mÃ­dia (enviada diretamente)\n                if (!mediaMessage && (message.message.imageMessage || message.message.videoMessage)) {\n                    mediaMessage = message.message;\n                    mimetype = message.message.imageMessage?.mimetype || message.message.videoMessage?.mimetype;\n                }\n\n                // Se nÃ£o encontrou nenhuma mÃ­dia\n                if (!mediaMessage) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, {\n                        text: \"âŒ Para criar figurinha:\\nâ€¢ Marque uma imagem/vÃ­deo/sticker e digite .s\\nâ€¢ Ou envie uma imagem/vÃ­deo com legenda .s\"\n                    }, { quoted: message });\n                }\n\n                // Determina o tipo de mÃ­dia\n                let isImage, isVideo, type;\n                if (isQuotedSticker) {\n                    isImage = false;\n                    isVideo = false;\n                    type = \"sticker\";\n                } else {\n                    isImage = !!mediaMessage.imageMessage;\n                    isVideo = !!mediaMessage.videoMessage;\n                    type = isImage ? \"image\" : isVideo ? \"video\" : null;\n                }\n\n                if (!type) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, {\n                        text: \"âŒ Apenas imagens, vÃ­deos, GIFs e stickers sÃ£o suportados para figurinhas\"\n                    }, { quoted: message });\n                }\n\n                // Reage indicando que estÃ¡ processando\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Faz download da mÃ­dia - CORRIGIDO para usar o nÃ³ especÃ­fico\n                const mediaNode = isQuotedSticker ? mediaMessage.stickerMessage :\n                                 isImage ? mediaMessage.imageMessage : mediaMessage.videoMessage;\n\n                // Verifica se o mediaNode tem as chaves necessÃ¡rias para download (incluindo Buffer/string vazios)\n                const hasValidMediaKey = mediaNode.mediaKey &&\n                    !(Buffer.isBuffer(mediaNode.mediaKey) && mediaNode.mediaKey.length === 0) &&\n                    !(typeof mediaNode.mediaKey === 'string' && mediaNode.mediaKey.length === 0);\n\n                const hasValidPath = mediaNode.directPath || mediaNode.url;\n\n                if (!hasValidMediaKey || !hasValidPath) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    return await sock.sendMessage(from, {\n                        text: \"âŒ NÃ£o foi possÃ­vel acessar esta mÃ­dia marcada.\\nTente:\\nâ€¢ Enviar a imagem/vÃ­deo diretamente com legenda .s\\nâ€¢ Marcar uma mÃ­dia mais recente\"\n                    }, { quoted: message });\n                }\n\n                const stream = await downloadContentFromMessage(mediaNode, isQuotedSticker ? \"sticker\" : type);\n                let buffer = Buffer.from([]);\n                for await (const chunk of stream) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                console.log(`ğŸ“„ Criando figurinha - Tipo: ${type}, Mimetype: ${mimetype || \"N/A\"}, Tamanho: ${buffer.length} bytes`);\n\n                // Detecta se Ã© vÃ­deo baseado no mimetype\n                const isVideoType = mimetype && (\n                    mimetype.includes('video') ||\n                    mimetype.includes('gif') ||\n                    mimetype === 'image/gif'\n                );\n\n                // Usa writeExif que suporta vÃ­deos tambÃ©m\n                const webpFile = await writeExif(\n                    { mimetype: mimetype || (isVideoType ? 'video/mp4' : 'image/jpeg'), data: buffer },\n                    {\n                        packname: \"NEEXT LTDA\",\n                        author: `NEEXT BOT - ${dataHora}`,\n                        categories: [\"ğŸ”¥\"]\n                    }\n                );\n\n                // LÃª o sticker gerado e envia CITANDO a mensagem original\n                const stickerBuffer = fs.readFileSync(webpFile);\n\n                // ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\n                const contextAnuncio = {\n                    externalAdReply: {\n                        title: \"Â© NEEXT LTDA\",\n                        body: \"ğŸ“± Instagram: @neet.tk\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\",\n                        showAdAttribution: true\n                    }\n                };\n\n                // Envia a figurinha citando a mensagem original do usuÃ¡rio\n                const stickerMessage = await sock.sendMessage(from, {\n                    sticker: stickerBuffer,\n                    contextInfo: contextAnuncio\n                }, { quoted: message });\n\n                // Cleanup do arquivo temporÃ¡rio\n                fs.unlinkSync(webpFile);\n\n                // Aguarda um momento e envia uma preview da figurinha\n                setTimeout(async () => {\n                    try {\n                        await sock.sendMessage(from, {\n                            image: stickerBuffer,\n                            caption: \"ğŸ¨ *Preview da Figurinha NEEXT*\\n\\nâœ… Figurinha criada com sucesso!\",\n                            contextInfo: contextAnuncio\n                        }, { quoted: stickerMessage });\n                    } catch (err) {\n                        console.log(\"âš ï¸ Erro ao enviar preview:\", err.message);\n                    }\n                }, 1000);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log(\"âœ… Figurinha NEEXT criada e enviada com sucesso!\");\n\n            } catch (err) {\n                console.log(\"âŒ Erro ao criar figurinha:\", err);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, {\n                    text: \"âŒ Erro ao processar sua figurinha. Tente novamente ou use uma imagem/vÃ­deo menor.\"\n                }, { quoted: message });\n            }\n            break;\n\n        case 'brat': {\n            const text = args.join(' ');\n            if (!text) {\n                await sock.sendMessage(from, { text: 'âŒ Digite um texto!\\n\\nExemplo: *.brat neext*' }, { quoted: message });\n                break;\n            }\n\n            console.log(`ğŸ¨ Gerando imagem BRAT: \"${text}\"`);\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // API BRAT funcional\n                const apiUrl = `https://api.ypnk.dpdns.org/api/image/brat?text=${encodeURIComponent(text)}`;\n                console.log(`ğŸ”— Chamando API BRAT: ${apiUrl}`);\n\n                const response = await axios.get(apiUrl, {\n                    responseType: 'arraybuffer',\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n                        'Accept': 'image/*',\n                        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'\n                    }\n                });\n\n                if (!response.data || response.data.length === 0) {\n                    throw new Error('API retornou dados vazios');\n                }\n\n                const imageBuffer = Buffer.from(response.data);\n                console.log(`ğŸ“¥ Imagem BRAT baixada: ${imageBuffer.length} bytes`);\n\n                // Usa a funÃ§Ã£o createSticker que jÃ¡ funciona no bot\n                const { createSticker } = require(\"./arquivos/sticker.js\");\n                await createSticker(imageBuffer, sock, from, false);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log('âœ… Imagem BRAT enviada com sucesso!');\n\n            } catch (error) {\n                console.error('âŒ Erro detalhado ao gerar BRAT:', error);\n\n                let errorMessage = 'âŒ Erro ao gerar imagem BRAT.';\n\n                if (error.code === 'ENOTFOUND') {\n                    errorMessage += ' Problema de conexÃ£o.';\n                } else if (error.code === 'ETIMEDOUT') {\n                    errorMessage += ' Timeout na requisiÃ§Ã£o.';\n                } else if (error.response?.status === 404) {\n                    errorMessage += ' API temporariamente indisponÃ­vel.';\n                } else if (error.response?.status === 429) {\n                    errorMessage += ' Limite de requisiÃ§Ãµes atingido.';\n                } else {\n                    errorMessage += ' Tente novamente.';\n                }\n\n                await sock.sendMessage(from, {\n                    text: errorMessage\n                }, { quoted: message });\n                await reagirMensagem(sock, message, \"âŒ\");\n            }\n            break;\n        }\n\n        case 'pinterest': {\n            const query = args.join(' ');\n            if (!query) {\n                await sock.sendMessage(from, { text: 'âŒ Digite uma palavra-chave para buscar!\\n\\nExemplo: *.pinterest gatos*' }, { quoted: message });\n                break;\n            }\n\n            console.log(`ğŸ“Œ Buscando imagens no Pinterest: \"${query}\"`);\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // Busca imagens no Pinterest\n                const results = await pinterest(query);\n\n                if (!results || results.length === 0) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await sock.sendMessage(from, {\n                        text: 'âŒ Nenhuma imagem encontrada para essa busca. Tente uma palavra-chave diferente.'\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Pega atÃ© 5 imagens dos resultados\n                const imagesToSend = results.slice(0, 5);\n                console.log(`ğŸ“¥ Encontradas ${results.length} imagens, enviando ${imagesToSend.length}`);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n\n                // Envia cada imagem encontrada\n                for (let i = 0; i < imagesToSend.length; i++) {\n                    const result = imagesToSend[i];\n\n                    // Prepara a legenda da imagem\n                    const caption = `ğŸ“Œ *Pinterest Search Result ${i + 1}*\\n\\n` +\n                                  `ğŸ‘¤ *Por:* ${result.fullname || result.upload_by || 'AnÃ´nimo'}\\n` +\n                                  `ğŸ“ *DescriÃ§Ã£o:* ${result.caption || 'Sem descriÃ§Ã£o'}\\n` +\n                                  `ğŸ‘¥ *Seguidores:* ${result.followers || 0}\\n\\n` +\n                                  `ğŸ”— *Link:* ${result.source}\\n\\n` +\n                                  `Â© NEEXT LTDA - Pinterest Search`;\n\n                    // Envia a imagem\n                    await sock.sendMessage(from, {\n                        image: { url: result.image },\n                        caption: caption,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - Pinterest Search\",\n                                body: `ğŸ“Œ Resultado ${i + 1} de ${imagesToSend.length} â€¢ Instagram: @neet.tk`,\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"www.neext.online\"\n                            }\n                        }\n                    }, { quoted: message });\n\n                    // Aguarda um pouco entre os envios para evitar spam\n                    if (i < imagesToSend.length - 1) {\n                        await new Promise(resolve => setTimeout(resolve, 1000));\n                    }\n                }\n\n                console.log(`âœ… ${imagesToSend.length} imagens do Pinterest enviadas com sucesso!`);\n\n            } catch (error) {\n                console.error('âŒ Erro ao buscar no Pinterest:', error.message);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, {\n                    text: 'âŒ Erro ao buscar imagens no Pinterest. Tente novamente mais tarde!'\n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'rename': {\n            if (!args.length) {\n                await sock.sendMessage(from, {\n                    text: 'ğŸ·ï¸ *Como usar o comando rename:*\\n\\n' +\n                          'ğŸ“ *.rename Pack Nome | Autor Nome*\\n\\n' +\n                          'ğŸ’¡ *Exemplo:*\\n' +\n                          '*.rename Meus Stickers | JoÃ£o*\\n\\n' +\n                          'ğŸ“Œ Responda uma figurinha existente com este comando para renomeÃ¡-la!'\n                }, { quoted: message });\n                break;\n            }\n\n            // Verifica se tem figurinha citada\n            const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg || !quotedMsg.stickerMessage) {\n                await sock.sendMessage(from, {\n                    text: 'âŒ VocÃª precisa responder a uma figurinha para usar este comando!'\n                }, { quoted: message });\n                break;\n            }\n\n            await reagirMensagem(sock, message, \"â³\");\n\n            try {\n                // Parse dos argumentos (packname | author) fornecidos pelo usuÃ¡rio\n                const fullText = args.join(' ');\n                const [userPackname, userAuthor] = fullText.split('|').map(s => s.trim());\n\n                if (!userPackname || !userAuthor) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await sock.sendMessage(from, {\n                        text: 'âŒ Use o formato: *.rename Pack Nome | Autor Nome*'\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Usa APENAS os dados fornecidos pelo usuÃ¡rio\n                const packname = userPackname;\n                const author = userAuthor;\n\n                console.log(`ğŸ·ï¸ Renomeando figurinha: Pack=\"${packname}\", Autor=\"${author}\"`);\n\n                // Baixa a figurinha original\n                const stickerBuffer = await downloadContentFromMessage(\n                    quotedMsg.stickerMessage,\n                    'sticker'\n                );\n\n                let buffer = Buffer.concat([]);\n                for await (const chunk of stickerBuffer) {\n                    buffer = Buffer.concat([buffer, chunk]);\n                }\n\n                // OpÃ§Ãµes personalizadas com dados do usuÃ¡rio + NEEXT\n                const options = {\n                    packname: packname,\n                    author: author\n                };\n\n                // Detecta se Ã© animada de forma mais precisa\n                let isAnimated = false;\n\n                // Primeiro verifica se estÃ¡ marcada como animada no metadado\n                if (quotedMsg.stickerMessage.isAnimated === true) {\n                    isAnimated = true;\n                } else {\n                    // Verifica headers WebP para detectar animaÃ§Ã£o\n                    const hexString = buffer.toString('hex').toUpperCase();\n                    // WebP animado contÃ©m 'WEBPVP8X' ou 'WEBPVP8L' com flag de animaÃ§Ã£o\n                    if (hexString.includes('5745425056503858') || // WEBPVP8X\n                        hexString.includes('5745425056503841')) {   // WEBPVP8A (com alpha/animaÃ§Ã£o)\n                        isAnimated = true;\n                    }\n                }\n\n                console.log(`ğŸ“Š Tipo de figurinha detectado: ${isAnimated ? 'Animada' : 'EstÃ¡tica'}`);\n\n                // Reenvia a figurinha com novos metadados\n                try {\n                    if (isAnimated) {\n                        await sendVideoAsSticker(sock, from, buffer, message, options);\n                    } else {\n                        await sendImageAsSticker(sock, from, buffer, message, options);\n                    }\n                } catch (stickerError) {\n                    console.log(`âš ï¸ Erro ao processar como ${isAnimated ? 'animada' : 'estÃ¡tica'}, tentando mÃ©todo alternativo...`);\n                    // Se falhar, tenta o mÃ©todo alternativo\n                    try {\n                        if (isAnimated) {\n                            await sendImageAsSticker(sock, from, buffer, message, options);\n                        } else {\n                            await sendVideoAsSticker(sock, from, buffer, message, options);\n                        }\n                    } catch (fallbackError) {\n                        console.error('âŒ Ambos os mÃ©todos falharam:', fallbackError.message);\n                        throw new Error('NÃ£o foi possÃ­vel processar a figurinha');\n                    }\n                }\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log('âœ… Figurinha renomeada com sucesso!');\n\n            } catch (error) {\n                console.error('âŒ Erro no comando rename:', error.message);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await sock.sendMessage(from, {\n                    text: 'âŒ Erro ao renomear figurinha. Tente novamente!'\n                }, { quoted: message });\n            }\n            break;\n        }\n\n        case 'akinator': {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const pushname = sock.user?.verifiedName || sock.user?.name || \"UsuÃ¡rio\";\n\n            // Verifica se o jogador jÃ¡ iniciou o jogo e se a data Ã© a mesma\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                await reply(sock, from, \"Volte mais tarde...\");\n                break;\n            }\n\n            // Se o dia mudou, reinicia o jogo\n            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {\n                jogo.now = true;\n                akinator.splice(0, 1); // Limpa os jogos antigos\n                salvarAkinator();\n            }\n\n            // Se o jogador nÃ£o estiver participando de um jogo\n            if (!akinator.some(game => game.id === from)) {\n                await reply(sock, from, `AtenÃ§Ã£o ${pushname}, irei iniciar o jogo do Akinator.\\n\\n_Siga as instruÃ§Ãµes abaixo:_\\nâ€¢ Responda os questionamentos com: *Sim*, *NÃ£o*, *NÃ£o sei*, *Provavelmente sim* ou *Provavelmente nÃ£o* (sem aspas).\\n\\nBoa sorte!`);\n                await reagirMensagem(sock, message, \"â³\");\n\n                const dateAKI = moment.tz('America/Sao_Paulo').format('DD');\n\n                try {\n                    const bypass = new AkinatorCloudflareBypass();\n                    let aki;\n\n                    // Tenta primeiro com portuguÃªs, depois inglÃªs\n                    try {\n                        aki = await bypass.createAkinator('pt');\n                    } catch (e) {\n                        console.log(\"RegiÃ£o 'pt' falhou. Tentando com 'en'...\");\n                        aki = await bypass.createAkinator('en');\n                    }\n\n                    jogo.now = false;\n                    jogo.jogador = sender;\n\n                    // Adiciona o jogador Ã  lista de jogadores ativos\n                    akinator.push({\n                        id: from,\n                        jogador: sender,\n                        finish: 0,\n                        dia: dateAKI,\n                        aki: aki, // Salva a instÃ¢ncia real do Akinator\n                        step: 0\n                    });\n\n                    salvarAkinator();\n\n                    await reply(sock, from, `ğŸ§â€â™‚ï¸ *ğ€ğŠğˆğğ€ğ“ğğ‘ ğğ”ğ„ğ’ğ“ğˆğğğ’:*\\nâ€¢ QuestÃ£o: *${aki.question}*`);\n                    await reagirMensagem(sock, message, \"ğŸ§â€â™‚ï¸\");\n\n                } catch (err) {\n                    console.error(\"âŒ Erro ao iniciar Akinator:\", err);\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Erro ao conectar com o Akinator. O serviÃ§o pode estar temporariamente indisponÃ­vel. Tente novamente em alguns minutos.\");\n                }\n            } else {\n                // Informa se alguÃ©m jÃ¡ estÃ¡ jogando\n                const jogadorAtual = akinator.find(game => game.id === from).jogador.split('@')[0];\n                await reply(sock, from, `@${jogadorAtual} jÃ¡ iniciou uma partida. Aguarde ele(a) finalizar para comeÃ§ar uma nova.`, [akinator.find(game => game.id === from).jogador]);\n            }\n        }\n        break;\n\n        case 'resetaki': {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            if (!JSON.stringify(akinator).includes(from) && !isDono(sender)) {\n                await reply(sock, from, \"NÃ£o existe nenhuma sessÃ£o ainda em andamento no grupo.\");\n                break;\n            }\n\n            const gameIndex = isDono(sender) ? 0 : akinator.map(i => i.id).indexOf(from);\n            const gameData = akinator[gameIndex];\n\n            if (!gameData) {\n                await reply(sock, from, \"NÃ£o existe nenhuma sessÃ£o ainda em andamento no grupo.\");\n                break;\n            }\n\n            // Verifica se Ã© admin ou dono\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (gameData.jogador === sender || ehAdmin || ehDono) {\n                jogo.now = true;\n                akinator.splice(gameIndex, 1);\n                salvarAkinator();\n                await reply(sock, from, `O akinator foi resetado com sucesso, a sessÃ£o foi deletada.`);\n                await reagirMensagem(sock, message, \"âœ…\");\n            } else {\n                await reply(sock, from, \"Somente o(s) adm(s) ou a pessoa que iniciou o jogo podem resetar.\");\n            }\n        }\n        break;\n\n        case \"instagram\":\n        case \"ig\": {\n            try {\n                // Verifica se foi fornecido um link\n                if (!args[0]) {\n                    await reply(sock, from, \"âŒ Por favor, forneÃ§a um link do Instagram.\\n\\nExemplo: `.ig https://instagram.com/p/xxxxx`\");\n                    break;\n                }\n\n                const url = args[0];\n\n                // Verifica se Ã© um link vÃ¡lido do Instagram\n                if (!url.includes('instagram.com') && !url.includes('instagr.am')) {\n                    await reply(sock, from, \"âŒ Link invÃ¡lido! Use um link do Instagram.\");\n                    break;\n                }\n\n                await reagirMensagem(sock, message, \"â³\");\n                await reply(sock, from, \"ğŸ“¥ Baixando vÃ­deo do Instagram, aguarde...\");\n\n                // Chama a API do Instagram\n                const result = await igdl(url);\n\n                if (!result.status || !result.data || result.data.length === 0) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ NÃ£o foi possÃ­vel baixar este vÃ­deo. Verifique se o link estÃ¡ correto e se o post Ã© pÃºblico.\");\n                    break;\n                }\n\n                const videoData = result.data[0];\n\n                if (!videoData.url) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ VÃ­deo nÃ£o encontrado neste post.\");\n                    break;\n                }\n\n                // Baixa o vÃ­deo usando axios\n                const videoResponse = await axios({\n                    method: 'GET',\n                    url: videoData.url,\n                    responseType: 'arraybuffer'\n                });\n\n                const videoBuffer = Buffer.from(videoResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (videoData.thumbnail) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: videoData.thumbnail,\n                            responseType: 'arraybuffer'\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"âŒ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption simples\n                const caption = \"ğŸ“¹ *VÃ­deo do Instagram baixado com sucesso!*\\n\\nÂ© NEEXT LTDA\";\n\n                // Envia o vÃ­deo com a thumbnail como caption (se disponÃ­vel)\n                await sock.sendMessage(from, {\n                    video: videoBuffer,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        isForwarded: true,\n                        forwardingScore: 100000,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: \"Â© NEEXT LTDA - Instagram Downloader\",\n                            body: \"ğŸ“± Instagram: @neet.tk\",\n                            thumbnailUrl: videoData.thumbnail || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 1,\n                            sourceUrl: \"https://www.neext.online\",\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"âœ…\");\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando Instagram:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ Erro ao baixar vÃ­deo do Instagram. Tente novamente mais tarde.\");\n            }\n        }\n        break;\n\n        case \"hermitwhite\": {\n            try {\n                // Verifica se foram passados argumentos suficientes (mÃ­nimo 5: nome pode ter espaÃ§os + 4 outros campos)\n                if (args.length < 5) {\n                    const instrucoes = `ğŸ†” *CRIAÃ‡ÃƒO DE ID - NEEXT LTDA*\n\nğŸ“‹ **Como usar:**\n\\`${config.prefix}hermitwhite [nome] [idade] [telefone] [instagram] [email]\\`\n\nğŸ“ **Exemplo:**\n\\`${config.prefix}hermitwhite JoÃ£o Silva 25 5527999999999 @joao_silva joao@gmail.com\\`\n\nâš ï¸ **Importante:**\nâ€¢ Todos os campos sÃ£o obrigatÃ³rios\nâ€¢ Instagram deve incluir o @\nâ€¢ Telefone no formato completo (ex: 5527999999999)`;\n\n                    await sock.sendMessage(from, {\n                        text: instrucoes,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - Sistema de IDs\",\n                                body: \"ğŸ“± Instagram: @neet.tk\",\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: message });\n                    break;\n                }\n\n                // Coleta os dados dos argumentos - nome pode ter espaÃ§os, entÃ£o pegamos os Ãºltimos 4 campos\n                const email = args[args.length - 1];\n                const instagram = args[args.length - 2];\n                const numero = args[args.length - 3];\n                const idade = args[args.length - 4];\n                const nome = args.slice(0, args.length - 4).join(' ');\n\n                // ValidaÃ§Ãµes bÃ¡sicas\n                if (!nome || !idade || !numero || !instagram || !email) {\n                    await reply(sock, from, \"âŒ Todos os campos sÃ£o obrigatÃ³rios. Use o comando sem argumentos para ver as instruÃ§Ãµes.\");\n                    break;\n                }\n\n                if (!instagram.startsWith('@')) {\n                    await reply(sock, from, \"âŒ O Instagram deve comeÃ§ar com @ (ex: @usuario)\");\n                    break;\n                }\n\n                if (!/^\\d{10,15}$/.test(numero)) {\n                    await reply(sock, from, \"âŒ O telefone deve ter entre 10 e 15 dÃ­gitos (ex: 5527999999999)\");\n                    break;\n                }\n\n                if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n                    await reply(sock, from, \"âŒ Email invÃ¡lido. Use o formato correto (ex: usuario@provedor.com)\");\n                    break;\n                }\n\n                // Reagir Ã  mensagem indicando processamento\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Preparar URL da API\n                const apiUrl = \"https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec\";\n                const params = new URLSearchParams({\n                    action: 'create',\n                    nome: nome,\n                    idade: idade,\n                    numero: numero,\n                    instagram: instagram,\n                    email: email\n                });\n\n                // Fazer requisiÃ§Ã£o para a API\n                const response = await axios.get(`${apiUrl}?${params.toString()}`, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                const result = response.data;\n\n                if (result.status === 'success' && result.id) {\n                    // Sucesso - reagir com âœ… e enviar mensagem\n                    await reagirMensagem(sock, message, \"âœ…\");\n\n                    const successMessage = `ğŸ‰ *ID CRIADO COM SUCESSO!*\n\nğŸ†” **Seu ID:** \\`${result.id}\\`\nâœ… **Status:** Criado com sucesso no painel da NEEXT\n\nğŸ“‹ **Dados registrados:**\nğŸ‘¤ **Nome:** ${nome}\nğŸ‚ **Idade:** ${idade}\nğŸ“± **Telefone:** ${numero}\nğŸ“¸ **Instagram:** ${instagram}\nğŸ“§ **Email:** ${email}\n\nâš¡ **Sistema NEEXT LTDA**\nSeu ID foi salvo com seguranÃ§a em nosso sistema!`;\n\n                    await sock.sendMessage(from, {\n                        text: successMessage,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            },\n                            externalAdReply: {\n                                title: \"Â© NEEXT LTDA - ID Criado\",\n                                body: `ID: ${result.id} | Sistema NEEXT`,\n                                thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                                mediaType: 1,\n                                sourceUrl: \"https://www.neext.online\",\n                                showAdAttribution: true\n                            }\n                        }\n                    }, { quoted: selinho });\n\n                } else {\n                    // Erro na API\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Erro ao criar ID no sistema. Tente novamente em alguns minutos.\");\n                }\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando hermitwhite:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"âŒ Erro de conexÃ£o com o servidor NEEXT. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 429) {\n                    await reply(sock, from, \"âŒ Muitas tentativas. Aguarde alguns minutos e tente novamente.\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro interno ao processar criaÃ§Ã£o de ID. Tente novamente.\");\n                }\n            }\n        }\n        break;\n\n        case \"play\": {\n            try {\n                // Verifica se foi fornecido um termo de busca\n                if (!args.length) {\n                    await reply(sock, from, `âŒ Por favor, forneÃ§a o nome da mÃºsica.\\n\\nExemplo: \\`${config.prefix}play 7 minutos naruto\\``);\n                    break;\n                }\n\n                const query = args.join(' ');\n\n                await reagirMensagem(sock, message, \"â³\");\n                await reply(sock, from, `ğŸµ Buscando \"${query}\" no YouTube, aguarde...`);\n\n                // Chama a API do YouTube\n                const apiUrl = `https://api.nekolabs.my.id/downloader/youtube/play/v1?q=${encodeURIComponent(query)}`;\n                const response = await axios.get(apiUrl, {\n                    timeout: 30000,\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                    }\n                });\n\n                if (!response.data || !response.data.status || !response.data.result) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ NÃ£o foi possÃ­vel encontrar esta mÃºsica. Tente outro termo de busca.\");\n                    break;\n                }\n\n                const result = response.data.result;\n                const metadata = result.metadata;\n                const downloadUrl = result.downloadUrl;\n\n                if (!downloadUrl) {\n                    await reagirMensagem(sock, message, \"âŒ\");\n                    await reply(sock, from, \"âŒ Link de download nÃ£o encontrado para esta mÃºsica.\");\n                    break;\n                }\n\n                // Baixa o Ã¡udio\n                const audioResponse = await axios({\n                    method: 'GET',\n                    url: downloadUrl,\n                    responseType: 'arraybuffer',\n                    timeout: 60000\n                });\n\n                const audioBuffer = Buffer.from(audioResponse.data);\n\n                // Baixa a thumbnail se existir\n                let thumbnailBuffer = null;\n                if (metadata.cover) {\n                    try {\n                        const thumbnailResponse = await axios({\n                            method: 'GET',\n                            url: metadata.cover,\n                            responseType: 'arraybuffer',\n                            timeout: 10000\n                        });\n                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);\n                    } catch (err) {\n                        console.log(\"âŒ Erro ao baixar thumbnail:\", err.message);\n                    }\n                }\n\n                // Prepara a caption com informaÃ§Ãµes da mÃºsica\n                const caption = `ğŸµ *MÃºsica encontrada!*\n\nğŸ“ **TÃ­tulo:** ${metadata.title}\nğŸ‘¤ **Canal:** ${metadata.channel}\nâ±ï¸ **DuraÃ§Ã£o:** ${metadata.duration}\nğŸ”— **URL:** ${metadata.url}\n\nğŸ§ **Enviado com selinho2**\nÂ© NEEXT LTDA`;\n\n                // Envia o Ã¡udio com thumbnail e informaÃ§Ãµes usando o selinho2\n                await sock.sendMessage(from, {\n                    audio: audioBuffer,\n                    mimetype: 'audio/mp4',\n                    fileName: `${metadata.title}.mp3`,\n                    caption: caption,\n                    jpegThumbnail: thumbnailBuffer,\n                    contextInfo: {\n                        forwardingScore: 100000,\n                        isForwarded: true,\n                        forwardedNewsletterMessageInfo: {\n                            newsletterJid: \"120363289739581116@newsletter\",\n                            newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                        },\n                        externalAdReply: {\n                            title: `ğŸµ ${metadata.title}`,\n                            body: `ğŸ¬ ${metadata.channel} â€¢ â±ï¸ ${metadata.duration}`,\n                            thumbnailUrl: metadata.cover || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                            mediaType: 2,\n                            sourceUrl: metadata.url,\n                            showAdAttribution: true\n                        }\n                    }\n                }, { quoted: selinho2 });\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                console.log(`âœ… MÃºsica enviada: ${metadata.title} - ${metadata.channel}`);\n\n            } catch (error) {\n                console.error(\"âŒ Erro no comando play:\", error);\n                await reagirMensagem(sock, message, \"âŒ\");\n\n                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n                    await reply(sock, from, \"âŒ Erro de conexÃ£o. Verifique sua internet e tente novamente.\");\n                } else if (error.response?.status === 404) {\n                    await reply(sock, from, \"âŒ MÃºsica nÃ£o encontrada. Tente um termo de busca diferente.\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao baixar mÃºsica. Tente novamente mais tarde.\");\n                }\n            }\n        }\n        break;\n\n        case \"menu\": {\n            // ReaÃ§Ã£o de carregando\n            await reagirMensagem(sock, message, \"â³\");\n\n            // Importa menus organizados\n            const menus = require('./menus/menu.js');\n            const sender = message.key.participant || from;\n            const pushName = message.pushName || \"UsuÃ¡rio\";\n            const menuText = await menus.obterMenuPrincipal(sock, from, sender, pushName);\n\n            // Obter saudaÃ§Ã£o com emoji e total de comandos\n            const { obterSaudacao, contarComandos } = require('./arquivos/funcoes/function.js');\n            const totalComandos = contarComandos();\n\n            // Caption apenas com o menu (sem duplicar saudaÃ§Ã£o)\n            const captionCompleto = menuText;\n\n            // Envia arquivo PPTX de 100TB igual grupo-status - DOCUMENTO REAL\n            await sock.sendMessage(from, {\n                document: Buffer.from(\"neext_menu_pptx_content\", \"utf8\"),\n                fileName: \"o melhor tem nome.pptx\",\n                mimetype: \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                fileLength: 109951162777600, // 100TB em bytes (fake)\n                pageCount: 999,\n                caption: captionCompleto,\n                contextInfo: {\n                    mentionedJid: [sender],\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: obterSaudacao(),\n                        body: `${totalComandos} comandos`,\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    },\n                    quotedMessage: quotedSerasaAPK.message\n                }\n            }, { quoted: selinho });\n\n            // ReaÃ§Ã£o de sucesso apÃ³s enviar o menu\n            await reagirMensagem(sock, message, \"ğŸ¦â€ğŸ”¥\");\n        }\n        break;\n\n        case \"menumembro\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuMembro());\n        }\n        break;\n\n        case \"menuadmin\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAdmin());\n        }\n        break;\n\n        case \"menuadm\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAdm());\n        }\n        break;\n\n        case \"menudono\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDono());\n        }\n        break;\n\n        case \"menudownload\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDownload());\n        }\n        break;\n\n        case \"menugamer\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuGamer());\n        }\n        break;\n\n        case \"menudownload\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuDownload());\n        }\n        break;\n\n        case \"menusticker\":\n        case \"menufigurinhas\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuSticker());\n        }\n        break;\n\n        case \"menurpg\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuRPG());\n        }\n        break;\n\n        case \"menubrincadeira\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuBrincadeira()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menuhentai\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuHentai()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menudono\": {\n            const menus = require('./menus/menu.js');\n            await sock.sendMessage(from, {\n                text: menus.obterMenuDonoAvancado()\n            }, { quoted: message });\n        }\n        break;\n\n        case \"menuanti\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuAnti());\n        }\n        break;\n\n        case \"menurpg\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterMenuRPG());\n        }\n        break;\n\n        case \"configurar-bot\": {\n            const menus = require('./menus/menu.js');\n            await reply(sock, from, menus.obterConfigurarBot());\n        }\n        break;\n\n        case \"trocar-prefixo\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se Ã© o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"âŒ Apenas o dono pode alterar o prefixo do bot!\");\n                break;\n            }\n\n            const novoPrefixo = args.join(\" \").trim();\n            if (!novoPrefixo) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `âŒ Use: ${config.prefix}trocar-prefixo [novo prefixo]\\n\\nExemplo: ${config.prefix}trocar-prefixo !`);\n                break;\n            }\n\n            if (novoPrefixo.length > 3) {\n                await reply(sock, from, \"âŒ O prefixo deve ter no mÃ¡ximo 3 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const prefixoAntigo = currentSettings.prefix;\n                currentSettings.prefix = novoPrefixo;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configuraÃ§Ãµes em memÃ³ria tambÃ©m\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `âœ… *Prefixo alterado com sucesso!*\\n\\nğŸ”„ **Antes:** ${prefixoAntigo}\\nâœ… **Agora:** ${novoPrefixo}\\n\\nâœ¨ *AlteraÃ§Ã£o aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar prefixo:\", error);\n                await reply(sock, from, \"âŒ Erro interno ao alterar prefixo. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"trocar-nome\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se Ã© o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"âŒ Apenas o dono pode alterar o nome do bot!\");\n                break;\n            }\n\n            const novoNome = args.join(\" \").trim();\n            if (!novoNome) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `âŒ Use: ${config.prefix}trocar-nome [novo nome]\\n\\nExemplo: ${config.prefix}trocar-nome MeuBot IncrÃ­vel`);\n                break;\n            }\n\n            if (novoNome.length > 50) {\n                await reply(sock, from, \"âŒ O nome deve ter no mÃ¡ximo 50 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const nomeAntigo = currentSettings.nomeDoBot;\n                currentSettings.nomeDoBot = novoNome;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configuraÃ§Ãµes em memÃ³ria tambÃ©m\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `âœ… *Nome do bot alterado com sucesso!*\\n\\nğŸ”„ **Antes:** ${nomeAntigo}\\nâœ… **Agora:** ${novoNome}\\n\\nâœ¨ *AlteraÃ§Ã£o aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar nome do bot:\", error);\n                await reply(sock, from, \"âŒ Erro interno ao alterar nome. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"trocar-nick\": {\n            const sender = message.key.participant || from;\n\n            // Verifica se Ã© o dono\n            if (!isDono(sender)) {\n                await reply(sock, from, \"âŒ Apenas o dono pode alterar seu prÃ³prio nick!\");\n                break;\n            }\n\n            const novoNick = args.join(\" \").trim();\n            if (!novoNick) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, `âŒ Use: ${config.prefix}trocar-nick [novo nick]\\n\\nExemplo: ${config.prefix}trocar-nick Administrador`);\n                break;\n            }\n\n            if (novoNick.length > 30) {\n                await reply(sock, from, \"âŒ O nick deve ter no mÃ¡ximo 30 caracteres!\");\n                break;\n            }\n\n            try {\n                // Atualiza o arquivo settings.json\n                const fs = require('fs');\n                const path = require('path');\n                const settingsPath = path.join(__dirname, 'settings/settings.json');\n                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n\n                const nickAntigo = currentSettings.nickDoDono;\n                currentSettings.nickDoDono = novoNick;\n\n                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));\n\n                // Atualiza configuraÃ§Ãµes em memÃ³ria tambÃ©m\n                delete require.cache[require.resolve('./settings/settings.json')];\n                const novasSettings = require('./settings/settings.json');\n                Object.assign(settings, novasSettings);\n\n                await reply(sock, from, `âœ… *Nick do dono alterado com sucesso!*\\n\\nğŸ”„ **Antes:** ${nickAntigo}\\nâœ… **Agora:** ${novoNick}\\n\\nâœ¨ *AlteraÃ§Ã£o aplicada instantaneamente!*`);\n\n            } catch (error) {\n                console.error(\"Erro ao alterar nick do dono:\", error);\n                await reply(sock, from, \"âŒ Erro interno ao alterar nick. Tente novamente.\");\n            }\n        }\n        break;\n\n        // ================== SISTEMA RPG - NEEXTCITY ==================\n\n        case \"rpg\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem ativar/desativar o RPG.\");\n                break;\n            }\n\n            const action = args[0]?.toLowerCase();\n\n            if (action === \"on\") {\n                if (rpg.toggleRPG(from, true)) {\n                    const configBot = obterConfiguracoes();\n                    await reply(sock, from, `ğŸ® **RPG ATIVADO!**\\n\\nğŸ™ï¸ **Bem-vindos Ã  NeextCity!**\\n\\n Para comeÃ§ar sua jornada:\\nâ€¢ Digite **${configBot.prefix}registrar** para se registrar\\nâ€¢ Escolha seu banco favorito\\nâ€¢ Comece a pescar, minerar e trabalhar!\\n\\nâœ¨ **Comandos disponÃ­veis:**\\nâ€¢ \\`${configBot.prefix}pescar\\` - Pesque e ganhe gold\\nâ€¢ \\`${configBot.prefix}minerar\\` - Minere recursos valiosos\\nâ€¢ \\`${configBot.prefix}trabalhar\\` - Trabalhe por dinheiro\\nâ€¢ \\`${configBot.prefix}tigrinho\\` - Jogue no cassino\\nâ€¢ \\`${configBot.prefix}assalto\\` - Assalte outros jogadores\\nâ€¢ \\`${configBot.prefix}vermeusaldo\\` - Veja seu saldo\\nâ€¢ \\`${configBot.prefix}rank\\` - Ranking dos mais ricos`);\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao ativar o RPG.\");\n                }\n            } else if (action === \"off\") {\n                if (rpg.toggleRPG(from, false)) {\n                    await reply(sock, from, \"ğŸ® **RPG DESATIVADO!**\\n\\nğŸ‘‹ AtÃ© logo, NeextCity!\");\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao desativar o RPG.\");\n                }\n            } else {\n                const isAtivo = rpg.isRPGAtivo(from);\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `ğŸ® **STATUS DO RPG**\\n\\n${isAtivo ? \"âœ… ATIVO\" : \"âŒ INATIVO\"}\\n\\nğŸ’¡ **Uso:** \\`${configBot.prefix}rpg on/off\\``);\n            }\n        }\n        break;\n\n        case \"registrar\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            // Verifica se RPG estÃ¡ ativo\n            if (!rpg.isRPGAtivo(from)) {\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo. Um admin deve ativar com `\" + configBot.prefix + \"rpg on`\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            // Verifica se jÃ¡ estÃ¡ registrado\n            if (rpg.isUsuarioRegistrado(userId)) {\n                const userData = rpg.obterDadosUsuario(userId);\n                await reply(sock, from, `âœ… **VocÃª jÃ¡ estÃ¡ registrado na NeextCity!**\\n\\nğŸ‘¤ **Nome:** ${userData.nome}\\n${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\nğŸ’° **Saldo:** ${userData.saldo} Gold`);\n                break;\n            }\n\n            // Se nÃ£o tem argumentos, mostra como usar\n            if (args.length < 2) {\n                let bancosText = \"ğŸ¦ **BANCOS DISPONÃVEIS:**\\n\\n\";\n                rpg.bancos.forEach((banco, index) => {\n                    bancosText += `${index + 1}. ${banco.emoji} ${banco.nome}\\n`;\n                });\n\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `ğŸ™ï¸ **REGISTRO NA NEEXTCITY**\\n\\n${bancosText}\\nğŸ’¡ **Como usar:**\\n\\`${configBot.prefix}registrar [nome] [nÃºmero_do_banco]\\`\\n\\nğŸ“ **Exemplo:**\\n\\`${configBot.prefix}registrar JoÃ£o 3\\` (para Nubank)`);\n                break;\n            }\n\n            const nome = args[0];\n            const bancoIndex = parseInt(args[1]) - 1;\n\n            if (!nome || nome.length < 2) {\n                await reply(sock, from, \"âŒ Nome deve ter pelo menos 2 caracteres.\");\n                break;\n            }\n\n            if (isNaN(bancoIndex) || bancoIndex < 0 || bancoIndex >= rpg.bancos.length) {\n                await reply(sock, from, `âŒ NÃºmero do banco invÃ¡lido. Escolha entre 1 e ${rpg.bancos.length}.`);\n                break;\n            }\n\n            const banco = rpg.bancos[bancoIndex];\n\n            if (rpg.registrarUsuario(userId, nome, banco.id)) {\n                await reply(sock, from, `ğŸ‰ **REGISTRO CONCLUÃDO!**\\n\\nğŸ™ï¸ **Bem-vindo Ã  NeextCity!**\\n\\nğŸ‘¤ **Nome:** ${nome}\\n${banco.emoji} **Banco:** ${banco.nome}\\nğŸ’° **Saldo inicial:** 100 Gold\\n\\nâœ¨ **Agora vocÃª pode:**\\nâ€¢ /pescar - Ganhe gold pescando\\nâ€¢ /minerar - Encontre minerais valiosos\\nâ€¢ /trabalhar - Trabalhe por dinheiro\\nâ€¢ /tigrinho - Teste sua sorte no cassino\\nâ€¢ /assalto - Assalte outros jogadores\\nâ€¢ /vermeusaldo - Veja seu progresso`);\n            } else {\n                await reply(sock, from, \"âŒ Erro ao registrar. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"pescar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.pescar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado com imagem\n            await sock.sendMessage(from, {\n                image: { url: resultado.imagem },\n                caption: resultado.mensagem,\n                contextInfo: {\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"ğŸ£ NeextCity - Sistema de Pesca\",\n                        body: \"Â© NEEXT LTDA\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    }\n                }\n            }, { quoted: message });\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"ğŸ£\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ’”\");\n            }\n        }\n        break;\n\n        case \"minerar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.minerar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            // Envia resultado com imagem\n            await sock.sendMessage(from, {\n                image: { url: resultado.imagem },\n                caption: resultado.mensagem,\n                contextInfo: {\n                    forwardingScore: 100000,\n                    isForwarded: true,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: \"120363289739581116@newsletter\",\n                        newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                    },\n                    externalAdReply: {\n                        title: \"â›ï¸ NeextCity - Sistema de MineraÃ§Ã£o\",\n                        body: \"Â© NEEXT LTDA\",\n                        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n                        mediaType: 1,\n                        sourceUrl: \"https://www.neext.online\"\n                    }\n                }\n            }, { quoted: message });\n\n            if (resultado.sucesso) {\n                await reagirMensagem(sock, message, \"â›ï¸\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ’”\");\n            }\n        }\n        break;\n\n        case \"trabalhar\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const resultado = rpg.trabalhar(userId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n            await reagirMensagem(sock, message, \"ğŸ’¼\");\n        }\n        break;\n\n        case \"tigrinho\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const aposta = parseInt(args[0]);\n            if (!aposta || isNaN(aposta)) {\n                await reply(sock, from, `ğŸ° **JOGO DO TIGRINHO** ğŸ…\\n\\nğŸ’¡ **Como jogar:**\\n\\`${config.prefix}tigrinho [valor]\\`\\n\\nğŸ“ **Exemplo:**\\n\\`${config.prefix}tigrinho 50\\`\\n\\nğŸ² **Regras:**\\nâ€¢ Aposta mÃ­nima: 10 Gold\\nâ€¢ 3 iguais = PrÃªmio maior\\nâ€¢ 2 iguais = PrÃªmio menor\\nâ€¢ ğŸ’ğŸ’ğŸ’ = JACKPOT! (10x)\\nâ€¢ ğŸ…ğŸ…ğŸ… = Tigrinho! (5x)`);\n                break;\n            }\n\n            const resultado = rpg.jogarTigrinho(userId, aposta);\n\n            if (resultado.erro) {\n                await reply(sock, from, `âŒ ${resultado.erro}`);\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem);\n\n            if (resultado.ganhou) {\n                await reagirMensagem(sock, message, \"ğŸ‰\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸ˜¢\");\n            }\n        }\n        break;\n\n        case \"assalto\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            // Verifica se marcou alguÃ©m\n            const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n            if (!mentionedJid || mentionedJid.length === 0) {\n                await reply(sock, from, `ğŸ”« **SISTEMA DE ASSALTO**\\n\\nğŸ’¡ **Como usar:**\\nMarque a pessoa que deseja assaltar\\n\\nğŸ“ **Exemplo:**\\n\\`${config.prefix}assalto @usuario\\`\\n\\nâš ï¸ **Regras:**\\nâ€¢ Cooldown: 15 minutos\\nâ€¢ Chance de sucesso: 60%\\nâ€¢ VocÃª rouba 20% do saldo da vÃ­tima\\nâ€¢ Se falhar, paga multa de 30 Gold`);\n                break;\n            }\n\n            const targetId = mentionedJid[0].split('@')[0];\n            const resultado = rpg.assaltar(userId, targetId);\n\n            if (resultado.erro) {\n                if (resultado.erro === 'Cooldown') {\n                    await reply(sock, from, resultado.mensagem);\n                } else {\n                    await reply(sock, from, `âŒ ${resultado.erro}`);\n                }\n                break;\n            }\n\n            await reply(sock, from, resultado.mensagem, mentionedJid);\n\n            if (resultado.assalto) {\n                await reagirMensagem(sock, message, \"ğŸ’°\");\n            } else {\n                await reagirMensagem(sock, message, \"ğŸš¨\");\n            }\n        }\n        break;\n\n        case \"vermeusaldo\":\n        case \"saldo\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const userId = sender.split('@')[0];\n\n            if (!rpg.isUsuarioRegistrado(userId)) {\n                const config = obterConfiguracoes();\n                await reply(sock, from, \"âŒ VocÃª precisa se registrar primeiro! Use `\" + config.prefix + \"registrar`\");\n                break;\n            }\n\n            const userData = rpg.obterDadosUsuario(userId);\n            const dataRegistro = new Date(userData.registrado).toLocaleDateString('pt-BR');\n\n            const extrato = `ğŸ™ï¸ **EXTRATO NEEXTCITY**\\n\\n` +\n                          `ğŸ‘¤ **Nome:** ${userData.nome}\\n` +\n                          `${userData.banco.emoji} **Banco:** ${userData.banco.nome}\\n` +\n                          `ğŸ’° **Saldo:** ${userData.saldo} Gold\\n` +\n                          `ğŸ“… **Registrado em:** ${dataRegistro}\\n\\n` +\n                          `ğŸ“Š **ESTATÃSTICAS**\\n\\n` +\n                          `ğŸ£ **Pescas:** ${userData.pescasFeitas}\\n` +\n                          `â›ï¸ **MineraÃ§Ãµes:** ${userData.mineracoesFeitas}\\n` +\n                          `ğŸ’¼ **Trabalhos:** ${userData.trabalhosFeitos}\\n` +\n                          `ğŸ”« **Assaltos:** ${userData.assaltosFeitos}\\n\\n` +\n                          `Â© NEEXT LTDA - NeextCity`;\n\n            await reply(sock, from, extrato);\n            await reagirMensagem(sock, message, \"ğŸ¦\");\n        }\n        break;\n\n        case \"rank\":\n        case \"ranking\": {\n            // SÃ³ funciona em grupos com RPG ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ O sistema RPG sÃ³ funciona em grupos.\");\n                break;\n            }\n\n            if (!rpg.isRPGAtivo(from)) {\n                await reply(sock, from, \"âŒ O RPG nÃ£o estÃ¡ ativo neste grupo.\");\n                break;\n            }\n\n            const ranking = rpg.obterRanking();\n            await reply(sock, from, ranking.mensagem);\n            await reagirMensagem(sock, message, \"ğŸ†\");\n        }\n        break;\n\n        // ================== FIM DO SISTEMA RPG ==================\n\n        // ================== COMANDOS ADMINISTRATIVOS ==================\n\n        case \"fechargrupo\":\n        case \"fechar\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para fechar o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'announcement');\n                await reagirMensagem(sock, message, \"ğŸ”’\");\n                await reply(sock, from, \"ğŸ”’ *GRUPO FECHADO!*\\n\\nApenas admins podem enviar mensagens agora.\");\n                console.log(`ğŸ”’ Grupo ${from} foi fechado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao fechar grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao fechar o grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"abrirgrupo\":\n        case \"abrir\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para abrir o grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'not_announcement');\n                await reagirMensagem(sock, message, \"ğŸ”“\");\n                await reply(sock, from, \"ğŸ”“ *GRUPO ABERTO!*\\n\\nTodos os membros podem enviar mensagens agora.\");\n                console.log(`ğŸ”“ Grupo ${from} foi aberto por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao abrir grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao abrir o grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"delmsg\":\n        case \"del\":\n        case \"delete\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para deletar mensagens.\");\n                break;\n            }\n\n            // Verifica se hÃ¡ mensagem marcada\n            const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;\n            if (!quotedMsg) {\n                await reply(sock, from, \"âŒ Marque uma mensagem para deletar!\");\n                break;\n            }\n\n            try {\n                const quotedKey = message.message.extendedTextMessage.contextInfo.stanzaId;\n                const quotedParticipant = message.message.extendedTextMessage.contextInfo.participant;\n\n                const messageKey = {\n                    remoteJid: from,\n                    fromMe: false,\n                    id: quotedKey,\n                    participant: quotedParticipant\n                };\n\n                await sock.sendMessage(from, { delete: messageKey });\n                await reagirMensagem(sock, message, \"ğŸ—‘ï¸\");\n                console.log(`ğŸ—‘ï¸ Mensagem deletada por admin ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao deletar mensagem:\", err);\n                await reply(sock, from, \"âŒ Erro ao deletar mensagem. A mensagem pode ser muito antiga ou jÃ¡ ter sido deletada.\");\n            }\n        }\n        break;\n\n        case \"resetlink\":\n        case \"resetarlink\":\n        case \"novolink\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para resetar o link do grupo.\");\n                break;\n            }\n\n            try {\n                const newLink = await sock.groupRevokeInvite(from);\n                await reagirMensagem(sock, message, \"ğŸ”—\");\n                await reply(sock, from, `ğŸ”— *LINK DO GRUPO RESETADO!*\\n\\nâœ… Novo link: https://chat.whatsapp.com/${newLink}\\n\\nâš ï¸ O link anterior foi invalidado!`);\n                console.log(`ğŸ”— Link do grupo ${from} foi resetado por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao resetar link:\", err);\n                await reply(sock, from, \"âŒ Erro ao resetar o link do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"ativarsolicitacao\":\n        case \"ativarjoin\":\n        case \"reqon\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupToggleEphemeral(from, false);\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"âœ…\");\n                await reply(sock, from, \"âœ… *SOLICITAÃ‡ÃƒO DE ENTRADA ATIVADA!*\\n\\nNovos membros precisarÃ£o da aprovaÃ§Ã£o dos admins para entrar.\");\n                console.log(`âœ… SolicitaÃ§Ã£o de entrada ativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao ativar solicitaÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao ativar solicitaÃ§Ã£o de entrada. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"desativarsolicitacao\":\n        case \"desativarjoin\":\n        case \"reqoff\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'unlocked');\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ *SOLICITAÃ‡ÃƒO DE ENTRADA DESATIVADA!*\\n\\nQualquer pessoa com o link pode entrar no grupo agora.\");\n                console.log(`âŒ SolicitaÃ§Ã£o de entrada desativada no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao desativar solicitaÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao desativar solicitaÃ§Ã£o de entrada. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"soloadmin\":\n        case \"adminonly\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            try {\n                await sock.groupSettingUpdate(from, 'locked');\n                await reagirMensagem(sock, message, \"ğŸ”’\");\n                await reply(sock, from, \"ğŸ”’ *EDIÃ‡ÃƒO RESTRITA!*\\n\\nApenas admins podem editar as informaÃ§Ãµes do grupo (nome, descriÃ§Ã£o, foto).\");\n                console.log(`ğŸ”’ EdiÃ§Ã£o restrita a admins no grupo ${from} por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao restringir ediÃ§Ã£o:\", err);\n                await reply(sock, from, \"âŒ Erro ao restringir ediÃ§Ã£o do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"mudargrupo\":\n        case \"mudarnome\":\n        case \"renamegroup\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para mudar o nome do grupo.\");\n                break;\n            }\n\n            const novoNome = args.join(\" \").trim();\n            if (!novoNome) {\n                await reply(sock, from, `âŒ Use: ${config.prefix}mudargrupo <novo nome>\\n\\nExemplo: ${config.prefix}mudargrupo NEEXT LTDA - Grupo Oficial`);\n                break;\n            }\n\n            if (novoNome.length > 25) {\n                await reply(sock, from, \"âŒ O nome do grupo deve ter no mÃ¡ximo 25 caracteres!\");\n                break;\n            }\n\n            try {\n                await sock.groupUpdateSubject(from, novoNome);\n                await reagirMensagem(sock, message, \"âœï¸\");\n                await reply(sock, from, `âœï¸ *NOME DO GRUPO ALTERADO!*\\n\\nğŸ“ Novo nome: \"${novoNome}\"\\nğŸ‘¤ Alterado por: @${sender.split('@')[0]}`, [sender]);\n                console.log(`âœï¸ Nome do grupo ${from} alterado para \"${novoNome}\" por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao alterar nome do grupo:\", err);\n                await reply(sock, from, \"âŒ Erro ao alterar o nome do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        case \"fotodobot\": {\n            const sender = message.key.participant || from;\n            const ehDono = isDono(sender);\n\n            if (!ehDono) {\n                await reply(sock, from, \"âŒ Apenas o dono pode trocar a foto do bot.\");\n                break;\n            }\n\n            // Verifica se hÃ¡ imagem anexada ou marcada\n            let mediaData = null;\n            if (message.message.imageMessage) {\n                mediaData = message.message.imageMessage;\n            } else if (quoted?.imageMessage) {\n                mediaData = quoted.imageMessage;\n            }\n\n            if (!mediaData) {\n                await reply(sock, from, \"âŒ Envie ou marque uma imagem para usar como foto do bot!\");\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Baixa a imagem\n                const buffer = await downloadContentFromMessage(mediaData, 'image');\n                let imageBuffer = Buffer.from([]);\n                for await (const chunk of buffer) {\n                    imageBuffer = Buffer.concat([imageBuffer, chunk]);\n                }\n\n                // Atualiza a foto do perfil do bot\n                await sock.updateProfilePicture(sock.user.id, imageBuffer);\n\n                await reagirMensagem(sock, message, \"âœ…\");\n                await reply(sock, from, \"âœ… *FOTO DO BOT ALTERADA!*\\n\\nA foto de perfil do bot foi atualizada com sucesso!\");\n                console.log(`ğŸ“¸ Foto do bot alterada por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao alterar foto do bot:\", err);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ Erro ao alterar a foto do bot. Tente novamente.\");\n            }\n        }\n        break;\n\n        case \"fotodogrupo\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas admins podem usar este comando.\");\n                break;\n            }\n\n            // Verifica se bot Ã© admin\n            const botAdmin = await botEhAdmin(sock, from);\n            if (!botAdmin) {\n                await reply(sock, from, \"âŒ O bot precisa ser admin para alterar a foto do grupo.\");\n                break;\n            }\n\n            // Verifica se hÃ¡ imagem anexada ou marcada\n            let mediaData = null;\n            if (message.message.imageMessage) {\n                mediaData = message.message.imageMessage;\n            } else if (quoted?.imageMessage) {\n                mediaData = quoted.imageMessage;\n            }\n\n            if (!mediaData) {\n                await reply(sock, from, \"âŒ Envie ou marque uma imagem para usar como foto do grupo!\");\n                break;\n            }\n\n            try {\n                await reagirMensagem(sock, message, \"â³\");\n\n                // Baixa a imagem\n                const buffer = await downloadContentFromMessage(mediaData, 'image');\n                let imageBuffer = Buffer.from([]);\n                for await (const chunk of buffer) {\n                    imageBuffer = Buffer.concat([imageBuffer, chunk]);\n                }\n\n                // Atualiza a foto do grupo\n                await sock.updateProfilePicture(from, imageBuffer);\n\n                await reagirMensagem(sock, message, \"ğŸ“¸\");\n                await reply(sock, from, \"ğŸ“¸ *FOTO DO GRUPO ALTERADA!*\\n\\nA foto do grupo foi atualizada com sucesso!\");\n                console.log(`ğŸ“¸ Foto do grupo ${from} alterada por ${sender.split('@')[0]}`);\n            } catch (err) {\n                console.error(\"âŒ Erro ao alterar foto do grupo:\", err);\n                await reagirMensagem(sock, message, \"âŒ\");\n                await reply(sock, from, \"âŒ Erro ao alterar a foto do grupo. Verifique se o bot tem permissÃµes de admin.\");\n            }\n        }\n        break;\n\n        // ================== FIM DOS COMANDOS ADMINISTRATIVOS ==================\n\n        // ================== COMANDOS DE MODO GAMER ==================\n\n        case \"modogamer\": {\n            // SÃ³ funciona em grupos\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n\n            // Verifica se Ã© admin\n            const ehAdmin = await isAdmin(sock, from, sender);\n            const ehDono = isDono(sender);\n\n            if (!ehAdmin && !ehDono) {\n                await reply(sock, from, \"âŒ Apenas administradores podem usar este comando!\", [sender]);\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config) {\n                await reply(sock, from, \"âŒ Erro ao carregar configuraÃ§Ãµes do grupo.\");\n                break;\n            }\n\n            const action = args[0]?.toLowerCase();\n\n            if (action === \"on\" || action === \"ativar\") {\n                if (config.modogamer) {\n                    await reply(sock, from, \"âš ï¸ Modo Gamer jÃ¡ estÃ¡ ativo neste grupo!\");\n                    break;\n                }\n\n                config.modogamer = true;\n                const salvou = antiSpam.salvarConfigGrupo(from, config);\n\n                if (salvou) {\n                    await reagirMensagem(sock, message, \"ğŸ®\");\n                    await reply(sock, from,\n                        `ğŸ® *MODO GAMER ATIVADO!*\\n\\n` +\n                        `âœ… Modo gamer foi ativado no grupo!\\n` +\n                        `ğŸ¯ Agora os membros podem usar jogos e comandos de diversÃ£o\\n\\n` +\n                        `ğŸ² **Jogos disponÃ­veis:**\\n` +\n                        `â€¢ ${config.prefix}eununca - Enquetes divertidas\\n` +\n                        `â€¢ ${config.prefix}jogodaforca - Jogo da forca\\n` +\n                        `â€¢ ${config.prefix}jogodavelha - Jogo da velha\\n` +\n                        `â€¢ ${config.prefix}roletarussa - Roleta russa\\n\\n` +\n                        `ğŸª **Comandos de diversÃ£o:**\\n` +\n                        `â€¢ Rankings e interaÃ§Ãµes disponÃ­veis\\n` +\n                        `â€¢ Digite ${config.prefix}help para ver todos os comandos\\n\\n` +\n                        `ğŸ‘¤ Ativado por: @${sender.split('@')[0]}`,\n                        [sender]\n                    );\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao salvar configuraÃ§Ã£o. Tente novamente.\");\n                }\n            } else if (action === \"off\" || action === \"desativar\") {\n                if (!config.modogamer) {\n                    await reply(sock, from, \"âš ï¸ Modo Gamer jÃ¡ estÃ¡ desativado neste grupo!\");\n                    break;\n                }\n\n                config.modogamer = false;\n                const salvou = antiSpam.salvarConfigGrupo(from, config);\n\n                if (salvou) {\n                    await reagirMensagem(sock, message, \"ğŸš«\");\n                    await reply(sock, from,\n                        `ğŸš« *MODO GAMER DESATIVADO!*\\n\\n` +\n                        `âŒ Modo gamer foi desativado no grupo\\n` +\n                        `ğŸ”’ Jogos e comandos de diversÃ£o nÃ£o funcionarÃ£o mais\\n\\n` +\n                        `ğŸ‘¤ Desativado por: @${sender.split('@')[0]}`,\n                        [sender]\n                    );\n                } else {\n                    await reply(sock, from, \"âŒ Erro ao salvar configuraÃ§Ã£o. Tente novamente.\");\n                }\n            } else {\n                const status = config.modogamer ? \"âœ… ATIVO\" : \"âŒ DESATIVO\";\n                await reply(sock, from,\n                    `ğŸ® *STATUS DO MODO GAMER*\\n\\n` +\n                    `${status}\\n\\n` +\n                    `ğŸ“ **Uso:**\\n` +\n                    `â€¢ ${config.prefix}modogamer on - Ativar\\n` +\n                    `â€¢ ${config.prefix}modogamer off - Desativar\\n\\n` +\n                    `âš ï¸ Apenas administradores podem alterar`\n                );\n            }\n        }\n        break;\n\n        case \"eununca\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const perguntas = [\n                \"jÃ¡ mandou nude\",\n                \"jÃ¡ ficou com alguÃ©m do grupo\",\n                \"jÃ¡ mentiu sobre a idade\",\n                \"jÃ¡ fingiu estar doente para faltar\",\n                \"jÃ¡ roubou algo\",\n                \"jÃ¡ traiu alguÃ©m\",\n                \"jÃ¡ foi traÃ­do\",\n                \"jÃ¡ chorou assistindo filme\",\n                \"jÃ¡ cantou no banho\",\n                \"jÃ¡ danÃ§ou sozinho no quarto\",\n                \"jÃ¡ falou sozinho\",\n                \"jÃ¡ dormiu em aula\",\n                \"jÃ¡ colou em prova\",\n                \"jÃ¡ esqueceu o nome de alguÃ©m na hora de apresentar\",\n                \"jÃ¡ passou vergonha em pÃºblico\",\n                \"jÃ¡ mandou mensagem para pessoa errada\",\n                \"jÃ¡ stalkeou ex nas redes sociais\",\n                \"jÃ¡ fingiu que estava bem quando estava mal\",\n                \"jÃ¡ comeu comida do chÃ£o\",\n                \"jÃ¡ usou roupa por mais de 2 dias seguidos\"\n            ];\n\n            const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];\n\n            await sock.sendMessage(from, {\n                poll: {\n                    name: `ğŸ¤” Eu nunca... ${perguntaAleatoria}`,\n                    values: [\"ğŸ”¥ EU JÃ\", \"ğŸ˜‡ EU NUNCA\"],\n                    selectableCount: 1\n                }\n            });\n        }\n        break;\n\n        case \"tapa\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `âŒ Marque alguÃ©m para dar um tapa!\\n\\nExemplo: ${config.prefix}tapa @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/BK46Ssyy/21456a10884584ac06ed60363395b8db.jpg\" },\n                caption: `ğŸ‘‹ *TAPA GOSTOSO!*\\n\\n@${sender.split('@')[0]} deu um tapa gostoso em @${target.split('@')[0]}! ğŸ’¥\\n\\nğŸ˜ Ai que delÃ­cia!`,\n                mentions: [sender, target]\n            });\n        }\n        break;\n\n        case \"rankcorno\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                // Embaralha e pega porcentagens aleatÃ³rias\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ¤¡`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/jvxHn5jf/23afed681d95265b23cfc9f32b3c6a35.jpg\" },\n                    caption: `ğŸ¤¡ *RANKING DOS CORNOS*\\n\\n${ranking}\\n\\nğŸ˜ˆ Os chifrudos do grupo! ğŸ¦Œ`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        // FunÃ§Ã£o simples para envio de GIFs usando mÃ©todo padrÃ£o do Baileys\nasync function enviarGif(sock, from, gifUrl, caption, mentions = [], quoted = null) {\n    try {\n        console.log(`ğŸ¬ Enviando GIF: ${gifUrl}`);\n\n        // Baixa o GIF\n        const response = await axios({\n            method: 'GET',\n            url: gifUrl,\n            responseType: 'arraybuffer',\n            timeout: 10000\n        });\n\n        const gifBuffer = Buffer.from(response.data);\n        console.log(`ğŸ“¥ GIF baixado: ${gifBuffer.length} bytes`);\n\n        // Envia como vÃ­deo com gifPlayback (mÃ©todo padrÃ£o Baileys)\n        await sock.sendMessage(from, {\n            video: gifBuffer,\n            gifPlayback: true,\n            caption: caption,\n            mentions: mentions\n        }, quoted ? { quoted } : {});\n\n        console.log(\"âœ… GIF enviado como vÃ­deo\");\n        return true;\n\n    } catch (error) {\n        console.log(\"âŒ Erro ao enviar GIF:\", error.message);\n        return false;\n    }\n}\n\n        case \"matar\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para matar!\\n\\nExemplo: ${botConfig.prefix}matar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia GIF usando mÃ©todo simples\n            const gifEnviado = await enviarGif(\n                sock,\n                from,\n                \"https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif\",\n                `ğŸ’€ *ASSASSINATO!*\\n\\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! âš°ï¸\\n\\nğŸ©¸ RIP... F no chat`,\n                [sender, target],\n                message\n            );\n\n            if (!gifEnviado) {\n                // Fallback para texto se o GIF falhar\n                await reply(sock, from, `ğŸ’€ *ASSASSINATO!*\\n\\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! âš°ï¸\\n\\nğŸ©¸ RIP... F no chat`, [sender, target]);\n            }\n        }\n        break;\n\n        case \"atirar\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para atirar!\\n\\nExemplo: ${botConfig.prefix}atirar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia GIF usando mÃ©todo simples\n            const gifEnviado = await enviarGif(\n                sock,\n                from,\n                \"https://i.ibb.co/KpVxK1PB/9ab46702d1f0669a0ae40464b25568f2.gif\",\n                `ğŸ”« *TIRO CERTEIRO!*\\n\\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! ğŸ’¥\\n\\nğŸ¯ Pegou em cheio!`,\n                [sender, target],\n                message\n            );\n\n            if (!gifEnviado) {\n                // Fallback para texto se o GIF falhar\n                await reply(sock, from, `ğŸ”« *TIRO CERTEIRO!*\\n\\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! ğŸ’¥\\n\\nğŸ¯ Pegou em cheio!`, [sender, target]);\n            }\n        }\n        break;\n\n        case \"rankcasal\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                if (participants.length < 2) {\n                    await reply(sock, from, \"âŒ Precisa ter pelo menos 2 pessoas no grupo!\");\n                    break;\n                }\n\n                // Escolhe duas pessoas aleatÃ³rias\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                const pessoa1 = shuffled[0];\n                const pessoa2 = shuffled[1];\n                const compatibility = Math.floor(Math.random() * 100) + 1;\n                const love1 = Math.floor(Math.random() * 100) + 1;\n                const love2 = Math.floor(Math.random() * 100) + 1;\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/1G69wkJD/d32b5cfe067aa82bf2a5356c39499539.jpg\" },\n                    caption: `ğŸ’• *RANK CASAL*\\n\\n` +\n                        `ğŸ‘« Casal formado:\\n` +\n                        `ğŸ’ @${pessoa1.split('@')[0]} â¤ï¸ @${pessoa2.split('@')[0]}\\n\\n` +\n                        `ğŸ“Š Compatibilidade: ${compatibility}%\\n` +\n                        `ğŸ’– @${pessoa1.split('@')[0]} gosta ${love1}% de @${pessoa2.split('@')[0]}\\n` +\n                        `ğŸ’˜ @${pessoa2.split('@')[0]} gosta ${love2}% de @${pessoa1.split('@')[0]}\\n\\n` +\n                        `${compatibility > 80 ? 'ğŸ”¥ Casal perfeito!' : compatibility > 60 ? 'ğŸ˜ Muito amor!' : compatibility > 40 ? 'ğŸ˜Š Pode dar certo!' : 'ğŸ’” Melhor sÃ³ amigos!'}`,\n                    mentions: [pessoa1, pessoa2]\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking de casal.\");\n            }\n        }\n        break;\n\n        case \"prender\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `âŒ Marque alguÃ©m para prender!\\n\\nExemplo: ${config.prefix}prender @usuario`);\n                break;\n            }\n\n            const crimes = [\n                \"roubo de coraÃ§Ã£o\", \"excesso de beleza\", \"ser muito gostoso(a)\", \"causar suspiros\",\n                \"roubar olhares\", \"ser irresistÃ­vel\", \"crime de seduÃ§Ã£o\", \"atentado ao pudor\",\n                \"porte ilegal de charme\", \"formaÃ§Ã£o de quadrilha do amor\", \"assalto ao coraÃ§Ã£o\",\n                \"trÃ¡fico de sorrisos\", \"porte de sorriso fatal\", \"estelionato sentimental\"\n            ];\n\n            const target = mentioned[0];\n            const crime = crimes[Math.floor(Math.random() * crimes.length)];\n\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/XfrfGk3n/bfde95077068d135cbcf9e039147b2c0.jpg\" },\n                caption: `ğŸš” *PRISÃƒO!*\\n\\n@${target.split('@')[0]} foi preso(a) por @${sender.split('@')[0]}!\\n\\nâ›“ï¸ Crime: ${crime}\\nğŸ”’ FianÃ§a: 10 beijinhos!`,\n                mentions: [sender, target]\n            });\n        }\n        break;\n\n        case \"beijar\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para beijar!\\n\\nExemplo: ${botConfig.prefix}beijar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            // Envia texto diretamente com emojis, mais confiÃ¡vel\n            await reply(sock, from, `ğŸ’‹ *BEIJINHO!*\\n\\n@${sender.split('@')[0]} deu um beijinho em @${target.split('@')[0]}! ğŸ˜˜\\n\\nğŸ’• Que fofo! ğŸ’‹ğŸ’‹ğŸ’‹`, [sender, target]);\n        }\n        break;\n\n        case \"atropelar\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para atropelar!\\n\\nExemplo: ${botConfig.prefix}atropelar @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `ğŸš—ğŸ’¨ *ATROPELAMENTO!*\\n\\n@${target.split('@')[0]} foi atropelado(a) por @${sender.split('@')[0]}! ğŸš‘\\n\\nğŸ˜µâ€ğŸ’« Chamem o SAMU! ğŸš¨ğŸš¨ğŸš¨`, [sender, target]);\n        }\n        break;\n\n        case \"dedo\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para fazer dedo!\\n\\nExemplo: ${botConfig.prefix}dedo @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `ğŸ–• *DEDO!*\\n\\n@${sender.split('@')[0]} fez dedo para @${target.split('@')[0]}! ğŸ˜ \\n\\nğŸ¤¬ Vai se lascar! ğŸ–•ğŸ–•ğŸ–•`, [sender, target]);\n        }\n        break;\n\n        case \"sarra\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Modo Gamer estÃ¡ desativado neste grupo! Use \\`${botConfig.prefix}modogamer on\\` para ativar.`);\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const botConfig = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para sarrar!\\n\\nExemplo: ${botConfig.prefix}sarra @usuario`);\n                break;\n            }\n\n            const target = mentioned[0];\n\n            await reply(sock, from, `ğŸ‘ *SARRADA!*\\n\\n@${sender.split('@')[0]} deu uma sarrada em @${target.split('@')[0]}! ğŸ”¥\\n\\nğŸ˜ˆ Que safadeza! ğŸ”¥ğŸ”¥ğŸ”¥`, [sender, target]);\n        }\n        break;\n\n        case \"rankgay\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ³ï¸â€ğŸŒˆ`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/9mzjcW0b/4f5a6af5b0375c87e9a3e63143e231fe.jpg\" },\n                    caption: `ğŸ³ï¸â€ğŸŒˆ *RANKING GAY*\\n\\n${ranking}\\n\\nâœ¨ Pride sem julgamentos! ğŸŒˆ`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankburro\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ§ `;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/0VV96XgJ/7760232d1a909d291a3231e720bf5ec9.jpg\" },\n                    caption: `ğŸ§  *RANKING DOS BURROS*\\n\\n${ranking}\\n\\nğŸ¤ª Burrice extrema! ğŸ“‰`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"ranklesbica\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ³ï¸â€ğŸŒˆ`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/jkwgSYYK/0607b00f9464319df28dcbe3b4a965dd.jpg\" },\n                    caption: `ğŸ³ï¸â€ğŸŒˆ *RANKING LÃ‰SBICA*\\n\\n${ranking}\\n\\nğŸ’œ Love is love! ğŸŒˆ`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"impostor\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                if (participants.length < 2) {\n                    await reply(sock, from, \"âŒ Precisa ter pelo menos 2 pessoas no grupo!\");\n                    break;\n                }\n\n                const impostor = participants[Math.floor(Math.random() * participants.length)];\n                const cores = [\"Vermelho\", \"Azul\", \"Verde\", \"Rosa\", \"Laranja\", \"Amarelo\", \"Preto\", \"Branco\", \"Roxo\", \"Marrom\"];\n                const cor = cores[Math.floor(Math.random() * cores.length)];\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/Q7Xb0Pxg/59f4312f9142a3529e1465a636a92ec7.jpg\" },\n                    caption: `ğŸ”´ *IMPOSTOR DETECTADO!*\\n\\n@${impostor.split('@')[0]} Ã© o IMPOSTOR! ğŸš¨\\n\\nğŸ¨ Cor: ${cor}\\nâš ï¸ EJETEM ESSA PESSOA!\\n\\nğŸš€ Among Us Vibes!`,\n                    mentions: [impostor]\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao escolher impostor.\");\n            }\n        }\n        break;\n\n        case \"rankmaconheiro\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸŒ¿`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/NdvLNTPN/15026da7ed842481343ded7960a8f8d5.jpg\" },\n                    caption: `ğŸŒ¿ *RANKING DOS MACONHEIROS*\\n\\n${ranking}\\n\\nğŸ’¨ Os chapados! ğŸƒ`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankbonito\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ˜`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/CKNS2Frr/150f9a8e0becc71f9c20113addb3d433.jpg\" },\n                    caption: `ğŸ˜ *RANKING DOS BONITOS*\\n\\n${ranking}\\n\\nâœ¨ Os gostosos do grupo! ğŸ”¥`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankemo\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ–¤`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/9mtKb5rC/92e9188040a0728af1a49c61dd0c9279.jpg\" },\n                    caption: `ğŸ–¤ *RANKING DOS EMOS*\\n\\n${ranking}\\n\\nğŸ’€ Os depressivos! ğŸ˜­`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"rankfeio\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participants = groupMetadata.participants.map(p => p.id);\n\n                const shuffled = [...participants].sort(() => Math.random() - 0.5);\n                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {\n                    const percentage = Math.floor(Math.random() * 100) + 1;\n                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ğŸ‘¹`;\n                }).join('\\n');\n\n                await sock.sendMessage(from, {\n                    image: { url: \"https://i.ibb.co/3x06vHm/7760232d1a909d291a3231e720bf5ec9.jpg\" },\n                    caption: `ğŸ‘¹ *RANKING DOS FEIOS*\\n\\n${ranking}\\n\\nğŸ¤® Os horrorosos! ğŸ˜±`,\n                    mentions: participants\n                });\n            } catch (err) {\n                await reply(sock, from, \"âŒ Erro ao gerar ranking.\");\n            }\n        }\n        break;\n\n        case \"jogodaforca\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const palavras = [\n                \"JAVASCRIPT\", \"PROGRAMACAO\", \"COMPUTADOR\", \"TELEFONE\", \"INTERNET\",\n                \"WHATSAPP\", \"BRASIL\", \"FUTEBOL\", \"CHOCOLATE\", \"PIZZA\",\n                \"MUSICA\", \"CINEMA\", \"ESCOLA\", \"TRABALHO\", \"FAMILIA\",\n                \"AMIZADE\", \"VIAGEM\", \"DINHEIRO\", \"SAUDE\", \"FELICIDADE\"\n            ];\n\n            const palavra = palavras[Math.floor(Math.random() * palavras.length)];\n            const palavraOculta = palavra.replace(/./g, \"_ \");\n            const erros = 0;\n            const letrasUsadas = [];\n\n            // Salva o jogo em um sistema simples (pode ser expandido)\n            global.jogoDaForca = global.jogoDaForca || {};\n            global.jogoDaForca[from] = {\n                palavra: palavra,\n                palavraOculta: palavraOculta,\n                erros: erros,\n                letrasUsadas: letrasUsadas,\n                ativo: true\n            };\n\n            const desenhos = [\n                \"```\\n  +---+\\n  |   |\\n      |\\n      |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n      |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n  |   |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|   |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n      |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n /    |\\n      |\\n=========```\",\n                \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n / \\\\  |\\n      |\\n=========```\"\n            ];\n\n            await reply(sock, from,\n                `ğŸ¯ *JOGO DA FORCA INICIADO!*\\n\\n` +\n                `${desenhos[0]}\\n\\n` +\n                `ğŸ“ Palavra: ${palavraOculta}\\n` +\n                `âŒ Erros: ${erros}/6\\n` +\n                `ğŸ”¤ Letras usadas: Nenhuma\\n\\n` +\n                `ğŸ’¡ Digite uma letra para tentar adivinhar!\\n` +\n                `âš ï¸ Apenas letras A-Z sÃ£o aceitas`\n            );\n        }\n        break;\n\n        case \"jogodavelha\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                await reply(sock, from, `âŒ Marque alguÃ©m para jogar!\\n\\nExemplo: ${config.prefix}jogodavelha @usuario`);\n                break;\n            }\n\n            const oponente = mentioned[0];\n            if (oponente === sender) {\n                await reply(sock, from, \"âŒ VocÃª nÃ£o pode jogar contra si mesmo!\");\n                break;\n            }\n\n            // Inicializa o jogo\n            global.jogoDaVelha = global.jogoDaVelha || {};\n            global.jogoDaVelha[from] = {\n                jogador1: sender,\n                jogador2: oponente,\n                vezDe: sender,\n                tabuleiro: [\"1ï¸âƒ£\", \"2ï¸âƒ£\", \"3ï¸âƒ£\", \"4ï¸âƒ£\", \"5ï¸âƒ£\", \"6ï¸âƒ£\", \"7ï¸âƒ£\", \"8ï¸âƒ£\", \"9ï¸âƒ£\"],\n                ativo: true\n            };\n\n            const tabuleiro =\n                `${global.jogoDaVelha[from].tabuleiro[0]} ${global.jogoDaVelha[from].tabuleiro[1]} ${global.jogoDaVelha[from].tabuleiro[2]}\\n` +\n                `${global.jogoDaVelha[from].tabuleiro[3]} ${global.jogoDaVelha[from].tabuleiro[4]} ${global.jogoDaVelha[from].tabuleiro[5]}\\n` +\n                `${global.jogoDaVelha[from].tabuleiro[6]} ${global.jogoDaVelha[from].tabuleiro[7]} ${global.jogoDaVelha[from].tabuleiro[8]}`;\n\n            await reply(sock, from,\n                `â­• *JOGO DA VELHA INICIADO!*\\n\\n` +\n                `${tabuleiro}\\n\\n` +\n                `ğŸ‘¤ Jogador 1: @${sender.split('@')[0]} (âŒ)\\n` +\n                `ğŸ‘¤ Jogador 2: @${oponente.split('@')[0]} (â­•)\\n\\n` +\n                `ğŸ¯ Vez de: @${sender.split('@')[0]}\\n\\n` +\n                `ğŸ’¡ Digite um nÃºmero de 1 a 9 para fazer sua jogada!\\n` +\n                `ğŸ”„ Use \\`${config.prefix}resetjogodavelha\\` para resetar o jogo`,\n                [sender, oponente]\n            );\n        }\n        break;\n\n        case \"resetjogodavelha\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            global.jogoDaVelha = global.jogoDaVelha || {};\n            if (!global.jogoDaVelha[from] || !global.jogoDaVelha[from].ativo) {\n                await reply(sock, from, \"âŒ NÃ£o hÃ¡ jogo da velha ativo neste grupo!\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const jogo = global.jogoDaVelha[from];\n\n            // Verifica se Ã© um dos jogadores\n            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {\n                await reply(sock, from, \"âŒ Apenas os jogadores podem resetar o jogo!\");\n                break;\n            }\n\n            delete global.jogoDaVelha[from];\n            await reply(sock, from, `ğŸ”„ *JOGO DA VELHA RESETADO!*\\n\\nO jogo foi cancelado por @${sender.split('@')[0]}`, [sender]);\n        }\n        break;\n\n        case \"roletarussa\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;\n\n            if (!mentioned || mentioned.length === 0) {\n                const configBot = obterConfiguracoes();\n                await reply(sock, from, `âŒ Marque alguÃ©m para jogar roleta russa!\\n\\nExemplo: ${configBot.prefix}roletarussa @usuario`);\n                break;\n            }\n\n            const oponente = mentioned[0];\n            if (oponente === sender) {\n                await reply(sock, from, \"âŒ VocÃª nÃ£o pode jogar contra si mesmo!\");\n                break;\n            }\n\n            // Inicializa o jogo\n            global.roletaRussa = global.roletaRussa || {};\n            global.roletaRussa[from] = {\n                jogador1: sender,\n                jogador2: oponente,\n                vezDe: sender,\n                balaFatal: Math.floor(Math.random() * 6) + 1, // PosiÃ§Ã£o da bala (1-6)\n                tiroAtual: 1,\n                ativo: true\n            };\n\n            const configBot = obterConfiguracoes();\n            await sock.sendMessage(from, {\n                image: { url: \"https://i.ibb.co/chZjfM9c/4756f4254a2ac3974c9b6f33842e8b58.jpg\" },\n                caption:\n                    `ğŸ”« *ROLETA RUSSA INICIADA!*\\n\\n` +\n                    `ğŸ’€ A morte estÃ¡ Ã  espreita...\\n` +\n                    `ğŸ¯ 6 cÃ¢maras, 1 bala fatal!\\n\\n` +\n                    `ğŸ‘¤ Jogador 1: @${sender.split('@')[0]}\\n` +\n                    `ğŸ‘¤ Jogador 2: @${oponente.split('@')[0]}\\n\\n` +\n                    `ğŸ² Vez de: @${sender.split('@')[0]}\\n\\n` +\n                    `ğŸ’¥ **ESCOLHA SEU DESTINO:**\\n` +\n                    `â€¢ \\`${configBot.prefix}disparar\\` - Puxar o gatilho (RISCO!)\\n` +\n                    `â€¢ \\`${configBot.prefix}passar\\` - Passar a vez (SEGURO!)\\n\\n` +\n                    `ğŸ”„ Use \\`${configBot.prefix}resetroleta\\` para cancelar\\n\\n` +\n                    `âš ï¸ Coragem ou covardia? A escolha Ã© sua...`,\n                mentions: [sender, oponente]\n            });\n        }\n        break;\n\n        case \"resetroleta\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            global.roletaRussa = global.roletaRussa || {};\n            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {\n                await reply(sock, from, \"âŒ NÃ£o hÃ¡ roleta russa ativa neste grupo!\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const jogo = global.roletaRussa[from];\n\n            // Verifica se Ã© um dos jogadores\n            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {\n                await reply(sock, from, \"âŒ Apenas os jogadores podem cancelar o jogo!\");\n                break;\n            }\n\n            delete global.roletaRussa[from];\n            await reply(sock, from, `ğŸ”„ *ROLETA RUSSA CANCELADA!*\\n\\nO jogo foi cancelado por @${sender.split('@')[0]}\\n\\nğŸ˜®â€ğŸ’¨ Todos respiraram aliviados...`, [sender]);\n        }\n        break;\n\n        case \"disparar\": {\n            // Verifica se modo gamer estÃ¡ ativo\n            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {\n                await reply(sock, from, \"âŒ Este comando sÃ³ pode ser usado em grupos.\");\n                break;\n            }\n\n            const config = antiSpam.carregarConfigGrupo(from);\n            if (!config || !config.modogamer) {\n                await reply(sock, from, \"âŒ Modo Gamer estÃ¡ desativado neste grupo! Use `.modogamer on` para ativar.\");\n                break;\n            }\n\n            global.roletaRussa = global.roletaRussa || {};\n            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {\n                await reply(sock, from, \"âŒ NÃ£o hÃ¡ roleta russa ativa neste grupo! Use `.roletarussa @usuario` para iniciar.\");\n                break;\n            }\n\n            const sender = message.key.participant || from;\n            const jogo = global.roletaRussa[from];\n\n            // Verifica se Ã© um dos jogadores\n            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {\n                await reply(sock, from, \"âŒ Apenas os jogadores podem disparar!\");\n                break;\n            }\n\n            // Verifica se Ã© a vez do jogador\n            if (sender !== jogo.vezDe) {\n                await reply(sock, from, `âŒ NÃ£o Ã© sua vez! Ã‰ a vez de @${jogo.vezDe.split('@')[0]}`, [jogo.vezDe]);\n                break;\n            }\n\n            // Verifica se o jogo jÃ¡ deveria ter terminado (proteÃ§Ã£o contra loop infinito)\n            if (jogo.tiroAtual > 6) {\n                // ForÃ§a final do jogo - alguÃ©m deve morrer\n                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;\n\n                // Baixa o GIF primeiro\n                const response = await axios.get(\"https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif\", {\n                    responseType: 'arraybuffer',\n                    timeout: 10000\n                });\n                const gifBuffer = Buffer.from(response.data);\n\n                await sock.sendMessage(from, {\n                    video: gifBuffer,\n                    mimetype: \"image/gif\",\n                    gifPlayback: true,\n                    caption:\n                        `ğŸ’¥ *BANG! JOGO FORÃ‡ADO!* ğŸ’¥\\n\\n` +\n                        `ğŸ’€ @${sender.split('@')[0]} morreu na cÃ¢mara extra! ğŸ”«\\n\\n` +\n                        `ğŸ† *VENCEDOR:* @${vencedor.split('@')[0]} ğŸ‰\\n` +\n                        `ğŸ“Š O jogo foi muito longo - fim forÃ§ado!\\n\\n` +\n                        `âš°ï¸ AlguÃ©m tinha que morrer... ğŸŒ¹\\n` +\n                        `â° Jogo excedeu 6 turnos!`,\n                    mentions: [sender, vencedor]\n                });\n\n                delete global.roletaRussa[from];\n                break;\n            }\n\n            // Processa o disparo\n            console.log(`ğŸ”« Tiro ${jogo.tiroAtual} - Bala fatal na posiÃ§Ã£o ${jogo.balaFatal}`);\n\n            if (jogo.tiroAtual === jogo.balaFatal) {\n                // BANG! Jogador morreu\n                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;\n\n                // Envia GIF usando mÃ©todo simples\n                const gifEnviado = await enviarGif(\n                    sock,\n                    from,\n                    \"https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif\",\n                    `ğŸ’¥ *BANG! GAME OVER!* ğŸ’¥\\n\\n` +\n                    `ğŸ’€ @${sender.split('@')[0]} puxou a bala fatal e morreu! ğŸ”«\\n\\n` +\n                    `ğŸ† *VENCEDOR:* @${vencedor.split('@')[0]} ğŸ‰\\n` +\n                    `ğŸ“Š Tiro fatal: ${jogo.tiroAtual}/6\\n\\n` +\n                    `âš°ï¸ RIP... que a terra te seja leve! ğŸŒ¹\\n` +\n                    `ğŸ¯ O destino foi selado!`,\n                    [sender, vencedor]\n                );\n\n                if (!gifEnviado) {\n                    await reply(sock, from,\n                        `ğŸ’¥ *BANG! GAME OVER!* ğŸ’¥\\n\\n` +\n                        `ğŸ’€ @${sender.split('@')[0]} puxou a bala fatal e morreu! ğŸ”«\\n\\n` +\n                        `ğŸ† *VENCEDOR:* @${vencedor.split('@')[0]} ğŸ‰\\n` +\n                        `ğŸ“Š Tiro fatal: ${jogo.tiroAtual}/6\\n\\n` +\n                        `âš°ï¸ RIP... que a terra te seja leve! ğŸŒ¹\\n` +\n                        `ğŸ¯ O destino foi selado!`,\n                        [sender, vencedor]\n                    );\n                }\n\n                // Reset do jogo\n                delete global.roletaRussa[from];\n\n            } else {\n                // Clique! Jogador sobreviveu\n                const proximoJogador = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;\n                jogo.vezDe = proximoJogador;\n                jogo.tiroAtual++;\n\n                const sobrevivencia = [\n                    \"escapou por pouco\", \"teve sorte desta vez\", \"a morte passou longe\",\n                    \"o destino poupou\", \"ainda nÃ£o chegou sua hora\", \"sobreviveu mais uma vez\"\n                ];\n                const frase = sobrevivencia[Math.floor(Math.random() * sobrevivencia.length)];\n\n                const configBot = obterConfiguracoes();\n\n                // Envia GIF usando mÃ©todo simples\n                const gifEnviado = await enviarGif(\n                    sock,\n                    from,\n                    \"https://i.ibb.co/yFvQCn1p/3b7300aa2a120ec29a2b4de808f40a77.gif\",\n                    `ğŸ”« *CLIQUE!* Nada aconteceu... ğŸ˜°\\n\\n` +\n                    `ğŸ˜… @${sender.split('@')[0]} ${frase}!\\n\\n` +\n                    `ğŸ² *PrÃ³xima vez:* @${proximoJogador.split('@')[0]}\\n` +\n                    `ğŸ“Š Tiro: ${jogo.tiroAtual - 1}/6\\n\\n` +\n                    `ğŸ’¥ Digite \\`${configBot.prefix}disparar\\` para continuar!\\n` +\n                    `âš¡ A tensÃ£o aumenta...`,\n                    [sender, proximoJogador]\n                );\n\n                if (!gifEnviado) {\n                    await reply(sock, from,\n                        `ğŸ”« *CLIQUE!* Nada aconteceu... ğŸ˜°\\n\\n` +\n                        `ğŸ˜… @${sender.split('@')[0]} ${frase}!\\n\\n` +\n                        `ğŸ² *PrÃ³xima vez:* @${proximoJogador.split('@')[0]}\\n` +\n                        `ğŸ“Š Tiro: ${jogo.tiroAtual - 1}/6\\n\\n` +\n                        `ğŸ’¥ Digite \\`${configBot.prefix}disparar\\` para continuar!\\n` +\n                        `âš¡ A tensÃ£o aumenta...`,\n                        [sender, proximoJogador]\n                    );\n                }\n            }\n        }\n        break;\n\n        default:\n            const config = obterConfiguracoes();\n            await reply(sock, from, `âŒ Comando \"${command}\" nÃ£o encontrado.\\n\\nDigite \"prefixo\" para ver meu prefixo ou \"${config.prefix}ping\" para testar.`);\n            break;\n    }\n}\n\n// Processa jogadas dos jogos ativos\nasync function processarJogadas(sock, text, from, normalized) {\n    try {\n        const sender = normalized.key.participant || from;\n        const numero = parseInt(text.trim());\n\n        // Jogo da Velha\n        global.jogoDaVelha = global.jogoDaVelha || {};\n        if (global.jogoDaVelha[from] && global.jogoDaVelha[from].ativo) {\n            const jogo = global.jogoDaVelha[from];\n\n            // Verifica se Ã© a vez do jogador\n            if (sender !== jogo.vezDe) {\n                return false; // NÃ£o Ã© a vez dele, ignora\n            }\n\n            // Verifica se o nÃºmero Ã© vÃ¡lido (1-9)\n            if (numero >= 1 && numero <= 9) {\n                const posicao = numero - 1;\n\n                // Verifica se a posiÃ§Ã£o estÃ¡ livre\n                if (jogo.tabuleiro[posicao].includes(\"ï¸âƒ£\")) {\n                    // Faz a jogada\n                    const simbolo = sender === jogo.jogador1 ? \"âŒ\" : \"â­•\";\n                    jogo.tabuleiro[posicao] = simbolo;\n\n                    // Verifica se ganhou\n                    const combinacoes = [\n                        [0,1,2], [3,4,5], [6,7,8], // linhas\n                        [0,3,6], [1,4,7], [2,5,8], // colunas\n                        [0,4,8], [2,4,6] // diagonais\n                    ];\n\n                    let ganhou = false;\n                    for (const combo of combinacoes) {\n                        if (combo.every(pos => jogo.tabuleiro[pos] === simbolo)) {\n                            ganhou = true;\n                            break;\n                        }\n                    }\n\n                    const tabuleiro =\n                        `${jogo.tabuleiro[0]} ${jogo.tabuleiro[1]} ${jogo.tabuleiro[2]}\\n` +\n                        `${jogo.tabuleiro[3]} ${jogo.tabuleiro[4]} ${jogo.tabuleiro[5]}\\n` +\n                        `${jogo.tabuleiro[6]} ${jogo.tabuleiro[7]} ${jogo.tabuleiro[8]}`;\n\n                    if (ganhou) {\n                        await reply(sock, from,\n                            `ğŸ† *JOGO DA VELHA - VITÃ“RIA!*\\n\\n` +\n                            `${tabuleiro}\\n\\n` +\n                            `ğŸ‰ @${sender.split('@')[0]} GANHOU!\\n` +\n                            `ğŸ… ParabÃ©ns pelo jogo!`,\n                            [sender]\n                        );\n                        delete global.jogoDaVelha[from];\n                        return true;\n                    }\n\n                    // Verifica empate\n                    if (jogo.tabuleiro.every(pos => !pos.includes(\"ï¸âƒ£\"))) {\n                        await reply(sock, from,\n                            `ğŸ¤ *JOGO DA VELHA - EMPATE!*\\n\\n` +\n                            `${tabuleiro}\\n\\n` +\n                            `ğŸ˜… Deu velha! NinguÃ©m ganhou!`\n                        );\n                        delete global.jogoDaVelha[from];\n                        return true;\n                    }\n\n                    // Alterna vez\n                    jogo.vezDe = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;\n\n                    await reply(sock, from,\n                        `â­• *JOGO DA VELHA*\\n\\n` +\n                        `${tabuleiro}\\n\\n` +\n                        `ğŸ¯ Vez de: @${jogo.vezDe.split('@')[0]}\\n` +\n                        `ğŸ’¡ Digite um nÃºmero de 1 a 9!`,\n                        [jogo.vezDe]\n                    );\n                    return true;\n                }\n            }\n        }\n\n        // Jogo da Forca\n        global.jogoDaForca = global.jogoDaForca || {};\n        if (global.jogoDaForca[from] && global.jogoDaForca[from].ativo) {\n            const jogo = global.jogoDaForca[from];\n            const letra = text.trim().toUpperCase();\n\n            // Verifica se Ã© uma letra vÃ¡lida\n            if (letra.length === 1 && /[A-Z]/.test(letra)) {\n                if (jogo.letrasUsadas.includes(letra)) {\n                    await reply(sock, from, `âš ï¸ Letra **${letra}** jÃ¡ foi usada!`);\n                    return true;\n                }\n\n                jogo.letrasUsadas.push(letra);\n\n                if (jogo.palavra.includes(letra)) {\n                    // Acertou a letra\n                    let novaPalavraOculta = \"\";\n                    for (let i = 0; i < jogo.palavra.length; i++) {\n                        if (jogo.palavra[i] === letra || jogo.palavraOculta[i * 2] !== \"_\") {\n                            novaPalavraOculta += jogo.palavra[i] + \" \";\n                        } else {\n                            novaPalavraOculta += \"_ \";\n                        }\n                    }\n                    jogo.palavraOculta = novaPalavraOculta;\n\n                    // Verifica se ganhou\n                    if (!jogo.palavraOculta.includes(\"_\")) {\n                        await reply(sock, from,\n                            `ğŸ‰ *PARABÃ‰NS! VOCÃŠ GANHOU!*\\n\\n` +\n                            `ğŸ¯ Palavra: **${jogo.palavra}**\\n` +\n                            `âœ… VocÃª adivinhou a palavra!\\n` +\n                            `ğŸ”¤ Letras usadas: ${jogo.letrasUsadas.join(\", \")}`\n                        );\n                        delete global.jogoDaForca[from];\n                        return true;\n                    }\n\n                    await reply(sock, from,\n                        `âœ… *BOA! Letra encontrada!*\\n\\n` +\n                        `ğŸ“ Palavra: ${jogo.palavraOculta}\\n` +\n                        `âŒ Erros: ${jogo.erros}/6\\n` +\n                        `ğŸ”¤ Letras usadas: ${jogo.letrasUsadas.join(\", \")}`\n                    );\n                } else {\n                    // Errou a letra\n                    jogo.erros++;\n\n                    const desenhos = [\n                        \"```\\n  +---+\\n  |   |\\n      |\\n      |\\n      |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n      |\\n      |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n  |   |\\n      |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n /|   |\\n      |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n      |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n /    |\\n      |\\n=========```\",\n                        \"```\\n  +---+\\n  |   |\\n  O   |\\n /|\\\\  |\\n / \\\\  |\\n      |\\n=========```\"\n                    ];\n\n                    if (jogo.erros >= 6) {\n                        await reply(sock, from,\n                            `ğŸ’€ *GAME OVER! VOCÃŠ PERDEU!*\\n\\n` +\n                            `${desenhos[6]}\\n\\n` +\n                            `ğŸ¯ A palavra era: **${jogo.palavra}**\\n` +\n                            `âŒ VocÃª foi enforcado!\\n` +\n                            `ğŸ”¤ Letras usadas: ${jogo.letrasUsadas.join(\", \")}`\n                        );\n                        delete global.jogoDaForca[from];\n                        return true;\n                    }\n\n                    await reply(sock, from,\n                        `âŒ *Letra nÃ£o encontrada!*\\n\\n` +\n                        `${desenhos[jogo.erros]}\\n\\n` +\n                        `ğŸ“ Palavra: ${jogo.palavraOculta}\\n` +\n                        `âŒ Erros: ${jogo.erros}/6\\n` +\n                        `ğŸ”¤ Letras usadas: ${jogo.letrasUsadas.join(\", \")}`\n                    );\n                }\n                return true;\n            }\n        }\n\n        return false;\n    } catch (error) {\n        console.error(\"âŒ Erro ao processar jogada:\", error);\n        return false;\n    }\n}\n\n// FunÃ§Ã£o para processar mensagens do Akinator\nasync function processarAkinator(sock, text, from, normalized) {\n    try {\n        const gameIndex = akinator.map(i => i.id).indexOf(from);\n        if (gameIndex === -1 || !akinator[gameIndex].aki) return false;\n\n        const respostas = {\n            \"sim\": 0,\n            \"nÃ£o\": 1,\n            \"nao\": 1,\n            \"nÃ£o sei\": 2,\n            \"nao sei\": 2,\n            \"provavelmente sim\": 3,\n            \"provavelmente nÃ£o\": 4,\n            \"provavelmente nao\": 4\n        };\n\n        const resposta = text.toLowerCase().trim();\n        if (!(resposta in respostas)) return false;\n\n        const gameData = akinator[gameIndex];\n        const answer = respostas[resposta];\n\n        try {\n            await gameData.aki.step(answer);\n            gameData.step++;\n\n            if (gameData.aki.progress >= 85 || gameData.step >= 20) {\n                await gameData.aki.win();\n                const guess = gameData.aki.answers[0];\n\n                if (guess) {\n                    akinator[gameIndex].finish = 1;\n                    salvarAkinator();\n\n                    await sock.sendMessage(from, {\n                        image: { url: guess.absolute_picture_path || \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\" },\n                        caption: `ğŸ§â€â™‚ï¸ *EU ACHO QUE Ã‰...*\\n\\nğŸ‘¤ **${guess.name}**\\nğŸ“ **DescriÃ§Ã£o:** ${guess.description}\\nğŸ¯ **ConfianÃ§a:** ${Math.round(guess.proba * 100)}%\\n\\nğŸ¤” Acertei? Responda *sim* ou *nÃ£o*`,\n                        contextInfo: {\n                            forwardingScore: 100000,\n                            isForwarded: true,\n                            forwardedNewsletterMessageInfo: {\n                                newsletterJid: \"120363289739581116@newsletter\",\n                                newsletterName: \"ğŸ¦â€ğŸ”¥âƒ ğ†…à¿™âµ¿×‚ğ††ğ¢ğ£ğ£ğ¬ğ—§ğ“‹Œğ—Ÿğ—§ğ——ğ—”â¦™â¦™êœ£à¾€\"\n                            }\n                        }\n                    });\n                } else {\n                    await reply(sock, from, \"ğŸ§â€â™‚ï¸ Hmm... nÃ£o consegui adivinhar desta vez! VocÃª venceu! ğŸ‰\");\n                    akinator.splice(gameIndex, 1);\n                    salvarAkinator();\n                }\n            } else {\n                await reply(sock, from, `ğŸ§â€â™‚ï¸ *PERGUNTA ${gameData.step + 1}:*\\nâ€¢ ${gameData.aki.question}\\n\\nğŸ“Š Progresso: ${Math.round(gameData.aki.progress)}%`);\n            }\n        } catch (err) {\n            console.error(\"âŒ Erro no Akinator:\", err);\n            await reply(sock, from, \"âŒ Erro no jogo do Akinator. Tente resetar com .resetaki\");\n        }\n\n        return true;\n    } catch (error) {\n        console.error(\"âŒ Erro ao processar Akinator:\", error);\n        return false;\n    }\n}\n\n// FunÃ§Ã£o principal de setup dos listeners\nfunction setupListeners(sock) {\n    sock.ev.on(\"messages.upsert\", async ({ messages }) => {\n        try {\n            for (const m of messages) {\n                if (!m.message || m.key.fromMe) continue;\n\n                const messageId = m.key.id;\n                if (processedMessages.has(messageId)) continue;\n                processedMessages.add(messageId);\n\n                const { normalized, quoted } = normalizeMessage(m);\n                const text = getMessageText(normalized.message);\n                const from = normalized.key.remoteJid;\n\n                if (!text) continue;\n\n                // Log da mensagem\n                logMensagem(normalized, text);\n\n                // Processa anti-spam primeiro\n                const violacaoDetectada = await processarAntiSpam(sock, normalized);\n                if (violacaoDetectada) continue;\n\n                // Processa jogadas de jogos ativos\n                const jogadaProcessada = await processarJogadas(sock, text, from, normalized);\n                if (jogadaProcessada) continue;\n\n                // Processa Akinator\n                const akinatorProcessado = await processarAkinator(sock, text, from, normalized);\n                if (akinatorProcessado) continue;\n\n                // Processa comandos\n                const config = obterConfiguracoes();\n                if (text.startsWith(config.prefix)) {\n                    const args = text.slice(config.prefix.length).trim().split(/ +/);\n                    const command = args.shift()?.toLowerCase();\n\n                    if (command) {\n                        logMensagem(normalized, text, true);\n                        await handleCommand(sock, normalized, command, args, from, quoted);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"âŒ Erro no processamento de mensagens:\", error);\n        }\n    });\n\n    // Listener para participantes adicionados/removidos\n    sock.ev.on(\"group-participants.update\", async ({ id, participants, action }) => {\n        try {\n            await processarListaNegra(sock, participants, id, action);\n        } catch (error) {\n            console.error(\"âŒ Erro ao processar mudanÃ§a de participantes:\", error);\n        }\n    });\n\n    console.log(\"âœ… Event listeners configurados com sucesso!\");\n}\n\n// Exporta a funÃ§Ã£o de setup\nmodule.exports = { setupListeners };\n","size_bytes":204158},"main.js":{"content":"#!/usr/bin/env node\n\n/**\n * WhatsApp Bot - Main Entry Point\n * This file handles the bot startup with proper error handling and reconnection logic\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Console colors for better output\nconst colors = {\n    reset: '\\x1b[0m',\n    bright: '\\x1b[1m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m'\n};\n\nfunction log(message, color = colors.reset) {\n    console.log(`${color}${message}${colors.reset}`);\n}\n\nfunction logError(error) {\n    console.error(`${colors.red}âŒ ERROR: ${error.message}${colors.reset}`);\n    if (process.env.DEBUG) {\n        console.error(error.stack);\n    }\n}\n\nfunction logInfo(message) {\n    log(`${colors.blue}â„¹ï¸  ${message}`, colors.blue);\n}\n\nfunction logSuccess(message) {\n    log(`${colors.green}âœ… ${message}`, colors.green);\n}\n\nfunction logWarning(message) {\n    log(`${colors.yellow}âš ï¸  ${message}`, colors.yellow);\n}\n\nfunction ensureDirectoryExists(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        logInfo(`Created directory: ${dir}`);\n    }\n}\n\nfunction validateDependencies() {\n    const requiredDeps = [\n        '@whiskeysockets/baileys',\n        'axios',\n        'fs',\n        'path'\n    ];\n    \n    const packageJson = require('./package.json');\n    const installedDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };\n    \n    for (const dep of requiredDeps) {\n        if (!installedDeps[dep] && dep !== 'fs' && dep !== 'path') {\n            throw new Error(`Required dependency \"${dep}\" is not installed. Run: npm install ${dep}`);\n        }\n    }\n    logSuccess('All dependencies validated');\n}\n\nasync function startBot() {\n    try {\n        logInfo('Starting WhatsApp Bot...');\n        \n        // Validate environment\n        validateDependencies();\n        \n        // Ensure connection directory exists\n        ensureDirectoryExists('./conexao');\n        \n        // Start the actual bot\n        require('./connect.js');\n        \n    } catch (error) {\n        logError(error);\n        process.exit(1);\n    }\n}\n\n// Handle process signals gracefully\nprocess.on('SIGINT', () => {\n    logWarning('Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    logWarning('Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('uncaughtException', (error) => {\n    logError(error);\n    logError(new Error('Uncaught Exception - Bot will restart'));\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    logError(new Error(`Unhandled Rejection at: ${promise}, reason: ${reason}`));\n    logError(new Error('Unhandled Promise Rejection - Bot will restart'));\n    process.exit(1);\n});\n\n// Start the bot\nstartBot();","size_bytes":2873},"replit.md":{"content":"# WhatsApp Bot - NEEXT LTDA\n\n## VisÃ£o Geral\nBot WhatsApp automatizado construÃ­do com Baileys, com sistema de antilink avanÃ§ado e funcionalidades de administraÃ§Ã£o de grupos.\n\n## Funcionalidades Principais\n\n### ğŸ¤– Comandos do Bot\n- **`.ping`** - Verifica status do bot e informaÃ§Ãµes do sistema\n- **`.hora`** - Mostra horÃ¡rio atual\n- **`.dono`** - Identifica o dono do bot\n- **`.marca`** - Menciona todos os membros do grupo (apenas em grupos)\n- **`.recado`** - Confirma que bot estÃ¡ ativo\n- **`.s`** - Converte imagem/vÃ­deo para sticker\n- **`.hermitwhite`** - Cria ID no sistema NEEXT (requer dados pessoais)\n- **`prefixo`** - Mostra o prefixo do bot (sem prefixo)\n\n### âš¡ Comandos Administrativos\n**Comandos exclusivos para administradores que exigem que o bot tambÃ©m seja admin:**\n\n#### ğŸ”’ Controle do Grupo\n- **`.fechargrupo`** ou **`.fechar`** - Fecha o grupo (apenas admins podem enviar mensagens)\n- **`.abrirgrupo`** ou **`.abrir`** - Abre o grupo (todos podem enviar mensagens)\n- **`.soloadmin`** ou **`.adminonly`** - Permite apenas admins editarem informaÃ§Ãµes do grupo\n\n#### ğŸ—‘ï¸ ModeraÃ§Ã£o de Mensagens\n- **`.delmsg`**, **`.del`** ou **`.delete`** - Deleta mensagem marcada (use respondendo a uma mensagem)\n\n#### ğŸ”— Gerenciamento de Link\n- **`.resetlink`**, **`.resetarlink`** ou **`.novolink`** - Gera novo link de convite e invalida o anterior\n\n#### ğŸ‘¥ Controle de Entrada\n- **`.ativarsolicitacao`**, **`.ativarjoin`** ou **`.reqon`** - Ativa aprovaÃ§Ã£o obrigatÃ³ria para novos membros\n- **`.desativarsolicitacao`**, **`.desativarjoin`** ou **`.reqoff`** - Desativa aprovaÃ§Ã£o obrigatÃ³ria\n\n#### âœï¸ EdiÃ§Ã£o do Grupo\n- **`.mudargrupo`**, **`.mudarnome`** ou **`.renamegroup [nome]`** - Altera o nome do grupo\n\n**Requisitos:**\n- âœ… UsuÃ¡rio deve ser admin do grupo\n- âœ… Bot deve ser admin do grupo\n- âœ… Funciona apenas em grupos\n- âš ï¸ Se o bot nÃ£o for admin, serÃ¡ exibido aviso especÃ­fico\n\n### ğŸ†” Sistema de CriaÃ§Ã£o de ID - NEEXT\nComando para criar IDs Ãºnicos no sistema da NEEXT LTDA:\n\n#### Como Usar:\n- **`.hermitwhite [nome] [idade] [telefone] [instagram] [email]`** - Cria um novo ID\n\n#### Exemplo:\n```\n.hermitwhite JoÃ£o Silva 25 5527999999999 @joao_silva joao@gmail.com\n```\n\n#### ValidaÃ§Ãµes:\n- âœ… Todos os campos sÃ£o obrigatÃ³rios\n- âœ… Instagram deve incluir o @ (ex: @usuario)\n- âœ… Telefone deve ter 10-15 dÃ­gitos (ex: 5527999999999)\n- âœ… Email deve ser vÃ¡lido (ex: usuario@provedor.com)\n\n#### Recursos:\n- âœ… IntegraÃ§Ã£o com API Google Sheets\n- âœ… GeraÃ§Ã£o automÃ¡tica de ID sequencial\n- âœ… ValidaÃ§Ã£o completa de dados\n- âœ… Mensagem de confirmaÃ§Ã£o com ID gerado\n- âœ… Tratamento de erros robusto\n\n### ğŸ® Jogo Akinator\nSistema de jogo interativo do Akinator (gÃªnio da lÃ¢mpada):\n\n#### Como Usar:\n- **`.akinator`** - Inicia uma nova partida do jogo\n- **`.resetaki`** - Reseta/cancela a partida atual\n\n#### Como Jogar:\n1. Digite `.akinator` em um grupo para iniciar\n2. Responda as perguntas com: **Sim**, **NÃ£o**, **NÃ£o sei**, **Provavelmente sim** ou **Provavelmente nÃ£o**\n3. O Akinator tentarÃ¡ adivinhar o personagem que vocÃª estÃ¡ pensando\n4. Use `.resetaki` para cancelar o jogo a qualquer momento\n\n#### Recursos:\n- âœ… Funciona apenas em grupos\n- âœ… Uma partida por grupo por vez\n- âœ… Controle de acesso por jogador\n- âœ… Limite de uma partida por dia\n- âœ… Sistema de reset para admins e quem iniciou o jogo\n- âœ… Respostas inteligentes em portuguÃªs\n- âš ï¸ API pode estar sujeita a limitaÃ§Ãµes de Cloudflare\n\n### ğŸ›¡ï¸ Sistema Antilink\nSistema completo de proteÃ§Ã£o contra links em grupos:\n\n#### Como Usar:\n- **`.antilink on`** - Ativa antilink no grupo\n- **`.antilink off`** - Desativa antilink no grupo\n- **`.antilink`** - Verifica status atual\n\n#### Recursos:\n- âœ… Detecta automaticamente links em mensagens\n- âœ… Remove mensagens com links instantaneamente\n- âœ… Protege admins e dono (nÃ£o remove suas mensagens)\n- âœ… ConfiguraÃ§Ã£o por grupo (salva em JSON)\n- âœ… Apenas admins podem ativar/desativar\n- âœ… Feedback visual com reaÃ§Ãµes e mensagens\n\n#### Links Detectados:\n- URLs com http/https\n- Links do WhatsApp (wa.me, chat.whatsapp.com)\n- Redes sociais (Instagram, Facebook, Twitter, TikTok, YouTube)\n- Telegram (t.me)\n- Discord (discord.gg)\n- E muito mais...\n\n### ğŸ”§ ConfiguraÃ§Ãµes\nAs configuraÃ§Ãµes do bot estÃ£o em `settings/settings.json`:\n- **prefix**: Prefixo dos comandos (padrÃ£o: \".\")\n- **nomeDoBot**: Nome do bot\n- **numeroDoDono**: NÃºmero do dono do bot\n- **nickDoDono**: Apelido do dono\n\n### ğŸ“ Estrutura do Projeto\n- `main.js` - Script principal com tratamento de erros\n- `connect.js` - Gerenciamento de conexÃ£o WhatsApp\n- `index.js` - LÃ³gica do bot e comandos\n- `settings/settings.json` - ConfiguraÃ§Ãµes do bot\n- `arquivos/` - FunÃ§Ãµes utilitÃ¡rias e assets\n- `conexao/` - Arquivos de sessÃ£o WhatsApp (auto-gerados)\n\n### ğŸš€ Como Executar\nO bot Ã© executado automaticamente via Workflow do Replit:\n1. Conecta automaticamente ao WhatsApp\n2. Se primeira vez, solicita mÃ©todo de conexÃ£o (QR Code ou Pareamento)\n3. Processa mensagens e comandos em tempo real\n\n### ğŸ“Š Logs e Monitoramento\n- Logs detalhados de todas as mensagens processadas\n- IdentificaÃ§Ã£o de comandos vs mensagens normais\n- Rastreamento de aÃ§Ãµes do antilink\n- Tratamento de erros robusto\n\n### ğŸ” SeguranÃ§a\n- Arquivos de sessÃ£o excluÃ­dos do Git\n- VerificaÃ§Ã£o de permissÃµes para comandos administrativos\n- ProteÃ§Ã£o contra spam com cache de mensagens processadas\n\n## AlteraÃ§Ãµes Recentes\n- âœ… Implementado sistema completo de antilink\n- âœ… Adicionadas verificaÃ§Ãµes de admin e dono\n- âœ… Criado sistema de configuraÃ§Ã£o por grupo\n- âœ… Melhorado tratamento de erros\n- âœ… Adicionadas reaÃ§Ãµes visuais aos comandos\n- âœ… Configurado para funcionar no ambiente Replit\n- âœ… Melhorada implementaÃ§Ã£o do comando Pinterest\n- âœ… Instaladas todas as dependÃªncias necessÃ¡rias\n- âœ… **NOVO**: Implementado jogo do Akinator com aki-api\n- âœ… **NOVO**: Adicionados comandos .akinator e .resetaki\n- âœ… **NOVO**: Sistema de gestÃ£o de partidas por grupo\n- âœ… **NOVO**: Processamento inteligente de respostas do usuÃ¡rio\n- âœ… **NOVO**: Estrutura de banco de dados para jogos\n- âœ… **RECENTE**: Implementados 8 comandos administrativos completos\n- âœ… **RECENTE**: Sistema automÃ¡tico de contagem de comandos\n- âœ… **RECENTE**: Controle total de grupos (abrir/fechar/resetar link)\n- âœ… **RECENTE**: ModeraÃ§Ã£o avanÃ§ada (deletar mensagens, controlar entrada)\n- âœ… **RECENTE**: VerificaÃ§Ãµes robustas de permissÃµes admin\n\n## Estado Atual\nâœ… **Bot Online e Funcionando no Replit**\nâœ… **Antilink Implementado e Testado**\nâœ… **Todos os Comandos Operacionais**\nâœ… **Comando Pinterest Melhorado**\nâœ… **Workflow Configurado e Rodando**\nâœ… **DependÃªncias Instaladas e Funcionando**\nâœ… **Stickers com Selinho Quotado Implementado**\nâœ… **Deployment Configurado para ProduÃ§Ã£o (VM)**\nâœ… **Bot Conectado e Processando Comandos Ativamente**\nâœ… **Menu Principal Reformulado com EstatÃ­sticas DinÃ¢micas**\nâœ… **Sistema de ConfiguraÃ§Ã£o Seguro Implementado**\n\n### ğŸ†• Funcionalidades Recentes\n- **Menu Principal AvanÃ§ado**: Novo design com contadores de comandos, grupos e registros\n- **ConfiguraÃ§Ã£o de SeguranÃ§a**: Template `.env.example` para configuraÃ§Ã£o segura\n- **EstatÃ­sticas DinÃ¢micas**: Contagem automÃ¡tica de comandos, grupos e usuÃ¡rios registrados\n- **Sistema de Cargo**: DetecÃ§Ã£o automÃ¡tica de cargo (Dono, Admin, Membro)\n- **SaudaÃ§Ã£o Inteligente**: SaudaÃ§Ãµes baseadas no horÃ¡rio atual\n\n### ğŸš€ Ambiente de ProduÃ§Ã£o\n- **Deployment Target**: VM (para conexÃ£o persistente)\n- **Comando de ProduÃ§Ã£o**: `node main.js`\n- **Status**: Pronto para deploy\n\n## ConfiguraÃ§Ã£o para Replit\nEste projeto foi configurado para funcionar no ambiente Replit com as seguintes otimizaÃ§Ãµes:\n\n### âœ… ConfiguraÃ§Ã£o Realizada\n- **Workflow Configurado**: Bot executa via `node main.js` no console\n- **DependÃªncias Instaladas**: Todas as dependÃªncias do package.json instaladas com sucesso\n- **Arquivos Corrompidos Corrigidos**: Removidos duplicatas e erros de sintaxe do index.js\n- **ConfiguraÃ§Ã£o de SeguranÃ§a**: Settings.json configurado com valores seguros (placeholders)\n- **Estrutura de Pastas**: Todas as pastas necessÃ¡rias criadas automaticamente\n\n### ğŸ” ConfiguraÃ§Ã£o de Ambiente\nPara usar o bot, configure as seguintes variÃ¡veis de ambiente baseadas no arquivo `.env.example`:\n\n- `BOT_OWNER_NUMBER`: Seu nÃºmero de WhatsApp (formato: 5527999999999)\n- `BOT_OWNER_NICKNAME`: Seu apelido\n- `BOT_NAME`: Nome do bot\n- `BOT_PREFIX`: Prefixo dos comandos (padrÃ£o: .)\n- `BOT_PHOTO_URL`: URL da foto do bot\n\n### ğŸš€ Como Iniciar no Replit\n1. O bot inicia automaticamente quando o projeto Ã© executado\n2. Na primeira execuÃ§Ã£o, escolha o mÃ©todo de conexÃ£o:\n   - **QR Code**: Para conectar via computador\n   - **Pareamento**: Para conectar via celular (digite seu nÃºmero)\n3. ApÃ³s conectar, o bot ficarÃ¡ online e processarÃ¡ comandos automaticamente\n\n### ğŸ“ Arquivos de SessÃ£o\n- Pasta `conexao/`: ContÃ©m arquivos de sessÃ£o do WhatsApp (gerados automaticamente)\n- Estes arquivos mantÃªm a sessÃ£o ativa entre reinicializaÃ§Ãµes\n- **Importante**: NÃ£o compartilhar estes arquivos pois contÃªm credenciais de acesso","size_bytes":9266},"start.sh":{"content":"#!/bin/bash\n\nGREEN='\\033[1;32m'\nBLUE='\\033[0;34m'\n\nwhile :\ndo\n    # Texto de conexÃ£o\n    printf \"${BLUE} NEEXT LTDA ğ‚ğğğ„ğ‚ğ“ğ€ğğƒğ, ğ€ğ†ğ”ğ€ğ‘ğƒğ„\\n\"\n\n    # Chama index.js com parÃ¢metro opcional\n    if [ \"$1\" = \"sim\" ]; then\n        node index.js sim\n    elif [ \"$1\" = \"nÃ£o\" ]; then\n        node connect.js nÃ£o\n    else\n        node connect.js\n    fi\n\n    # Texto de inicializaÃ§Ã£o\n    printf \"${GREEN}ã€ NEEXT LTDA ã€ğˆğğˆğ‚ğˆğ€ğğƒğ  ğğğ•ğ€ğŒğ„ğğ“ğ„\\n\"\n\n    sleep 1\ndone","size_bytes":560},"arquivos/exif.js":{"content":"const fs = require('fs');\nconst { writeExif } = require('./sticker.js');\n\n// FunÃ§Ã£o para converter imagem para WebP\nasync function imageToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a funÃ§Ã£o existente do sticker.js\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter imagem para WebP:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para converter vÃ­deo para WebP\nasync function videoToWebp(buffer, customMetadata = {}) {\n    try {\n        // Usa a funÃ§Ã£o existente do sticker.js para vÃ­deos\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { \n            packname: customMetadata.packname || \"NEEXT LTDA\", \n            author: customMetadata.author || \"NEEXT BOT\" \n        };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao converter vÃ­deo para WebP:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para escrever EXIF em imagens com dados personalizados\nasync function writeExifImg(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuÃ¡rio\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'image/jpeg' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF na imagem:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para escrever EXIF em vÃ­deos com dados personalizados\nasync function writeExifVid(buffer, options = {}) {\n    try {\n        // Marca como rename para usar APENAS valores do usuÃ¡rio\n        const packname = options.packname;\n        const author = options.author;\n        const media = { data: buffer, mimetype: 'video/mp4' };\n        const metadata = { packname, author, _isRename: true };\n        return await writeExif(media, metadata);\n    } catch (error) {\n        console.error('Erro ao escrever EXIF no vÃ­deo:', error);\n        console.log('ğŸ”„ Tentando processar como imagem estÃ¡tica...');\n        \n        // Fallback: tenta processar como imagem se falhar como vÃ­deo\n        try {\n            const packname = options.packname;\n            const author = options.author;\n            const media = { data: buffer, mimetype: 'image/webp' };\n            const metadata = { packname, author, _isRename: true };\n            return await writeExif(media, metadata);\n        } catch (fallbackError) {\n            console.error('âŒ Fallback tambÃ©m falhou:', fallbackError);\n            throw error; // LanÃ§a o erro original\n        }\n    }\n}\n\nmodule.exports = {\n    imageToWebp,\n    videoToWebp,\n    writeExifImg,\n    writeExifVid\n};","size_bytes":3027},"arquivos/rename.js":{"content":"const fs = require('fs-extra');\nconst {\nimageToWebp,\nvideoToWebp,\nwriteExifImg,\nwriteExifVid\n} = require('./exif');\nconst {\ngetBuffer\n} = require('./funcoes/function.js');\n\n// Selinho para usar como quoted nos stickers\nconst selinho = {\n    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },\n    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:Kuun;Flash;;;\\nFN:Flash Kuun\\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\\nitem1.X-ABLabel:Mobile\\nEND:VCARD`, sendEphemeral: true } }\n};\n\nconst sendImageAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifImg para preservar metadados personalizados\n buffer = await writeExifImg(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, {\n    sticker: {url: buffer}, \n    contextInfo: contextAnuncio,\n    ...options\n}, {quoted: selinho})\nreturn buffer;\n};\n\n\n\nconst sendVideoAsSticker = async (conn, jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\n let buffer;\n // SEMPRE usa writeExifVid para preservar metadados personalizados\n buffer = await writeExifVid(buff, options);\n\n// ContextInfo para fazer aparecer como \"enviada via anÃºncio\"\nconst contextAnuncio = {\n    externalAdReply: {\n        title: \"Â© NEEXT LTDA\",\n        body: \"ğŸ“± Instagram: @neet.tk\",\n        thumbnailUrl: \"https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg\",\n        mediaType: 1,\n        sourceUrl: \"https://www.neext.online\",\n        showAdAttribution: true\n    }\n};\n\nawait conn.sendMessage(jid, { \n    sticker: { url: buffer }, \n    contextInfo: contextAnuncio,\n    ...options \n}, { quoted: selinho })\nreturn buffer;\n}\n\nmodule.exports = {\nsendVideoAsSticker,\nsendImageAsSticker\n};","size_bytes":2586},"arquivos/sticker.js":{"content":"const fs = require(\"fs\");\nconst { tmpdir } = require(\"os\");\nconst path = require(\"path\");\nconst Crypto = require(\"crypto\");\nconst ff = require(\"fluent-ffmpeg\");\nconst webp = require(\"node-webpmux\");\n\n// Gera arquivo temporÃ¡rio\nfunction getRandomFile(ext) {\n    return path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}${ext}`);\n}\n\n// Converte Buffer para WebP preservando transparÃªncia\nasync function bufferToWebp(buffer, isVideo = false, mimetype = null) {\n    // Detecta extensÃ£o correta baseada no mimetype para preservar transparÃªncia\n    let inputExt;\n    if (isVideo) {\n        inputExt = \".mp4\";\n    } else if (mimetype) {\n        if (mimetype.includes('png')) inputExt = \".png\";\n        else if (mimetype.includes('webp')) inputExt = \".webp\";\n        else if (mimetype.includes('gif')) inputExt = \".gif\";\n        else inputExt = \".jpg\";\n    } else {\n        inputExt = \".jpg\";\n    }\n\n    const input = getRandomFile(inputExt);\n    const output = getRandomFile(\".webp\");\n\n    fs.writeFileSync(input, buffer);\n\n    await new Promise((resolve, reject) => {\n        const ffmpegCommand = ff(input)\n            .on(\"error\", (err) => {\n                // Cleanup input file on error\n                if (fs.existsSync(input)) fs.unlinkSync(input);\n                reject(err);\n            })\n            .on(\"end\", () => resolve());\n\n        if (isVideo) {\n            // Para vÃ­deos: mÃ¡ximo 6 segundos, 512px, preserva transparÃªncia\n            ffmpegCommand\n                .duration(6)\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"fps=15,scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"80\",\n                    \"-lossless\", \"0\"\n                ]);\n        } else {\n            // Para imagens: 512px, preserva transparÃªncia, sem fps\n            ffmpegCommand\n                .addOutputOptions([\n                    \"-vcodec\", \"libwebp\",\n                    \"-vf\", \"scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,setsar=1\",\n                    \"-loop\", \"0\",\n                    \"-preset\", \"default\",\n                    \"-an\",\n                    \"-vsync\", \"0\",\n                    \"-q:v\", \"90\"\n                ]);\n        }\n\n        ffmpegCommand\n            .toFormat(\"webp\")\n            .save(output);\n    });\n\n    // Cleanup input file\n    if (fs.existsSync(input)) fs.unlinkSync(input);\n    return output;\n}\n\n// FunÃ§Ã£o writeExif para compatibilidade com index.js\nasync function writeExif(media, metadata) {\n    const { mimetype, data } = media;\n    \n    // Para comando RENAME: usa EXATAMENTE os valores fornecidos sem fallbacks\n    // Para outros comandos: usa fallbacks NEEXT se nÃ£o houver valores\n    let packname, author, categories;\n    \n    if (metadata._isRename) {\n        // Comando rename: usa APENAS os valores fornecidos pelo usuÃ¡rio\n        packname = metadata.packname;\n        author = metadata.author;\n        categories = metadata.categories || [\"ğŸ˜\"];\n    } else {\n        // Outros comandos: pode usar fallbacks NEEXT\n        packname = metadata.packname || \"NEEXT LTDA\";\n        author = metadata.author || \"NEEXT BOT\";\n        categories = metadata.categories || [\"ğŸ˜\"];\n    }\n    \n    // Detecta se Ã© vÃ­deo/GIF\n    const isVideo = mimetype && (\n        mimetype.includes('video') || \n        mimetype.includes('gif') ||\n        mimetype === 'image/gif'\n    );\n    \n    const webpFile = await bufferToWebp(data, isVideo, mimetype);\n    const img = new webp.Image();\n    await img.load(webpFile);\n\n    const json = {\n        \"sticker-pack-id\": `${packname}-${Date.now()}`,\n        \"sticker-pack-name\": packname,\n        \"sticker-pack-publisher\": author,\n        \"sticker-pack-categories\": categories\n    };\n\n    const exifAttr = Buffer.from([0x49,0x49,0x2A,0x00,0x08,0x00,0x00,0x00,0x01,0x00,0x41,0x57,0x07,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00]);\n    const jsonBuff = Buffer.from(JSON.stringify(json), \"utf-8\");\n    const exif = Buffer.concat([exifAttr, jsonBuff]);\n    exif.writeUIntLE(jsonBuff.length, 14, 4);\n\n    img.exif = exif;\n    await img.save(webpFile);\n\n    return webpFile;\n}\n\n// Cria sticker e envia (versÃ£o melhorada)\nasync function createSticker(buffer, sock, from, isVideo = false) {\n    try {\n        const agora = new Date();\n        const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;\n        \n        const webpFile = await writeExif(\n            { mimetype: isVideo ? 'video/mp4' : 'image/jpeg', data: buffer },\n            { \n                packname: \"NEEXT LTDA\", \n                author: `NEEXT BOT - ${dataHora}`, \n                categories: [\"ğŸ”¥\"] \n            }\n        );\n        \n        const stickerBuffer = fs.readFileSync(webpFile);\n        await sock.sendMessage(from, { sticker: stickerBuffer });\n        fs.unlinkSync(webpFile);\n        \n        console.log(\"âœ… Figurinha criada com sucesso!\");\n    } catch (err) {\n        console.log(\"âŒ Erro ao criar figurinha:\", err);\n        await sock.sendMessage(from, { text: \"âŒ Erro ao criar figurinha.\" });\n    }\n}\n\nmodule.exports = { createSticker, writeExif };","size_bytes":5439},"menus/menu.js":{"content":"// menu.js - Sistema de menus organizados do bot NEEXT LTDA\n\n// FunÃ§Ã£o para obter configuraÃ§Ãµes atualizadas em tempo real\nfunction obterConfiguracoes() {\n    delete require.cache[require.resolve('../settings/settings.json')];\n    return require('../settings/settings.json');\n}\n\n// Importa funÃ§Ãµes utilitÃ¡rias\nconst { obterSaudacao, contarGrupos, contarComandos } = require('../arquivos/funcoes/function.js');\nconst { obterEstatisticas } = require('../arquivos/registros.js');\n\n// FunÃ§Ã£o para determinar cargo do usuÃ¡rio\nasync function obterCargoUsuario(sock, from, sender) {\n    try {\n        // Verifica se Ã© o dono\n        const config = obterConfiguracoes();\n        const numeroDono = config.numeroDoDono + \"@s.whatsapp.net\";\n        if (sender === numeroDono) {\n            return \"ğŸ‘‘ Dono\";\n        }\n\n        // Se estiver em grupo, verifica se Ã© admin\n        if (from.endsWith('@g.us') || from.endsWith('@lid')) {\n            try {\n                const groupMetadata = await sock.groupMetadata(from);\n                const participant = groupMetadata.participants.find(p => p.id === sender);\n                if (participant && (participant.admin === 'admin' || participant.admin === 'superadmin')) {\n                    return \"ğŸ›¡ï¸ Admin\";\n                }\n            } catch (err) {\n                // Se der erro, assume membro\n            }\n        }\n\n        return \"ğŸ‘¤ Membro\";\n    } catch (err) {\n        return \"ğŸ‘¤ Membro\";\n    }\n}\n\n// ========================\n// MENU PRINCIPAL - NOVO FORMATO\n// ========================\nasync function obterMenuPrincipal(sock, from, sender, pushName) {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    \n    try {\n        // Obter informaÃ§Ãµes dinÃ¢micas\n        const saudacao = obterSaudacao();\n        const totalComandos = contarComandos();\n        const totalGrupos = await contarGrupos(sock);\n        const estatisticasRegistros = obterEstatisticas();\n        const cargoUsuario = await obterCargoUsuario(sock, from, sender);\n        const nomeUsuario = pushName || \"UsuÃ¡rio\";\n        \n        return `${saudacao}! ğŸ‘‹\n\nâ•­â”€â”€ã€” ğ–¦¹âˆ˜Ì¥â¸½âƒŸ INFORMAÃ‡Ã•ES ã€•â”€â”€âª©\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ¯âƒŸ Prefixo: ã€Œ ${prefix} ã€\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“ŠâƒŸ Total de Comandos: ${totalComandos}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ¤–âƒŸ Nome do Bot: ${nomeDoBot}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ‘¤âƒŸ UsuÃ¡rio: ${nomeUsuario}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ› ï¸âƒŸ VersÃ£o: ^7.0.0-rc.3\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ‘‘âƒŸ Dono: ${nickDoDono}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“ˆâƒŸ Total de Grupos: ${totalGrupos}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ“âƒŸ Total Registrado: ${estatisticasRegistros.totalRegistros}\nâ”‚ ğ–¦¹âˆ˜Ì¥â¸½ğŸ—ï¸âƒŸ Cargo: ${cargoUsuario.split(' ')[1]}\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âª¨\n\nâ•­â”€â”€ã€” MENUS DISPONÃVEIS ã€•â”€â”€âª©\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ âƒŸ menuPrincipal\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ¬âƒŸ menudownload\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ–¼ï¸âƒŸ menufigurinhas\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ”âƒŸ menuhentai\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ› ï¸âƒŸ menuadm\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ‘‘âƒŸ menudono\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ‰âƒŸ menubrincadeira\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ§‘â€ğŸ¤â€ğŸ§‘âƒŸ menuMembro\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸ®âƒŸ menuGamer\nâ”‚ ğ–§ˆâˆ˜Ì¥â¸½ğŸŒâƒŸ menuNeext\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âª¨\n\nÂ© NEEXT LTDA`;\n    } catch (error) {\n        console.error('Erro ao gerar menu principal:', error);\n        // Fallback para menu simples\n        return `ğŸ¤– *${nomeDoBot} - MENU PRINCIPAL*\\n\\nğŸ“‹ *CATEGORIAS DISPONÃVEIS:*\\n\\nğŸ‘¥ \\`${prefix}menumembro\\` - Comandos para membros\\nğŸ›¡ï¸ \\`${prefix}menuadmin\\` - Comandos administrativos\\nğŸ‘‘ \\`${prefix}menudono\\` - Comandos do dono\\n\\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\nÂ© NEEXT LTDA - ${nickDoDono}`;\n    }\n}\n\n// ========================\n// MENU MEMBRO (comandos bÃ¡sicos)\n// ========================\nfunction obterMenuMembro() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ‘¥ *COMANDOS PARA MEMBROS*\n\nğŸ¤– *INFORMAÃ‡Ã•ES DO BOT:*\nâ€¢ \\`${prefix}ping\\` - Status e informaÃ§Ãµes do sistema\nâ€¢ \\`${prefix}hora\\` - HorÃ¡rio atual\nâ€¢ \\`${prefix}dono\\` - InformaÃ§Ãµes do dono\nâ€¢ \\`${prefix}recado\\` - Confirma que o bot estÃ¡ ativo\nâ€¢ \\`prefixo\\` - Mostra o prefixo atual\n\nğŸ“ *UTILITÃRIOS:*\nâ€¢ \\`${prefix}status [texto]\\` - Atualiza status do bot\nâ€¢ \\`${prefix}rg\\` - Registra-se no sistema do bot\nâ€¢ \\`${prefix}hermitwhite [dados]\\` - Cria ID no sistema NEEXT\n\nğŸ·ï¸ *STICKERS:*\nâ€¢ \\`${prefix}s\\` - Converte mÃ­dia em sticker\nâ€¢ \\`${prefix}rename [pack|author]\\` - Renomeia sticker\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ADMIN (comandos administrativos)\n// ========================\nfunction obterMenuAdmin() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ›¡ï¸ *COMANDOS ADMINISTRATIVOS*\n\nğŸ‘¥ *GERENCIAMENTO DE GRUPO:*\nâ€¢ \\`${prefix}marca\\` - Menciona todos os membros\nâ€¢ \\`${prefix}fechargrupo\\` / \\`${prefix}fechar\\` - Fecha o grupo\nâ€¢ \\`${prefix}abrirgrupo\\` / \\`${prefix}abrir\\` - Abre o grupo\nâ€¢ \\`${prefix}mudargrupo [nome]\\` - Altera nome do grupo\nâ€¢ \\`${prefix}resetlink\\` - Gera novo link do grupo\n\nğŸ—‘ï¸ *MODERAÃ‡ÃƒO:*\nâ€¢ \\`${prefix}del\\` - Deleta mensagem marcada\nâ€¢ \\`${prefix}ativarsolicitacao\\` - Ativa aprovaÃ§Ã£o de membros\nâ€¢ \\`${prefix}desativarsolicitacao\\` - Desativa aprovaÃ§Ã£o\nâ€¢ \\`${prefix}soloadmin\\` - Apenas admins editam grupo\n\nâš™ï¸ *CONFIGURAÃ‡Ã•ES:*\nâ€¢ \\`${prefix}antilink on/off\\` - Liga/desliga antilink\nâ€¢ \\`${prefix}modogamer on/off\\` - Liga/desliga modo gamer\nâ€¢ \\`${prefix}rpg on/off\\` - Liga/desliga sistema RPG\n\nğŸ“Š *STATUS:*\nâ€¢ \\`${prefix}grupo-status\\` - Status do grupo\nâ€¢ \\`${prefix}status-anti\\` - Status sistemas anti-spam\n\nâš ï¸ *Requer: Admin do grupo + Bot admin*\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DONO (comandos exclusivos)\n// ========================\nfunction obterMenuDono() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ‘‘ *COMANDOS DO DONO*\n\nâš™ï¸ *CONFIGURAÃ‡Ã•ES DO BOT:*\nâ€¢ \\`${prefix}trocar-prefixo [novo]\\` - Altera prefixo\nâ€¢ \\`${prefix}trocar-nome [novo]\\` - Altera nome do bot\nâ€¢ \\`${prefix}trocar-nick [novo]\\` - Altera nick do dono\nâ€¢ \\`${prefix}configurar-bot\\` - Guia de configuraÃ§Ãµes\n\nğŸ”§ *CONTROLE TOTAL:*\nâ€¢ Todos os comandos de admin funcionam\nâ€¢ Bypass de todas as restriÃ§Ãµes\nâ€¢ Controle completo sobre configuraÃ§Ãµes\n\nâš ï¸ *Acesso exclusivo para: ${nickDoDono}*\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DOWNLOAD (mÃ­dia e downloads)\n// ========================\nfunction obterMenuDownload() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ“¥ *DOWNLOADS E MÃDIA*\n\nğŸµ *MÃšSICA:*\nâ€¢ \\`${prefix}play [nome]\\` - Busca mÃºsica no YouTube\n\nğŸ“· *IMAGENS:*\nâ€¢ \\`${prefix}pinterest [busca]\\` - Imagens do Pinterest\nâ€¢ \\`${prefix}brat [texto]\\` - Gera imagem BRAT\n\nğŸ“± *REDES SOCIAIS:*\nâ€¢ \\`${prefix}ig [link]\\` - Download Instagram\nâ€¢ \\`${prefix}instagram [link]\\` - Download Instagram\n\nğŸ·ï¸ *STICKERS:*\nâ€¢ \\`${prefix}s\\` - Criar sticker de mÃ­dia\nâ€¢ \\`${prefix}rename [pack|author]\\` - Editar sticker\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU GAMER (jogos e entretenimento)\n// ========================\nfunction obterMenuGamer() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ® *JOGOS E ENTRETENIMENTO*\n\nâš ï¸ *Requer \\`${prefix}modogamer on\\` ativo no grupo*\n\nğŸ¯ *JOGOS INTERATIVOS:*\nâ€¢ \\`${prefix}jogodavelha @user\\` - Jogo da velha\nâ€¢ \\`${prefix}roletarussa @user\\` - Roleta russa\nâ€¢ \\`${prefix}disparar\\` - Atirar na roleta russa\nâ€¢ \\`${prefix}resetjogodavelha\\` - Reset jogo da velha\nâ€¢ \\`${prefix}resetroleta\\` - Reset roleta russa\n\nğŸ² *DIVERSÃƒO:*\nâ€¢ \\`${prefix}eununca\\` - Eu nunca poll\nâ€¢ \\`${prefix}impostor\\` - Escolhe impostor aleatÃ³rio\n\nğŸ’¥ *AÃ‡Ã•ES DIVERTIDAS:*\nâ€¢ \\`${prefix}tapa @user\\` - Dar tapa\nâ€¢ \\`${prefix}matar @user\\` - Matar alguÃ©m\nâ€¢ \\`${prefix}atirar @user\\` - Atirar em alguÃ©m\nâ€¢ \\`${prefix}atropelar @user\\` - Atropelar\nâ€¢ \\`${prefix}beijar @user\\` - Beijar alguÃ©m\nâ€¢ \\`${prefix}prender @user\\` - Prender alguÃ©m\nâ€¢ \\`${prefix}sarra @user\\` - Sarrar em alguÃ©m\nâ€¢ \\`${prefix}dedo @user\\` - Mostrar dedo\n\nğŸ“Š *RANKINGS DIVERTIDOS:*\nâ€¢ \\`${prefix}rankcorno\\` - Rank dos cornos\nâ€¢ \\`${prefix}rankgay\\` - Rank dos gays\nâ€¢ \\`${prefix}ranklesbica\\` - Rank das lÃ©sbicas\nâ€¢ \\`${prefix}rankburro\\` - Rank dos burros\nâ€¢ \\`${prefix}rankfeio\\` - Rank dos feios\nâ€¢ \\`${prefix}rankbonito\\` - Rank dos bonitos\nâ€¢ \\`${prefix}rankfumante\\` - Rank dos fumantes\nâ€¢ \\`${prefix}rankmaconheiro\\` - Rank dos maconheiros\nâ€¢ \\`${prefix}rankpobre\\` - Rank dos pobres\nâ€¢ \\`${prefix}ranksad\\` - Rank dos tristes\nâ€¢ \\`${prefix}rankemo\\` - Rank dos emos\nâ€¢ \\`${prefix}rankcasal\\` - Rank de casais\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ADM (todos os comandos de administradores)\n// ========================\nfunction obterMenuAdm() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ›¡ï¸ *COMANDOS DE ADMINISTRADORES*\n\nâš ï¸ *Requer: Admin do grupo + Bot admin*\n\nğŸ”— *SISTEMA ANTI-SPAM:*\nâ€¢ \\`${prefix}x9 on/off\\` - Anti-X9 Monitor\nâ€¢ \\`${prefix}antilink on/off\\` - Anti-links\nâ€¢ \\`${prefix}anticontato on/off\\` - Anti-contatos\nâ€¢ \\`${prefix}antidocumento on/off\\` - Anti-documentos\nâ€¢ \\`${prefix}antivideo on/off\\` - Anti-vÃ­deos\nâ€¢ \\`${prefix}antiaudio on/off\\` - Anti-Ã¡udios\nâ€¢ \\`${prefix}antisticker on/off\\` - Anti-stickers\nâ€¢ \\`${prefix}antiflod on/off\\` - Anti-flood\nâ€¢ \\`${prefix}antifake on/off\\` - Anti-nÃºmeros fake\n\nğŸ“‹ *LISTA NEGRA:*\nâ€¢ \\`${prefix}listanegra add @user\\` - Adicionar usuÃ¡rio\nâ€¢ \\`${prefix}listanegra remove @user\\` - Remover usuÃ¡rio\nâ€¢ \\`${prefix}listanegra list\\` - Ver lista negra\n\nğŸ—‘ï¸ *MODERAÃ‡ÃƒO:*\nâ€¢ \\`${prefix}del\\` - Deleta mensagem marcada\nâ€¢ \\`${prefix}marca\\` - Menciona todos os membros\n\nğŸ”’ *CONTROLE DO GRUPO:*\nâ€¢ \\`${prefix}fechargrupo\\` - Fecha o grupo\nâ€¢ \\`${prefix}abrirgrupo\\` - Abre o grupo\nâ€¢ \\`${prefix}mudargrupo [nome]\\` - Altera nome do grupo\nâ€¢ \\`${prefix}soloadmin\\` - SÃ³ admin edita grupo\nâ€¢ \\`${prefix}resetlink\\` - Gera novo link do grupo\n\nğŸ‘¥ *CONTROLE DE ENTRADA:*\nâ€¢ \\`${prefix}ativarsolicitacao\\` - Ativa aprovaÃ§Ã£o\nâ€¢ \\`${prefix}desativarsolicitacao\\` - Desativa aprovaÃ§Ã£o\n\nğŸ® *CONFIGURAÃ‡Ã•ES:*\nâ€¢ \\`${prefix}modogamer on/off\\` - Modo gamer\nâ€¢ \\`${prefix}grupo-status\\` - Status do grupo\n\nğŸ“¸ *PERSONALIZAÃ‡ÃƒO:*\nâ€¢ \\`${prefix}fotodogrupo\\` - Troca foto do grupo\nâ€¢ \\`${prefix}fotodobot\\` - Troca foto do bot\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU ANTI-SPAM\n// ========================\nfunction obterMenuAnti() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ›¡ï¸ *SISTEMA ANTI-SPAM*\n\nâš ï¸ *Requer: Admin + Bot admin*\n\nğŸ”— *PROTEÃ‡Ã•ES DISPONÃVEIS:*\nâ€¢ \\`${prefix}antilink on/off\\` - Anti-links\nâ€¢ \\`${prefix}anticontato on/off\\` - Anti-contatos\nâ€¢ \\`${prefix}antidocumento on/off\\` - Anti-documentos\nâ€¢ \\`${prefix}antivideo on/off\\` - Anti-vÃ­deos\nâ€¢ \\`${prefix}antiaudio on/off\\` - Anti-Ã¡udios\nâ€¢ \\`${prefix}antisticker on/off\\` - Anti-stickers\nâ€¢ \\`${prefix}antiflod on/off\\` - Anti-flood\nâ€¢ \\`${prefix}antifake on/off\\` - Anti-nÃºmeros fake\nâ€¢ \\`${prefix}x9 on/off\\` - Anti-X9\n\nğŸ“‹ *LISTA NEGRA:*\nâ€¢ \\`${prefix}listanegra add @user\\` - Adicionar Ã  lista\nâ€¢ \\`${prefix}listanegra remove @user\\` - Remover da lista\nâ€¢ \\`${prefix}listanegra list\\` - Ver lista negra\n\nğŸ“Š *STATUS:*\nâ€¢ \\`${prefix}status-anti\\` - Ver todas as proteÃ§Ãµes ativas\n\nğŸ”´ *AÃ‡ÃƒO: Delete automÃ¡tico + Ban (se bot for admin)*\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU RPG (sistema NeextCity)\n// ========================\nfunction obterMenuRPG() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ’° *SISTEMA RPG - NEEXTCITY*\n\nâš ï¸ *Requer \\`${prefix}rpg on\\` ativo no grupo*\n\nğŸ‘¤ *CADASTRO:*\nâ€¢ \\`${prefix}registrar [nome] [banco]\\` - Registrar no RPG\n\nğŸ’¼ *TRABALHOS:*\nâ€¢ \\`${prefix}pescar\\` - Pescar para ganhar gold\nâ€¢ \\`${prefix}minerar\\` - Minerar recursos\nâ€¢ \\`${prefix}trabalhar\\` - Trabalhar por gold\n\nğŸ° *JOGOS:*\nâ€¢ \\`${prefix}tigrinho [valor]\\` - CaÃ§a-nÃ­quel\nâ€¢ \\`${prefix}assalto @user\\` - Assaltar jogador\n\nğŸ“Š *INFORMAÃ‡Ã•ES:*\nâ€¢ \\`${prefix}saldo\\` - Ver seu saldo e stats\nâ€¢ \\`${prefix}rank\\` - Ranking dos mais ricos\n\nğŸ’¡ *Ganhe gold, compre itens e domine NeextCity!*\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU STICKERS (figurinhas)\n// ========================\nfunction obterMenuSticker() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ·ï¸ *MENU DE STICKERS*\n\nâœ¨ *CRIAR STICKERS:*\nâ€¢ \\`${prefix}s\\` - Converte mÃ­dia em sticker\nâ€¢ \\`${prefix}sticker\\` - Criar sticker de imagem/vÃ­deo\nâ€¢ \\`${prefix}attp [texto]\\` - Sticker de texto animado\nâ€¢ \\`${prefix}ttp [texto]\\` - Sticker de texto simples\n\nğŸ¨ *EDITAR STICKERS:*\nâ€¢ \\`${prefix}rename [pack|author]\\` - Renomear sticker\nâ€¢ \\`${prefix}take [pack] [author]\\` - Roubar sticker\nâ€¢ \\`${prefix}toimg\\` - Converter sticker em imagem\n\nğŸ­ *STICKERS ESPECIAIS:*\nâ€¢ \\`${prefix}emoji [emoji]\\` - Sticker de emoji\nâ€¢ \\`${prefix}semoji [emoji]\\` - Sticker emoji simples\n\nğŸ“ *COMO USAR:*\nâ€¢ Envie uma imagem/vÃ­deo com \\`${prefix}s\\`\nâ€¢ Marque um sticker e use \\`${prefix}take\\`\nâ€¢ Use \\`${prefix}rename\\` para personalizar\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU BRINCADEIRAS (coming soon)\n// ========================\nfunction obterMenuBrincadeira() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ‰ *MENU BRINCADEIRAS*\n\nâš ï¸ *EM DESENVOLVIMENTO*\n\nğŸš§ Este menu estÃ¡ sendo finalizado e em breve terÃ¡:\n\nğŸ­ **Comandos de DiversÃ£o:**\nâ€¢ Roleta de perguntas\nâ€¢ Verdade ou desafio\nâ€¢ Simulador de namorados\nâ€¢ Gerador de casais aleatÃ³rios\n\nğŸ² **InteraÃ§Ãµes Divertidas:**\nâ€¢ Perguntas para o grupo\nâ€¢ Desafios aleatÃ³rios\nâ€¢ Brincadeiras de grupo\n\nğŸ“… **Status:** Em desenvolvimento\nâ° **PrevisÃ£o:** PrÃ³xima atualizaÃ§Ã£o\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU HENTAI (coming soon)\n// ========================\nfunction obterMenuHentai() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ” *MENU HENTAI*\n\nâš ï¸ *EM DESENVOLVIMENTO*\n\nğŸš§ Este menu estÃ¡ sendo finalizado e em breve terÃ¡:\n\nğŸ¨ **ConteÃºdo ArtÃ­stico:**\nâ€¢ Imagens de anime\nâ€¢ Wallpapers temÃ¡ticos\nâ€¢ Arte digital\n\nâš ï¸ **Importante:**\nâ€¢ ConteÃºdo serÃ¡ adequado Ã s diretrizes\nâ€¢ Uso responsÃ¡vel obrigatÃ³rio\nâ€¢ Apenas em grupos privados\n\nğŸ“… **Status:** Em desenvolvimento\nâ° **PrevisÃ£o:** PrÃ³xima atualizaÃ§Ã£o\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// MENU DONO AVANÃ‡ADO (coming soon)\n// ========================\nfunction obterMenuDonoAvancado() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nğŸ‘‘ *MENU DONO AVANÃ‡ADO*\n\nâš ï¸ *EM DESENVOLVIMENTO*\n\nğŸš§ Este menu estÃ¡ sendo finalizado e em breve terÃ¡:\n\nğŸ”§ **Controle Total:**\nâ€¢ Backup de configuraÃ§Ãµes\nâ€¢ Gerenciamento de grupos em massa\nâ€¢ Logs detalhados do sistema\nâ€¢ Controle de usuÃ¡rios globais\n\nâš™ï¸ **ConfiguraÃ§Ãµes AvanÃ§adas:**\nâ€¢ Auto-moderaÃ§Ã£o inteligente\nâ€¢ Respostas automÃ¡ticas personalizadas\nâ€¢ Sistema de recompensas\n\nğŸ“… **Status:** Em desenvolvimento\nâ° **PrevisÃ£o:** PrÃ³xima atualizaÃ§Ã£o\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\n// ========================\n// GUIA DE CONFIGURAÃ‡ÃƒO\n// ========================\nfunction obterConfigurarBot() {\n    const { prefix, nomeDoBot, nickDoDono } = obterConfiguracoes();\n    return `\nâš™ï¸ *CONFIGURAR BOT - GUIA COMPLETO*\n\nğŸ”§ *COMANDOS DE CONFIGURAÃ‡ÃƒO (Apenas Dono):*\n\nğŸ“ *ALTERAR PREFIXO:*\n\\`${prefix}trocar-prefixo [novo]\\`\n*Exemplo:* \\`${prefix}trocar-prefixo !\\`\n*Resultado:* Prefixo mudarÃ¡ de \"${prefix}\" para \"!\"\n\nğŸ¤– *ALTERAR NOME DO BOT:*\n\\`${prefix}trocar-nome [novo nome]\\`\n*Exemplo:* \\`${prefix}trocar-nome MeuBot IncrÃ­vel\\`\n*Resultado:* Nome mudarÃ¡ de \"${nomeDoBot}\"\n\nğŸ‘¤ *ALTERAR NICK DO DONO:*\n\\`${prefix}trocar-nick [novo nick]\\`\n*Exemplo:* \\`${prefix}trocar-nick Administrador\\`\n*Resultado:* Nick mudarÃ¡ de \"${nickDoDono}\"\n\nğŸ“‹ *CONFIGURAÃ‡Ã•ES ATUAIS:*\nâ€¢ **Prefixo:** ${prefix}\nâ€¢ **Nome do Bot:** ${nomeDoBot}\nâ€¢ **Nick do Dono:** ${nickDoDono}\n\nâš ï¸ *IMPORTANTE:*\nâ€¢ Apenas o dono pode usar esses comandos\nâ€¢ As mudanÃ§as sÃ£o aplicadas instantaneamente\nâ€¢ ConfiguraÃ§Ãµes sÃ£o salvas automaticamente\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nÂ© NEEXT LTDA - ${nickDoDono}\n`;\n}\n\nmodule.exports = {\n    obterMenuPrincipal,\n    obterMenuMembro,\n    obterMenuAdmin,\n    obterMenuAdm,\n    obterMenuDono,\n    obterMenuDownload,\n    obterMenuGamer,\n    obterMenuAnti,\n    obterMenuRPG,\n    obterMenuSticker,\n    obterMenuBrincadeira,\n    obterMenuHentai,\n    obterMenuDonoAvancado,\n    obterConfigurarBot\n};","size_bytes":17723},"arquivos/funcoes/function.js":{"content":"// ---------------------------\n// Pacotes\n// ---------------------------\nconst cfonts = require(\"cfonts\");\n\n// ---------------------------\n// ConfiguraÃ§Ãµes do Bot\n// ---------------------------\nconst settings = require(\"../../settings/settings.json\");\nconst prefix = settings.prefix || \".\";\nconst botNome = settings.nomeDoBot || \"NEEXT BOT\";\n\n// ---------------------------\n// Banner do bot\n// ---------------------------\nfunction mostrarBanner() {\n    console.clear();\n\n    // NEEXT em roxo sÃ³lido\n    cfonts.say(\"NEEXT\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    // LTDA em roxo sÃ³lido\n    cfonts.say(\"LTDA\", {\n        font: \"block\",\n        align: \"center\",\n        colors: [\"#800080\"], // roxo real\n        background: \"transparent\",\n        letterSpacing: 1,\n        space: true\n    });\n\n    console.log(\"\\n\");\n}\n\n// ---------------------------\n// Logs simples (sem duplicaÃ§Ã£o e sem criar arquivos)\n// ---------------------------\nconst mensagensRegistradas = new Set();\n\nfunction logMensagem(m, text = \"\", isCommand = false) {\n    const fromMe = m?.key?.fromMe || false;\n    const jid = m?.key?.remoteJid || \"\";\n    const isGroup = jid.endsWith(\"@g.us\") || jid.endsWith(\"@lid\");\n    const sender = (m?.key?.participant || jid)?.split(\"@\")[0] || \"desconhecido\";\n    const pushName = m?.pushName || \"Sem nome\";\n\n    const conteudo = text || (() => {\n        if (m?.message?.conversation) return m.message.conversation;\n        if (m?.message?.extendedTextMessage?.text) return m.message.extendedTextMessage.text;\n        if (m?.message?.imageMessage?.caption) return m.message.imageMessage.caption;\n        if (m?.message?.videoMessage?.caption) return m.message.videoMessage.caption;\n        return \"[conteÃºdo nÃ£o suportado]\";\n    })();\n\n    // Evita duplicaÃ§Ã£o\n    const logKey = `${fromMe}-${jid}-${conteudo}`;\n    if (mensagensRegistradas.has(logKey)) return;\n    mensagensRegistradas.add(logKey);\n\n    const tipo = isCommand || (conteudo.startsWith(prefix)) ? \"[COMANDO]\" : \"[MENSAGEM]\";\n    const local = isGroup ? \"GRUPO\" : \"PV\";\n    const remetente = `${pushName} (${sender})${fromMe ? \" [EU]\" : \"\"}`;\n\n    const logText = `\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n${tipo} ${local}\nDe: ${remetente}\nConteÃºdo: ${conteudo}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;\n\n    console.log(logText);\n}\n\n// ---------------------------\n// FunÃ§Ã£o para buscar buffer de URL\n// ---------------------------\nasync function getBuffer(url) {\n    try {\n        const response = await require('axios').get(url, { responseType: 'arraybuffer' });\n        return Buffer.from(response.data);\n    } catch (error) {\n        console.error('Erro ao buscar buffer da URL:', error);\n        throw error;\n    }\n}\n\n// FunÃ§Ã£o para formatar JID\nfunction formatJid(jid) {\n    return String(jid || \"\").replace(/@s\\.whatsapp\\.net|@g\\.us|@lid/g,'');\n}\n\n// ---------------------------\n// FunÃ§Ã£o para saudaÃ§Ã£o baseada no horÃ¡rio\n// ---------------------------\nfunction obterSaudacao() {\n    const moment = require('moment-timezone');\n    const hora = moment().tz('America/Sao_Paulo').hour();\n    \n    if (hora >= 6 && hora < 12) {\n        return \"ğŸŒ… Bom dia\";\n    } else if (hora >= 12 && hora < 18) {\n        return \"â˜€ï¸ Boa tarde\";\n    } else if (hora >= 18 && hora < 24) {\n        return \"ğŸŒ™ Boa noite\";\n    } else {\n        return \"ğŸŒƒ Boa madrugada\";\n    }\n}\n\n// ---------------------------\n// FunÃ§Ã£o para contar grupos\n// ---------------------------\nasync function contarGrupos(sock) {\n    try {\n        const grupos = await sock.groupFetchAllParticipating();\n        return Object.keys(grupos).length;\n    } catch (error) {\n        console.error('Erro ao contar grupos:', error);\n        return 0;\n    }\n}\n\n// ---------------------------\n// FunÃ§Ã£o para contar comandos automaticamente\n// ---------------------------\nfunction contarComandos() {\n    try {\n        const fs = require('fs');\n        const path = require('path');\n        \n        // LÃª o arquivo index.js\n        const indexPath = path.join(__dirname, '../../index.js');\n        const indexContent = fs.readFileSync(indexPath, 'utf8');\n        \n        // Procura por todos os cases no switch da funÃ§Ã£o handleCommand\n        const casePattern = /case\\s+\"([^\"]+)\"/g;\n        const matches = [];\n        let match;\n        \n        while ((match = casePattern.exec(indexContent)) !== null) {\n            // Evita duplicatas e ignora cases internos como break cases\n            if (!matches.includes(match[1])) {\n                matches.push(match[1]);\n            }\n        }\n        \n        console.log(`ğŸ“Š Total de comandos encontrados automaticamente: ${matches.length}`);\n        return matches.length;\n    } catch (error) {\n        console.error('âŒ Erro ao contar comandos automaticamente:', error);\n        // Fallback para contagem manual se houver erro\n        return 25; // estimativa atual\n    }\n}\n\n// ---------------------------\n// ExportaÃ§Ãµes\n// ---------------------------\nmodule.exports = {\n    mostrarBanner,\n    logMensagem,\n    formatJid,\n    getBuffer,\n    obterSaudacao,\n    contarGrupos,\n    contarComandos\n};","size_bytes":5361},"arquivos/antispam.js":{"content":"// Sistema Anti-Spam Completo para WhatsApp Bot\nconst fs = require('fs');\nconst path = require('path');\n\n// DiretÃ³rios do sistema\nconst GRUPOS_DIR = path.join(__dirname, '../database/grupos/ativadogrupo');\nconst CACHE_FLOOD = new Map(); // Cache para controle de flood\n\n// UtilitÃ¡rios\nfunction formatGroupId(groupId) {\n    return groupId.replace('@g.us', '').replace('@lid', '').replace(/[^a-zA-Z0-9]/g, '_');\n}\n\n// Verifica se nÃºmero Ã© brasileiro\nfunction isNumeroBrasileiro(jid) {\n    if (!jid || typeof jid !== 'string') return false;\n    \n    // Remove o @s.whatsapp.net para pegar apenas o nÃºmero\n    const numero = jid.replace('@s.whatsapp.net', '');\n    \n    // Verifica se comeÃ§a com 55 (cÃ³digo do Brasil)\n    // Formatos aceitos: 55XXXXXXXXXXX (13 dÃ­gitos) ou 5511XXXXXXXXX (12 dÃ­gitos para alguns casos)\n    const brasileiroRegex = /^55[1-9][0-9]{8,9}$/;\n    \n    return brasileiroRegex.test(numero);\n}\n\nfunction getGroupConfigPath(groupId) {\n    const formattedId = formatGroupId(groupId);\n    return path.join(GRUPOS_DIR, `${formattedId}.json`);\n}\n\n// Carrega configuraÃ§Ã£o de um grupo\nfunction carregarConfigGrupo(groupId) {\n    try {\n        const configPath = getGroupConfigPath(groupId);\n        if (!fs.existsSync(configPath)) {\n            return {\n                antilink: false,\n                anticontato: false,\n                antidocumento: false,\n                antivideo: false,\n                antiaudio: false,\n                antisticker: false,\n                antiflod: false,\n                antifake: false,\n                x9: false,\n                modogamer: false,\n                listanegra: [],\n                floodConfig: {\n                    maxMensagens: 5,\n                    tempoSegundos: 10\n                }\n            };\n        }\n        const data = fs.readFileSync(configPath, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(`âŒ Erro ao carregar config do grupo ${groupId}:`, err);\n        return null;\n    }\n}\n\n// Salva configuraÃ§Ã£o de um grupo\nfunction salvarConfigGrupo(groupId, config) {\n    try {\n        // Garante que o diretÃ³rio existe\n        if (!fs.existsSync(GRUPOS_DIR)) {\n            fs.mkdirSync(GRUPOS_DIR, { recursive: true });\n        }\n        \n        const configPath = getGroupConfigPath(groupId);\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n        return true;\n    } catch (err) {\n        console.error(`âŒ Erro ao salvar config do grupo ${groupId}:`, err);\n        return false;\n    }\n}\n\n// Detecta links na mensagem\nfunction detectarLinks(texto) {\n    if (!texto) return false;\n    const linkRegex = /((https?:\\/\\/)|(www\\.))[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|wa.me\\/|whatsapp.com\\/|t.me\\/|chat.whatsapp.com\\/|instagram.com\\/|facebook.com\\/|twitter.com\\/|tiktok.com\\/|youtube.com\\/|discord.gg\\//i;\n    return linkRegex.test(texto);\n}\n\n// Verifica se Ã© contact/contato\nfunction isContactMessage(message) {\n    return !!(message.contactMessage || message.contactsArrayMessage);\n}\n\n// Verifica se Ã© documento\nfunction isDocumentMessage(message) {\n    return !!(message.documentMessage);\n}\n\n// Verifica se Ã© vÃ­deo\nfunction isVideoMessage(message) {\n    return !!(message.videoMessage);\n}\n\n// Verifica se Ã© Ã¡udio\nfunction isAudioMessage(message) {\n    return !!(message.audioMessage || message.pttMessage);\n}\n\n// Verifica se Ã© sticker\nfunction isStickerMessage(message) {\n    return !!(message.stickerMessage);\n}\n\n// Controle de flood\nfunction verificarFlood(userId, groupId, config) {\n    if (!config.antiflod) return false;\n    \n    const key = `${groupId}_${userId}`;\n    const agora = Date.now();\n    const limite = config.floodConfig.tempoSegundos * 1000;\n    \n    if (!CACHE_FLOOD.has(key)) {\n        CACHE_FLOOD.set(key, []);\n    }\n    \n    const mensagens = CACHE_FLOOD.get(key);\n    \n    // Remove mensagens antigas\n    const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < limite);\n    \n    // Adiciona nova mensagem\n    mensagensRecentes.push(agora);\n    CACHE_FLOOD.set(key, mensagensRecentes);\n    \n    // Verifica se excedeu o limite\n    return mensagensRecentes.length > config.floodConfig.maxMensagens;\n}\n\n// Limpa cache de flood periodicamente\nsetInterval(() => {\n    const agora = Date.now();\n    for (const [key, mensagens] of CACHE_FLOOD.entries()) {\n        const mensagensRecentes = mensagens.filter(timestamp => agora - timestamp < 60000); // 1 minuto\n        if (mensagensRecentes.length === 0) {\n            CACHE_FLOOD.delete(key);\n        } else {\n            CACHE_FLOOD.set(key, mensagensRecentes);\n        }\n    }\n}, 60000);\n\n// Verifica se usuÃ¡rio estÃ¡ na lista negra\nfunction isUsuarioListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    return config.listanegra.includes(userId);\n}\n\n// Adiciona usuÃ¡rio Ã  lista negra\nfunction adicionarListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    if (!config.listanegra) config.listanegra = [];\n    \n    if (!config.listanegra.includes(userId)) {\n        config.listanegra.push(userId);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // JÃ¡ estava na lista\n}\n\n// Remove usuÃ¡rio da lista negra\nfunction removerListaNegra(userId, groupId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config || !config.listanegra) return false;\n    \n    const index = config.listanegra.indexOf(userId);\n    if (index > -1) {\n        config.listanegra.splice(index, 1);\n        return salvarConfigGrupo(groupId, config);\n    }\n    return true; // NÃ£o estava na lista\n}\n\n// Ativa/desativa funcionalidade anti\nfunction toggleAntiFeature(groupId, feature, estado) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return false;\n    \n    const validFeatures = ['antilink', 'anticontato', 'antidocumento', 'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'x9'];\n    \n    if (!validFeatures.includes(feature)) return false;\n    \n    if (estado === 'on' || estado === 'ativar' || estado === '1') {\n        config[feature] = true;\n    } else if (estado === 'off' || estado === 'desativar' || estado === '0') {\n        config[feature] = false;\n    } else {\n        return config[feature]; // Retorna estado atual\n    }\n    \n    return salvarConfigGrupo(groupId, config) ? config[feature] : false;\n}\n\n// Processa mensagem para verificar violaÃ§Ãµes\nfunction processarMensagem(message, groupId, userId) {\n    const config = carregarConfigGrupo(groupId);\n    if (!config) return { violacao: false };\n    \n    const violations = [];\n    \n    // Extrai texto da mensagem\n    let texto = '';\n    if (message.conversation) texto = message.conversation;\n    if (message.extendedTextMessage?.text) texto = message.extendedTextMessage.text;\n    if (message.imageMessage?.caption) texto = message.imageMessage.caption;\n    if (message.videoMessage?.caption) texto = message.videoMessage.caption;\n    \n    // Verifica antilink\n    if (config.antilink && detectarLinks(texto)) {\n        violations.push('antilink');\n    }\n    \n    // Verifica anticontato\n    if (config.anticontato && isContactMessage(message)) {\n        violations.push('anticontato');\n    }\n    \n    // Verifica antidocumento\n    if (config.antidocumento && isDocumentMessage(message)) {\n        violations.push('antidocumento');\n    }\n    \n    // Verifica antivideo\n    if (config.antivideo && isVideoMessage(message)) {\n        violations.push('antivideo');\n    }\n    \n    // Verifica antiaudio\n    if (config.antiaudio && isAudioMessage(message)) {\n        violations.push('antiaudio');\n    }\n    \n    // Verifica antisticker\n    if (config.antisticker && isStickerMessage(message)) {\n        violations.push('antisticker');\n    }\n    \n    // Verifica antiflod\n    if (verificarFlood(userId, groupId, config)) {\n        violations.push('antiflod');\n    }\n    \n    return {\n        violacao: violations.length > 0,\n        tipos: violations,\n        config\n    };\n}\n\n// Exporta todas as funÃ§Ãµes\nmodule.exports = {\n    // Gerenciamento de configuraÃ§Ã£o\n    carregarConfigGrupo,\n    salvarConfigGrupo,\n    \n    // Toggle de funcionalidades\n    toggleAntiFeature,\n    \n    // Lista negra\n    isUsuarioListaNegra,\n    adicionarListaNegra,\n    removerListaNegra,\n    \n    // Processamento\n    processarMensagem,\n    \n    // DetecÃ§Ãµes especÃ­ficas\n    detectarLinks,\n    isContactMessage,\n    isDocumentMessage,\n    isVideoMessage,\n    isAudioMessage,\n    isStickerMessage,\n    verificarFlood,\n    isNumeroBrasileiro,\n    \n    // UtilitÃ¡rios\n    formatGroupId,\n    getGroupConfigPath\n};","size_bytes":8754},"arquivos/rpg.js":{"content":"// Sistema de RPG - NeextCity ENHANCED\nconst fs = require('fs');\nconst path = require('path');\n\n// Caminho para o arquivo de dados do RPG\nconst rpgDataFile = path.join(__dirname, '../database/grupos/rpg_data.json');\nconst moment = require('moment-timezone');\n\n// Sistema de Mutex simples para evitar race conditions\nlet rpgLock = false;\n\nasync function withLock(fn) {\n    while (rpgLock) {\n        await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    rpgLock = true;\n    try {\n        return await fn();\n    } finally {\n        rpgLock = false;\n    }\n}\n\n// Limites diÃ¡rios configurÃ¡veis\nconst DAILY_LIMITS = {\n    pesca: 10,\n    mineracao: 8,\n    trabalho: 6,\n    caca: 5,\n    agricultura: 7,\n    entrega: 4,\n    corrida: 3,\n    coleta: 15\n};\n\n// Sistema de configuraÃ§Ãµes dinÃ¢micas\nfunction obterConfiguracoes() {\n    try {\n        delete require.cache[require.resolve('../settings/settings.json')];\n        return require('../settings/settings.json');\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar configuraÃ§Ãµes RPG:\", err);\n        return {\n            prefix: \".\",\n            nomeDoBot: \"WhatsApp Bot\",\n            nickDoDono: \"Owner\",\n            numeroDoDono: \"5500000000000\"\n        };\n    }\n}\n\n// Bancos disponÃ­veis\nconst bancos = [\n    { id: 'caixa', nome: 'ğŸ¦ Caixa EconÃ´mica Federal', emoji: 'ğŸ¦' },\n    { id: 'santander', nome: 'ğŸ”´ Santander', emoji: 'ğŸ”´' },\n    { id: 'nubank', nome: 'ğŸ’œ Nubank', emoji: 'ğŸ’œ' },\n    { id: 'bradesco', nome: 'ğŸ”µ Bradesco', emoji: 'ğŸ”µ' },\n    { id: 'itau', nome: 'ğŸŸ  ItaÃº', emoji: 'ğŸŸ ' },\n    { id: 'bb', nome: 'ğŸŸ¡ Banco do Brasil', emoji: 'ğŸŸ¡' },\n    { id: 'pix', nome: 'ğŸ“± PIX', emoji: 'ğŸ“±' },\n    { id: 'inter', nome: 'ğŸ§¡ Inter', emoji: 'ğŸ§¡' }\n];\n\n// ==================== SISTEMA DE LOJA ====================\n// CatÃ¡logo completo de itens para compra\nconst catalogoItens = {\n    // PROPRIEDADES\n    propriedades: {\n        casa_simples: {\n            id: 'casa_simples',\n            nome: 'ğŸ  Casa Simples',\n            preco: 5000,\n            categoria: 'propriedades',\n            descricao: 'Uma casa bÃ¡sica para morar',\n            emoji: 'ğŸ ',\n            beneficio: 'Renda passiva: +50 gold/dia'\n        },\n        casa_luxo: {\n            id: 'casa_luxo', \n            nome: 'ğŸ˜ï¸ Casa de Luxo',\n            preco: 15000,\n            categoria: 'propriedades',\n            descricao: 'Uma mansÃ£o elegante',\n            emoji: 'ğŸ˜ï¸',\n            beneficio: 'Renda passiva: +150 gold/dia'\n        },\n        fazenda: {\n            id: 'fazenda',\n            nome: 'ğŸšœ Fazenda',\n            preco: 25000,\n            categoria: 'propriedades', \n            descricao: 'Terra para agricultura e criaÃ§Ã£o',\n            emoji: 'ğŸšœ',\n            beneficio: 'Permite agricultura e criaÃ§Ã£o'\n        },\n        posto_gasolina: {\n            id: 'posto_gasolina',\n            nome: 'â›½ Posto de Gasolina',\n            preco: 35000,\n            categoria: 'propriedades',\n            descricao: 'NegÃ³cio lucrativo',\n            emoji: 'â›½',\n            beneficio: 'Renda passiva: +300 gold/dia'\n        }\n    },\n    // ANIMAIS E CRIAÃ‡ÃƒO\n    animais: {\n        galinha: {\n            id: 'galinha',\n            nome: 'ğŸ” Galinha',\n            preco: 500,\n            categoria: 'animais',\n            descricao: 'Produz ovos diariamente',\n            emoji: 'ğŸ”',\n            beneficio: 'Produz 3 ovos/dia (30 gold cada)'\n        },\n        pato: {\n            id: 'pato',\n            nome: 'ğŸ¦† Pato', \n            preco: 800,\n            categoria: 'animais',\n            descricao: 'Pato para criaÃ§Ã£o',\n            emoji: 'ğŸ¦†',\n            beneficio: 'Produz carne valiosa'\n        },\n        cavalo: {\n            id: 'cavalo',\n            nome: 'ğŸ Cavalo',\n            preco: 8000,\n            categoria: 'animais',\n            descricao: 'Para corridas e transporte',\n            emoji: 'ğŸ',\n            beneficio: 'Permite corridas e +50% velocidade entrega'\n        },\n        gato: {\n            id: 'gato', \n            nome: 'ğŸ± Gato',\n            preco: 200,\n            categoria: 'animais',\n            descricao: 'Companheiro fiel',\n            emoji: 'ğŸ±',\n            beneficio: 'Traz sorte (+5% chance crÃ­tico)'\n        },\n        cachorro: {\n            id: 'cachorro',\n            nome: 'ğŸ¶ Cachorro',\n            preco: 300,\n            categoria: 'animais', \n            descricao: 'Melhor amigo do homem',\n            emoji: 'ğŸ¶',\n            beneficio: 'Protege contra assaltos (+20% defesa)'\n        },\n        vaca: {\n            id: 'vaca',\n            nome: 'ğŸ„ Vaca',\n            preco: 2500,\n            categoria: 'animais',\n            descricao: 'Produz leite fresco',\n            emoji: 'ğŸ„',\n            beneficio: 'Produz 5 litros leite/dia (25 gold cada)'\n        },\n        porco: {\n            id: 'porco',\n            nome: 'ğŸ· Porco', \n            preco: 1200,\n            categoria: 'animais',\n            descricao: 'CriaÃ§Ã£o rentÃ¡vel',\n            emoji: 'ğŸ·',\n            beneficio: 'Renda de 80 gold/dia'\n        }\n    },\n    // FERRAMENTAS E UPGRADES\n    ferramentas: {\n        vara_ouro: {\n            id: 'vara_ouro',\n            nome: 'ğŸ£ Vara de Ouro',\n            preco: 3000,\n            categoria: 'ferramentas',\n            descricao: 'Vara de pesca premium',\n            emoji: 'ğŸ£',\n            beneficio: '+25% chance peixes raros'\n        },\n        picareta_diamante: {\n            id: 'picareta_diamante',\n            nome: 'â›ï¸ Picareta de Diamante',\n            preco: 4500,\n            categoria: 'ferramentas',\n            descricao: 'Ferramenta de mineraÃ§Ã£o suprema',\n            emoji: 'â›ï¸',\n            beneficio: '+30% chance minerais valiosos'\n        },\n        trator: {\n            id: 'trator',\n            nome: 'ğŸšœ Trator',\n            preco: 12000,\n            categoria: 'ferramentas',\n            descricao: 'Para agricultura avanÃ§ada',\n            emoji: 'ğŸšœ',\n            beneficio: '+50% produÃ§Ã£o agrÃ­cola'\n        }\n    },\n    // VEÃCULOS\n    veiculos: {\n        bike: {\n            id: 'bike',\n            nome: 'ğŸš² Bicicleta',\n            preco: 800,\n            categoria: 'veiculos',\n            descricao: 'Transporte bÃ¡sico',\n            emoji: 'ğŸš²', \n            beneficio: '+10% velocidade trabalhos'\n        },\n        moto: {\n            id: 'moto',\n            nome: 'ğŸï¸ Motocicleta',\n            preco: 5000,\n            categoria: 'veiculos',\n            descricao: 'Para entregas rÃ¡pidas',\n            emoji: 'ğŸï¸',\n            beneficio: 'Habilita trabalho entregador'\n        },\n        carro: {\n            id: 'carro',\n            nome: 'ğŸš— Carro',\n            preco: 20000,\n            categoria: 'veiculos',\n            descricao: 'AutomÃ³vel confortÃ¡vel',\n            emoji: 'ğŸš—',\n            beneficio: 'Habilita trabalho uber (+200 gold/viagem)'\n        },\n        caminhao: {\n            id: 'caminhao',\n            nome: 'ğŸš› CaminhÃ£o',\n            preco: 45000,\n            categoria: 'veiculos',\n            descricao: 'Para cargas pesadas',\n            emoji: 'ğŸš›',\n            beneficio: 'Trabalho caminhoneiro (+500 gold/viagem)'\n        }\n    }\n};\n\n// Peixes disponÃ­veis para pesca\nconst peixes = [\n    { nome: 'Peixe Dourado', valor: 250, raridade: 'lendario', emoji: 'ğŸ ', chance: 2 },\n    { nome: 'SalmÃ£o', valor: 180, raridade: 'epico', emoji: 'ğŸŸ', chance: 5 },\n    { nome: 'Atum', valor: 120, raridade: 'raro', emoji: 'ğŸŸ', chance: 10 },\n    { nome: 'Sardinha', valor: 80, raridade: 'comum', emoji: 'ğŸŸ', chance: 25 },\n    { nome: 'TilÃ¡pia', valor: 60, raridade: 'comum', emoji: 'ğŸŸ', chance: 30 },\n    { nome: 'Bagre', valor: 40, raridade: 'comum', emoji: 'ğŸŸ', chance: 28 }\n];\n\n// Animais para caÃ§a\nconst animaisCaca = [\n    { nome: 'Javali', valor: 300, raridade: 'lendario', emoji: 'ğŸ—', chance: 3 },\n    { nome: 'Veado', valor: 200, raridade: 'epico', emoji: 'ğŸ¦Œ', chance: 8 },\n    { nome: 'Coelho', valor: 100, raridade: 'raro', emoji: 'ğŸ°', chance: 15 },\n    { nome: 'Pato Selvagem', valor: 80, raridade: 'comum', emoji: 'ğŸ¦†', chance: 30 },\n    { nome: 'Perdiz', valor: 60, raridade: 'comum', emoji: 'ğŸ¦', chance: 44 }\n];\n\n// Cultivos para agricultura\nconst cultivos = [\n    { nome: 'Milho', valor: 120, tempo: 60, emoji: 'ğŸŒ½', categoria: 'cereal' },\n    { nome: 'Tomate', valor: 100, tempo: 45, emoji: 'ğŸ…', categoria: 'verdura' },\n    { nome: 'Batata', valor: 80, tempo: 90, emoji: 'ğŸ¥”', categoria: 'tubÃ©rculo' },\n    { nome: 'Cenoura', valor: 70, tempo: 30, emoji: 'ğŸ¥•', categoria: 'verdura' },\n    { nome: 'Alface', valor: 50, tempo: 20, emoji: 'ğŸ¥¬', categoria: 'folha' }\n];\n\n// Minerais disponÃ­veis para mineraÃ§Ã£o\nconst minerais = [\n    { nome: 'Diamante', valor: 500, raridade: 'lendario', emoji: 'ğŸ’', chance: 1 },\n    { nome: 'Ouro', valor: 300, raridade: 'epico', emoji: 'ğŸ¥‡', chance: 3 },\n    { nome: 'Prata', valor: 200, raridade: 'raro', emoji: 'ğŸ¥ˆ', chance: 8 },\n    { nome: 'Ferro', valor: 100, raridade: 'comum', emoji: 'âš¡', chance: 25 },\n    { nome: 'Cobre', valor: 60, raridade: 'comum', emoji: 'ğŸŸ¤', chance: 35 },\n    { nome: 'CarvÃ£o', valor: 30, raridade: 'comum', emoji: 'âš«', chance: 28 }\n];\n\n// Trabalhos disponÃ­veis  \nconst trabalhos = [\n    { nome: 'Programador', salario: 150, emoji: 'ğŸ’»', requisito: null },\n    { nome: 'MÃ©dico', salario: 200, emoji: 'ğŸ‘¨â€âš•ï¸', requisito: null },\n    { nome: 'Professor', salario: 120, emoji: 'ğŸ‘¨â€ğŸ«', requisito: null },\n    { nome: 'Vendedor', salario: 100, emoji: 'ğŸ‘¨â€ğŸ’¼', requisito: null },\n    { nome: 'Motorista', salario: 80, emoji: 'ğŸš—', requisito: null },\n    { nome: 'SeguranÃ§a', salario: 90, emoji: 'ğŸ›¡ï¸', requisito: null },\n    { nome: 'Entregador', salario: 120, emoji: 'ğŸï¸', requisito: 'moto' },\n    { nome: 'Uber', salario: 200, emoji: 'ğŸš—', requisito: 'carro' },\n    { nome: 'Caminhoneiro', salario: 500, emoji: 'ğŸš›', requisito: 'caminhao' },\n    { nome: 'Fazendeiro', salario: 180, emoji: 'ğŸšœ', requisito: 'fazenda' }\n];\n\n// Imagens do sistema\nconst imagens = {\n    pesca: [\n        'https://i.ibb.co/TMyLLC3R/41c684278e9f0d135ebc9e256b48868a.jpg',\n        'https://i.ibb.co/DXvzXGn/20d09f32ae9946cd9ea3157f9c15185a.jpg'\n    ],\n    mineracao: [\n        'https://i.ibb.co/zWsQKzYn/fd4e0eac6d004504ca5a16413fa90ad6.jpg', \n        'https://i.ibb.co/5hyff8B4/3b938d5b6b50323e58414c9edb72053b.jpg'\n    ],\n    tigrinho: [\n        'https://i.ibb.co/xG9QxjD/tigrinho-cassino-1.jpg',\n        'https://i.ibb.co/yNpL4zV/tigrinho-cassino-2.jpg',\n        'https://i.ibb.co/RQfvXdt/tigrinho-perdeu-tudo.jpg'\n    ],\n    trabalho: [\n        'https://i.ibb.co/hL8tKyS/trabalho-escritorio.jpg',\n        'https://i.ibb.co/QdR4fVp/trabalho-construcao.jpg'\n    ],\n    caca: [\n        'https://i.ibb.co/mNvLFzD/cacador-floresta.jpg',\n        'https://i.ibb.co/KWp2YjS/caca-animais.jpg' \n    ],\n    agricultura: [\n        'https://i.ibb.co/yX8bJgT/fazenda-plantacao.jpg',\n        'https://i.ibb.co/VHGKqNf/agricultura-colheita.jpg'\n    ],\n    loja: [\n        'https://i.ibb.co/pWqKbZR/loja-neext-city.jpg',\n        'https://i.ibb.co/dMfQxYG/compras-rpg.jpg'\n    ],\n    pix: [\n        'https://i.ibb.co/XsRtKgD/pix-transferencia.jpg',\n        'https://i.ibb.co/qjPgHmW/pix-banco.jpg'\n    ],\n    corrida: [\n        'https://i.ibb.co/kDgHtNm/corrida-cavalos.jpg',\n        'https://i.ibb.co/7Y4pbLz/hipismo-corrida.jpg'\n    ]\n};\n\n// Frases motivacionais\nconst frasesMotivacionais = [\n    'ğŸ’ª Continue trabalhando duro!',\n    'ğŸŒŸ VocÃª estÃ¡ no caminho certo!',\n    'ğŸš€ Rumo ao sucesso em NeextCity!',\n    'ğŸ’° O dinheiro nÃ£o dorme!',\n    'ğŸ† Seja o melhor de NeextCity!'\n];\n\n// Carrega dados do RPG\nfunction carregarDadosRPG() {\n    try {\n        if (!fs.existsSync(rpgDataFile)) {\n            const dir = path.dirname(rpgDataFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(rpgDataFile, JSON.stringify({ grupos: {}, jogadores: {} }, null, 2));\n        }\n        const data = fs.readFileSync(rpgDataFile, 'utf-8');\n        return JSON.parse(data);\n    } catch (err) {\n        console.error('âŒ Erro ao carregar dados RPG:', err);\n        return { grupos: {}, jogadores: {} };\n    }\n}\n\n// FunÃ§Ã£o para garantir estrutura completa do usuÃ¡rio\nfunction ensureUserDefaults(usuario) {\n    const hoje = moment().tz('America/Sao_Paulo').format('YYYY-MM-DD');\n    \n    return {\n        nome: usuario.nome || 'Jogador',\n        banco: usuario.banco || bancos[0],\n        saldo: usuario.saldo || 100,\n        registrado: usuario.registrado || new Date().toISOString(),\n        \n        // InventÃ¡rio e propriedades\n        inventario: usuario.inventario || {},\n        propriedades: usuario.propriedades || {},\n        \n        // Contadores de atividades\n        pescasFeitas: usuario.pescasFeitas || 0,\n        mineracoesFeitas: usuario.mineracoesFeitas || 0,\n        trabalhosFeitos: usuario.trabalhosFeitos || 0,\n        assaltosFeitos: usuario.assaltosFeitos || 0,\n        cacasFeitas: usuario.cacasFeitas || 0,\n        agriculturasFeitas: usuario.agriculturasFeitas || 0,\n        entregasFeitas: usuario.entregasFeitas || 0,\n        corridasFeitas: usuario.corridasFeitas || 0,\n        coletasFeitas: usuario.coletasFeitas || 0,\n        \n        // Ãšltima vez que fez cada atividade\n        ultimaPesca: usuario.ultimaPesca || 0,\n        ultimaMineracao: usuario.ultimaMineracao || 0,\n        ultimoTrabalho: usuario.ultimoTrabalho || 0,\n        ultimoAssalto: usuario.ultimoAssalto || 0,\n        ultimaCaca: usuario.ultimaCaca || 0,\n        ultimaAgricultura: usuario.ultimaAgricultura || 0,\n        ultimaEntrega: usuario.ultimaEntrega || 0,\n        ultimaCorrida: usuario.ultimaCorrida || 0,\n        ultimaColeta: usuario.ultimaColeta || 0,\n        \n        // Sistema de limites diÃ¡rios\n        limites: usuario.limites || {},\n        limitesData: usuario.limitesData || hoje,\n        \n        // Cultivos em andamento\n        cultivos: usuario.cultivos || [],\n        \n        // HistÃ³rico de PIX\n        pixEnviados: usuario.pixEnviados || [],\n        pixRecebidos: usuario.pixRecebidos || [],\n        \n        // EstatÃ­sticas especiais\n        totalGanho: usuario.totalGanho || 0,\n        totalGasto: usuario.totalGasto || 0,\n        maiorGanho: usuario.maiorGanho || 0,\n        tigrinhoJogadas: usuario.tigrinhoJogadas || 0,\n        tigrinhoPerdas: usuario.tigrinhoPerdas || 0\n    };\n}\n\n// Reseta limites diÃ¡rios se necessÃ¡rio\nfunction resetDailyLimitsIfNeeded(usuario) {\n    const hoje = moment().tz('America/Sao_Paulo').format('YYYY-MM-DD');\n    \n    if (usuario.limitesData !== hoje) {\n        usuario.limites = {};\n        usuario.limitesData = hoje;\n        \n        // Coleta automÃ¡tica de renda passiva\n        let rendaPassiva = 0;\n        if (usuario.propriedades) {\n            Object.keys(usuario.propriedades).forEach(propId => {\n                const item = catalogoItens.propriedades[propId];\n                if (item && item.beneficio.includes('Renda passiva')) {\n                    const valor = parseInt(item.beneficio.match(/\\d+/)?.[0] || 0);\n                    rendaPassiva += valor * (usuario.propriedades[propId] || 1);\n                }\n            });\n        }\n        \n        if (rendaPassiva > 0) {\n            usuario.saldo += rendaPassiva;\n            usuario.totalGanho += rendaPassiva;\n        }\n    }\n    \n    return usuario;\n}\n\n// Salva dados do RPG\nfunction salvarDadosRPG(data) {\n    try {\n        fs.writeFileSync(rpgDataFile, JSON.stringify(data, null, 2));\n        return true;\n    } catch (err) {\n        console.error('âŒ Erro ao salvar dados RPG:', err);\n        return false;\n    }\n}\n\n// Verifica se RPG estÃ¡ ativo no grupo\nfunction isRPGAtivo(groupId) {\n    const dados = carregarDadosRPG();\n    return dados.grupos[groupId]?.ativo || false;\n}\n\n// Ativa/desativa RPG no grupo\nfunction toggleRPG(groupId, ativo) {\n    const dados = carregarDadosRPG();\n    if (!dados.grupos[groupId]) {\n        dados.grupos[groupId] = { ativo: false, jogadores: [] };\n    }\n    dados.grupos[groupId].ativo = ativo;\n    return salvarDadosRPG(dados);\n}\n\n// Verifica se usuÃ¡rio estÃ¡ registrado\nfunction isUsuarioRegistrado(userId) {\n    const dados = carregarDadosRPG();\n    return !!dados.jogadores[userId];\n}\n\n// Registra novo usuÃ¡rio\nfunction registrarUsuario(userId, nome, bancoId) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        const banco = bancos.find(b => b.id === bancoId);\n        if (!banco) return false;\n\n        const novoUsuario = {\n            nome: nome,\n            banco: banco,\n            saldo: 100 // Saldo inicial\n        };\n\n        dados.jogadores[userId] = ensureUserDefaults(novoUsuario);\n        return salvarDadosRPG(dados);\n    });\n}\n\n// ObtÃ©m dados do usuÃ¡rio\nfunction obterDadosUsuario(userId) {\n    const dados = carregarDadosRPG();\n    let usuario = dados.jogadores[userId];\n    if (!usuario) return null;\n    \n    usuario = ensureUserDefaults(usuario);\n    usuario = resetDailyLimitsIfNeeded(usuario);\n    \n    return usuario;\n}\n\n// ==================== SISTEMA PIX ====================\n// FunÃ§Ã£o para transferir dinheiro entre jogadores\nfunction pixTransferir(deUserId, paraUserId, valor, deNome, paraNome) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        \n        let usuarioDe = dados.jogadores[deUserId];\n        let usuarioPara = dados.jogadores[paraUserId];\n        \n        if (!usuarioDe) return { erro: 'VocÃª nÃ£o estÃ¡ registrado no RPG' };\n        if (!usuarioPara) return { erro: 'DestinatÃ¡rio nÃ£o estÃ¡ registrado no RPG' };\n        \n        usuarioDe = ensureUserDefaults(usuarioDe);\n        usuarioPara = ensureUserDefaults(usuarioPara);\n        \n        if (deUserId === paraUserId) return { erro: 'NÃ£o Ã© possÃ­vel transferir para si mesmo' };\n        if (valor <= 0) return { erro: 'Valor deve ser positivo' };\n        if (valor < 10) return { erro: 'Valor mÃ­nimo para PIX Ã© 10 Gold' };\n        if (usuarioDe.saldo < valor) return { erro: `Saldo insuficiente. VocÃª tem ${usuarioDe.saldo} Gold` };\n        \n        // Taxa de 2% para transferÃªncias\n        const taxa = Math.floor(valor * 0.02);\n        const valorFinal = valor - taxa;\n        \n        // Realiza a transferÃªncia\n        usuarioDe.saldo -= valor;\n        usuarioPara.saldo += valorFinal;\n        \n        // Registra no histÃ³rico\n        const agora = new Date().toISOString();\n        const pixEnviado = {\n            para: paraUserId,\n            paraNome: paraNome || usuarioPara.nome,\n            valor: valor,\n            taxa: taxa,\n            valorFinal: valorFinal,\n            data: agora\n        };\n        \n        const pixRecebido = {\n            de: deUserId,\n            deNome: deNome || usuarioDe.nome,\n            valor: valorFinal,\n            data: agora\n        };\n        \n        usuarioDe.pixEnviados.push(pixEnviado);\n        usuarioPara.pixRecebidos.push(pixRecebido);\n        \n        // Limita histÃ³rico a 50 transaÃ§Ãµes\n        if (usuarioDe.pixEnviados.length > 50) usuarioDe.pixEnviados.shift();\n        if (usuarioPara.pixRecebidos.length > 50) usuarioPara.pixRecebidos.shift();\n        \n        dados.jogadores[deUserId] = usuarioDe;\n        dados.jogadores[paraUserId] = usuarioPara;\n        \n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            valor: valor,\n            taxa: taxa,\n            valorFinal: valorFinal,\n            saldoRemetente: usuarioDe.saldo,\n            saldoDestinatario: usuarioPara.saldo,\n            mensagem: `ğŸ’¸ **PIX REALIZADO COM SUCESSO!** âœ…\\n\\n` +\n                     `ğŸ‘¤ **De:** ${usuarioDe.nome}\\n` +\n                     `ğŸ‘¤ **Para:** ${usuarioPara.nome}\\n` +\n                     `ğŸ’° **Valor:** ${valor} Gold\\n` +\n                     `ğŸ’³ **Taxa (2%):** ${taxa} Gold\\n` +\n                     `âœ… **Recebido:** ${valorFinal} Gold\\n\\n` +\n                     `ğŸ¦ **Seu saldo atual:** ${usuarioDe.saldo} Gold\\n\\n` +\n                     `â° **Data:** ${new Date().toLocaleString('pt-BR')}`\n        };\n    });\n}\n\n// Atualiza saldo do usuÃ¡rio\nfunction atualizarSaldo(userId, novoSaldo) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        if (dados.jogadores[userId]) {\n            dados.jogadores[userId].saldo = novoSaldo;\n            return salvarDadosRPG(dados);\n        }\n        return false;\n    });\n}\n\n// ==================== SISTEMA DE LOJA ====================\n// Comprar item da loja\nfunction comprarItem(userId, itemId, quantidade = 1) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n        \n        usuario = ensureUserDefaults(usuario);\n        \n        // Procura o item em todas as categorias\n        let item = null;\n        let categoria = null;\n        \n        Object.keys(catalogoItens).forEach(cat => {\n            if (catalogoItens[cat][itemId]) {\n                item = catalogoItens[cat][itemId];\n                categoria = cat;\n            }\n        });\n        \n        if (!item) return { erro: 'Item nÃ£o encontrado na loja' };\n        \n        const custoTotal = item.preco * quantidade;\n        if (usuario.saldo < custoTotal) {\n            return { erro: `Saldo insuficiente! VocÃª precisa de ${custoTotal} Gold (tem ${usuario.saldo} Gold)` };\n        }\n        \n        // Realiza a compra\n        usuario.saldo -= custoTotal;\n        usuario.totalGasto += custoTotal;\n        \n        if (categoria === 'propriedades') {\n            usuario.propriedades[itemId] = (usuario.propriedades[itemId] || 0) + quantidade;\n        } else {\n            usuario.inventario[itemId] = (usuario.inventario[itemId] || 0) + quantidade;\n        }\n        \n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            item: item,\n            quantidade: quantidade,\n            custoTotal: custoTotal,\n            saldo: usuario.saldo,\n            mensagem: `ğŸ›’ **COMPRA REALIZADA!** âœ…\\n\\n` +\n                     `${item.emoji} **${item.nome}**\\n` +\n                     `ğŸ“¦ **Quantidade:** ${quantidade}\\n` +\n                     `ğŸ’° **Custo total:** ${custoTotal} Gold\\n` +\n                     `ğŸ’¡ **BenefÃ­cio:** ${item.beneficio}\\n\\n` +\n                     `ğŸ¦ **Saldo restante:** ${usuario.saldo} Gold`,\n            imagem: imagens.loja[Math.floor(Math.random() * imagens.loja.length)]\n        };\n    });\n}\n\n// Listar itens da loja por categoria\nfunction listarLoja(categoria = null) {\n    const config = obterConfiguracoes();\n    let mensagem = 'ğŸª **LOJA NEEXTCITY** ğŸª\\n\\n';\n    \n    if (categoria && catalogoItens[categoria]) {\n        const itens = catalogoItens[categoria];\n        mensagem += `ğŸ“‚ **Categoria: ${categoria.toUpperCase()}**\\n\\n`;\n        \n        Object.values(itens).forEach(item => {\n            mensagem += `${item.emoji} **${item.nome}**\\n`;\n            mensagem += `   ğŸ’° **PreÃ§o:** ${item.preco} Gold\\n`;\n            mensagem += `   ğŸ’¡ **BenefÃ­cio:** ${item.beneficio}\\n`;\n            mensagem += `   ğŸ›’ **Comprar:** \\`${config.prefix}comprar ${item.id}\\`\\n\\n`;\n        });\n    } else {\n        mensagem += 'ğŸ“‚ **CATEGORIAS DISPONÃVEIS:**\\n\\n';\n        mensagem += 'ğŸ  **Propriedades** - Casas, fazendas, postos\\n';\n        mensagem += `   \\`${config.prefix}loja propriedades\\`\\n\\n`;\n        mensagem += 'ğŸ¾ **Animais** - Galinhas, cavalos, gatos\\n';\n        mensagem += `   \\`${config.prefix}loja animais\\`\\n\\n`;\n        mensagem += 'ğŸ”§ **Ferramentas** - Varas, picaretas, tratores\\n';\n        mensagem += `   \\`${config.prefix}loja ferramentas\\`\\n\\n`;\n        mensagem += 'ğŸš— **VeÃ­culos** - Bikes, motos, carros\\n';\n        mensagem += `   \\`${config.prefix}loja veiculos\\`\\n\\n`;\n        mensagem += `ğŸ’¡ **Para comprar:** \\`${config.prefix}comprar [item_id]\\`\\n`;\n    }\n    \n    return {\n        mensagem: mensagem,\n        imagem: imagens.loja[Math.floor(Math.random() * imagens.loja.length)]\n    };\n}\n\n// Ver inventÃ¡rio do jogador\nfunction verInventario(userId) {\n    const dados = carregarDadosRPG();\n    let usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n    \n    usuario = ensureUserDefaults(usuario);\n    \n    let mensagem = `ğŸ“¦ **INVENTÃRIO DE ${usuario.nome.toUpperCase()}** ğŸ“¦\\n\\n`;\n    mensagem += `ğŸ’° **Saldo:** ${usuario.saldo} Gold\\n\\n`;\n    \n    // Propriedades\n    if (Object.keys(usuario.propriedades).length > 0) {\n        mensagem += 'ğŸ  **PROPRIEDADES:**\\n';\n        Object.entries(usuario.propriedades).forEach(([itemId, qtd]) => {\n            const item = catalogoItens.propriedades[itemId];\n            if (item) {\n                mensagem += `   ${item.emoji} **${item.nome}** (${qtd}x)\\n`;\n            }\n        });\n        mensagem += '\\n';\n    }\n    \n    // InventÃ¡rio geral\n    if (Object.keys(usuario.inventario).length > 0) {\n        mensagem += 'ğŸ“¦ **ITENS:**\\n';\n        Object.entries(usuario.inventario).forEach(([itemId, qtd]) => {\n            // Procura o item em todas as categorias\n            let item = null;\n            Object.values(catalogoItens).forEach(categoria => {\n                if (categoria[itemId]) {\n                    item = categoria[itemId];\n                }\n            });\n            \n            if (item) {\n                mensagem += `   ${item.emoji} **${item.nome}** (${qtd}x)\\n`;\n            }\n        });\n        mensagem += '\\n';\n    }\n    \n    if (Object.keys(usuario.propriedades).length === 0 && Object.keys(usuario.inventario).length === 0) {\n        const config = obterConfiguracoes();\n        mensagem += 'ğŸ“­ **InventÃ¡rio vazio!**\\n\\n';\n        mensagem += `ğŸ›’ **Visite a loja:** \\`${config.prefix}loja\\`\\n`;\n    }\n    \n    return { mensagem: mensagem };\n}\n\n// Verifica cooldown\nfunction verificarCooldown(ultimaAcao, tempoEspera) {\n    const agora = Date.now();\n    const tempoRestante = (ultimaAcao + tempoEspera) - agora;\n    return tempoRestante > 0 ? tempoRestante : 0;\n}\n\n// Verifica limite diÃ¡rio\nfunction verificarLimiteDiario(usuario, atividade) {\n    const limiteMax = DAILY_LIMITS[atividade] || 10;\n    const usoAtual = usuario.limites[atividade] || 0;\n    \n    if (usoAtual >= limiteMax) {\n        return {\n            excedido: true,\n            atual: usoAtual,\n            maximo: limiteMax,\n            restantes: 0\n        };\n    }\n    \n    return {\n        excedido: false,\n        atual: usoAtual,\n        maximo: limiteMax,\n        restantes: limiteMax - usoAtual\n    };\n}\n\n// Incrementa uso diÃ¡rio\nfunction incrementarLimiteDiario(usuario, atividade) {\n    if (!usuario.limites) usuario.limites = {};\n    usuario.limites[atividade] = (usuario.limites[atividade] || 0) + 1;\n}\n\n// Formata tempo restante\nfunction formatarTempo(milissegundos) {\n    const segundos = Math.ceil(milissegundos / 1000);\n    const minutos = Math.floor(segundos / 60);\n    const seg = segundos % 60;\n    \n    if (minutos > 0) {\n        return `${minutos}m ${seg}s`;\n    }\n    return `${seg}s`;\n}\n\n// Sistema de Pesca\nfunction pescar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (5 minutos)\n    const cooldown = verificarCooldown(usuario.ultimaPesca, 5 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ£ VocÃª precisa esperar **${formatarTempo(cooldown)}** para pescar novamente!`\n        };\n    }\n\n    // Chance de falha (anzol quebrar, etc.)\n    const chancefalha = Math.random() * 100;\n    if (chancefalha < 15) {\n        usuario.ultimaPesca = Date.now();\n        salvarDadosRPG(dados);\n        \n        const falhas = [\n            'ğŸ£ Seu anzol quebrou! Que azar...',\n            'ğŸ£ O peixe escapou! Tente novamente mais tarde.',\n            'ğŸ£ Sua linha de pesca se embaraÃ§ou!',\n            'ğŸ£ VocÃª nÃ£o conseguiu pescar nada desta vez.',\n            'ğŸ£ Um peixe grande levou sua isca!'\n        ];\n        \n        return {\n            sucesso: false,\n            mensagem: falhas[Math.floor(Math.random() * falhas.length)],\n            imagem: imagens.pesca[Math.floor(Math.random() * imagens.pesca.length)]\n        };\n    }\n\n    // Determina qual peixe foi pescado\n    const rand = Math.random() * 100;\n    let chanceAcumulada = 0;\n    let peixePescado = null;\n\n    for (const peixe of peixes) {\n        chanceAcumulada += peixe.chance;\n        if (rand <= chanceAcumulada) {\n            peixePescado = peixe;\n            break;\n        }\n    }\n\n    if (!peixePescado) peixePescado = peixes[peixes.length - 1];\n\n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += peixePescado.valor;\n    usuario.ultimaPesca = Date.now();\n    usuario.pescasFeitas++;\n    salvarDadosRPG(dados);\n\n    const raridadeEmoji = {\n        'lendario': 'ğŸŒŸ',\n        'epico': 'ğŸ’œ',\n        'raro': 'ğŸ’™',\n        'comum': 'âšª'\n    };\n\n    return {\n        sucesso: true,\n        peixe: peixePescado,\n        mensagem: `ğŸ£ **PESCA REALIZADA!**\\n\\n` +\n                 `${raridadeEmoji[peixePescado.raridade]} **${peixePescado.nome}** ${peixePescado.emoji}\\n` +\n                 `ğŸ’° **+${peixePescado.valor} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `ğŸ£ **Pescas feitas:** ${usuario.pescasFeitas}`,\n        imagem: imagens.pesca[Math.floor(Math.random() * imagens.pesca.length)]\n    };\n}\n\n// Sistema de MineraÃ§Ã£o\nfunction minerar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (7 minutos)\n    const cooldown = verificarCooldown(usuario.ultimaMineracao, 7 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `â›ï¸ VocÃª precisa esperar **${formatarTempo(cooldown)}** para minerar novamente!`\n        };\n    }\n\n    // Chance de falha (picareta quebrar, etc.)\n    const chancefalha = Math.random() * 100;\n    if (chancefalha < 20) {\n        usuario.ultimaMineracao = Date.now();\n        salvarDadosRPG(dados);\n        \n        const falhas = [\n            'â›ï¸ Sua picareta quebrou na pedra!',\n            'â›ï¸ VocÃª nÃ£o encontrou nada nesta Ã¡rea.',\n            'â›ï¸ A mina desabou! Que azar...',\n            'â›ï¸ VocÃª se cansou e nÃ£o conseguiu minerar.',\n            'â›ï¸ A rocha estava muito dura!'\n        ];\n        \n        return {\n            sucesso: false,\n            mensagem: falhas[Math.floor(Math.random() * falhas.length)],\n            imagem: imagens.mineracao[Math.floor(Math.random() * imagens.mineracao.length)]\n        };\n    }\n\n    // Determina qual mineral foi encontrado\n    const rand = Math.random() * 100;\n    let chanceAcumulada = 0;\n    let mineralEncontrado = null;\n\n    for (const mineral of minerais) {\n        chanceAcumulada += mineral.chance;\n        if (rand <= chanceAcumulada) {\n            mineralEncontrado = mineral;\n            break;\n        }\n    }\n\n    if (!mineralEncontrado) mineralEncontrado = minerais[minerais.length - 1];\n\n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += mineralEncontrado.valor;\n    usuario.ultimaMineracao = Date.now();\n    usuario.mineracoesFeitas++;\n    salvarDadosRPG(dados);\n\n    const raridadeEmoji = {\n        'lendario': 'ğŸŒŸ',\n        'epico': 'ğŸ’œ',\n        'raro': 'ğŸ’™',\n        'comum': 'âšª'\n    };\n\n    return {\n        sucesso: true,\n        mineral: mineralEncontrado,\n        mensagem: `â›ï¸ **MINERAÃ‡ÃƒO REALIZADA!**\\n\\n` +\n                 `${raridadeEmoji[mineralEncontrado.raridade]} **${mineralEncontrado.nome}** ${mineralEncontrado.emoji}\\n` +\n                 `ğŸ’° **+${mineralEncontrado.valor} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `â›ï¸ **MineraÃ§Ãµes feitas:** ${usuario.mineracoesFeitas}`,\n        imagem: imagens.mineracao[Math.floor(Math.random() * imagens.mineracao.length)]\n    };\n}\n\n// Sistema de Trabalho\nfunction trabalhar(userId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n\n    // Verifica cooldown (10 minutos)\n    const cooldown = verificarCooldown(usuario.ultimoTrabalho, 10 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ’¼ VocÃª precisa esperar **${formatarTempo(cooldown)}** para trabalhar novamente!`\n        };\n    }\n\n    // Escolhe trabalho aleatÃ³rio\n    const trabalho = trabalhos[Math.floor(Math.random() * trabalhos.length)];\n    \n    // Atualiza dados do usuÃ¡rio\n    usuario.saldo += trabalho.salario;\n    usuario.ultimoTrabalho = Date.now();\n    usuario.trabalhosFeitos++;\n    salvarDadosRPG(dados);\n\n    return {\n        sucesso: true,\n        trabalho: trabalho,\n        mensagem: `ğŸ’¼ **TRABALHO REALIZADO!**\\n\\n` +\n                 `${trabalho.emoji} **${trabalho.nome}**\\n` +\n                 `ğŸ’° **+${trabalho.salario} Gold**\\n` +\n                 `ğŸ¦ **Saldo:** ${usuario.saldo} Gold\\n` +\n                 `ğŸ’¼ **Trabalhos feitos:** ${usuario.trabalhosFeitos}`\n    };\n}\n\n// JOGO DO TIGRINHO APRIMORADO - ROUBA 50% DO DINHEIRO!\nfunction jogarTigrinho(userId, aposta) {\n    return withLock(async () => {\n        const dados = carregarDadosRPG();\n        let usuario = dados.jogadores[userId];\n        if (!usuario) return { erro: 'UsuÃ¡rio nÃ£o registrado' };\n        \n        usuario = ensureUserDefaults(usuario);\n        usuario = resetDailyLimitsIfNeeded(usuario);\n        \n        if (aposta < 10) return { erro: 'Aposta mÃ­nima Ã© 10 Gold' };\n        if (aposta > usuario.saldo) return { erro: 'Saldo insuficiente' };\n        \n        // Sistema predatÃ³rio: apenas 15% de chance de ganhar!\n        const chanceGanhar = Math.random() * 100;\n        const simbolos = ['ğŸ…', 'ğŸ', 'ğŸ’', 'ğŸ‹', 'ğŸ””', 'ğŸ’', 'ğŸ°', 'â­'];\n        \n        let resultado, ganhou, premioFinal = 0, perdaExtra = 0;\n        \n        usuario.tigrinhoJogadas++;\n        \n        if (chanceGanhar <= 15) { // Apenas 15% de chance de ganhar\n            // GANHOU - mas pouco\n            ganhou = true;\n            resultado = [simbolos[0], simbolos[0], simbolos[0]]; // ForÃ§ar combinaÃ§Ã£o\n            \n            if (chanceGanhar <= 2) {\n                // Jackpot ultra raro (2%)\n                multiplicador = 3;\n                resultado = ['ğŸ’', 'ğŸ’', 'ğŸ’'];\n            } else if (chanceGanhar <= 5) {\n                // Tigrinho raro (3%)\n                multiplicador = 2;\n                resultado = ['ğŸ…', 'ğŸ…', 'ğŸ…'];\n            } else {\n                // Ganho pequeno (10%)\n                multiplicador = 1.2;\n                resultado = ['â­', 'â­', 'â­'];\n            }\n            \n            premioFinal = Math.floor(aposta * multiplicador);\n            usuario.saldo = usuario.saldo - aposta + premioFinal;\n            usuario.totalGanho += (premioFinal - aposta);\n            \n        } else {\n            // PERDEU - e perde MUITO!\n            ganhou = false;\n            usuario.tigrinhoPerdas++;\n            \n            // Gera resultado perdedor\n            resultado = [\n                simbolos[Math.floor(Math.random() * simbolos.length)],\n                simbolos[Math.floor(Math.random() * simbolos.length)],\n                simbolos[Math.floor(Math.random() * simbolos.length)]\n            ];\n            \n            // Garantir que nÃ£o seja uma combinaÃ§Ã£o vencedora\n            while (resultado[0] === resultado[1] && resultado[1] === resultado[2]) {\n                resultado[2] = simbolos[Math.floor(Math.random() * simbolos.length)];\n            }\n            \n            // AQUI ESTÃ A ARMADILHA: Perde a aposta + 50% do saldo restante!\n            const saldoRestante = usuario.saldo - aposta;\n            perdaExtra = Math.floor(saldoRestante * 0.5); // 50% do saldo restante\n            \n            usuario.saldo -= aposta + perdaExtra;\n            usuario.totalGasto += aposta + perdaExtra;\n            \n            // NÃ£o deixa ficar negativo\n            if (usuario.saldo < 0) {\n                perdaExtra += usuario.saldo; // Ajusta a perda extra\n                usuario.saldo = 0;\n            }\n        }\n        \n        dados.jogadores[userId] = usuario;\n        salvarDadosRPG(dados);\n        \n        const config = obterConfiguracoes();\n        \n        return {\n            sucesso: true,\n            ganhou: ganhou,\n            resultado: resultado,\n            aposta: aposta,\n            premio: premioFinal,\n            perdaExtra: perdaExtra,\n            saldo: usuario.saldo,\n            imagem: imagens.tigrinho[ganhou ? 0 : Math.floor(Math.random() * 2) + 1],\n            mensagem: `ğŸ° **JOGO DO TIGRINHO** ğŸ…\\n\\n` +\n                     `ğŸ² [ ${resultado.join(' | ')} ]\\n\\n` +\n                     (ganhou ? \n                        `ğŸ‰ **PARABÃ‰NS! VOCÃŠ GANHOU!** ğŸŠ\\nğŸ’° **Ganho:** +${premioFinal - aposta} Gold\\n` :\n                        `ğŸ’€ **VOCÃŠ PERDEU TUDO!** ğŸ˜­\\nğŸ’¸ **Aposta perdida:** -${aposta} Gold\\n` +\n                        (perdaExtra > 0 ? `ğŸ”¥ **TIGRINHO ROUBOU 50%:** -${perdaExtra} Gold\\n` : '') +\n                        `âš ï¸ **O Tigrinho Ã© viciante e rouba seu dinheiro!**\\n`\n                     ) +\n                     `ğŸ¦ **Saldo atual:** ${usuario.saldo} Gold\\n` +\n                     `ğŸ¯ **Jogadas:** ${usuario.tigrinhoJogadas} | ğŸ“‰ **Perdas:** ${usuario.tigrinhoPerdas}\\n\\n` +\n                     (usuario.saldo < 100 ? `âš ï¸ **CUIDADO:** Seu saldo estÃ¡ baixo! Use \\`${config.prefix}trabalhar\\` ou \\`${config.prefix}pescar\\` para recuperar!` : \n                     `ğŸ’¡ **Dica:** Pare enquanto ainda tem dinheiro! Use \\`${config.prefix}rank\\` para ver os mais ricos!`)\n        };\n    });\n}\n\n// Sistema de Assalto\nfunction assaltar(userId, targetId) {\n    const dados = carregarDadosRPG();\n    const usuario = dados.jogadores[userId];\n    const alvo = dados.jogadores[targetId];\n    \n    if (!usuario) return { erro: 'VocÃª nÃ£o estÃ¡ registrado' };\n    if (!alvo) return { erro: 'UsuÃ¡rio alvo nÃ£o estÃ¡ registrado' };\n    if (userId === targetId) return { erro: 'VocÃª nÃ£o pode assaltar a si mesmo' };\n\n    // Verifica cooldown (15 minutos)\n    const cooldown = verificarCooldown(usuario.ultimoAssalto, 15 * 60 * 1000);\n    if (cooldown > 0) {\n        return { \n            erro: 'Cooldown', \n            tempo: formatarTempo(cooldown),\n            mensagem: `ğŸ”« VocÃª precisa esperar **${formatarTempo(cooldown)}** para assaltar novamente!`\n        };\n    }\n\n    if (alvo.saldo < 50) return { erro: 'O alvo nÃ£o tem Gold suficiente para ser assaltado (mÃ­nimo 50)' };\n\n    // Chance de sucesso (60%)\n    const sucesso = Math.random() < 0.6;\n    const valorAssaltado = Math.floor(alvo.saldo * 0.2); // 20% do saldo do alvo\n\n    usuario.ultimoAssalto = Date.now();\n    usuario.assaltosFeitos++;\n\n    if (sucesso) {\n        usuario.saldo += valorAssaltado;\n        alvo.saldo -= valorAssaltado;\n        \n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            assalto: true,\n            valor: valorAssaltado,\n            mensagem: `ğŸ”« **ASSALTO BEM-SUCEDIDO!**\\n\\n` +\n                     `ğŸ’° **+${valorAssaltado} Gold** roubados de ${alvo.nome}\\n` +\n                     `ğŸ¦ **Seu saldo:** ${usuario.saldo} Gold\\n` +\n                     `ğŸ”« **Assaltos feitos:** ${usuario.assaltosFeitos}`\n        };\n    } else {\n        // Falha no assalto - perde 30 Gold como multa\n        const multa = Math.min(30, usuario.saldo);\n        usuario.saldo -= multa;\n        \n        salvarDadosRPG(dados);\n        \n        return {\n            sucesso: true,\n            assalto: false,\n            multa: multa,\n            mensagem: `ğŸ”« **ASSALTO FALHOU!**\\n\\n` +\n                     `ğŸš¨ VocÃª foi pego e pagou **${multa} Gold** de multa!\\n` +\n                     `ğŸ¦ **Seu saldo:** ${usuario.saldo} Gold\\n` +\n                     `ğŸ”« **Assaltos feitos:** ${usuario.assaltosFeitos}`\n        };\n    }\n}\n\n// Sistema de Ranking\nfunction obterRanking() {\n    const dados = carregarDadosRPG();\n    const jogadores = Object.entries(dados.jogadores)\n        .map(([id, dados]) => ({ id, ...dados }))\n        .sort((a, b) => b.saldo - a.saldo)\n        .slice(0, 10); // Top 10\n\n    if (jogadores.length === 0) {\n        return { mensagem: 'ğŸ“Š Nenhum jogador registrado ainda!' };\n    }\n\n    let ranking = 'ğŸ† **RANKING DOS MAIS RICOS - NEEXTCITY**\\n\\n';\n    \n    jogadores.forEach((jogador, index) => {\n        const posicao = index + 1;\n        const medal = posicao === 1 ? 'ğŸ¥‡' : posicao === 2 ? 'ğŸ¥ˆ' : posicao === 3 ? 'ğŸ¥‰' : `${posicao}Â°`;\n        \n        ranking += `${medal} **${jogador.nome}**\\n`;\n        ranking += `   ${jogador.banco.emoji} ${jogador.banco.nome}\\n`;\n        ranking += `   ğŸ’° ${jogador.saldo} Gold\\n\\n`;\n    });\n\n    return { mensagem: ranking };\n}\n\nmodule.exports = {\n    carregarDadosRPG,\n    salvarDadosRPG,\n    isRPGAtivo,\n    toggleRPG,\n    isUsuarioRegistrado,\n    registrarUsuario,\n    obterDadosUsuario,\n    atualizarSaldo,\n    pescar,\n    minerar,\n    trabalhar,\n    jogarTigrinho,\n    assaltar,\n    obterRanking,\n    bancos\n};","size_bytes":41777},"arquivos/registros.js":{"content":"// arquivos/registros.js - Sistema de Registros do Bot\nconst fs = require('fs');\nconst path = require('path');\n\nconst registrosFile = path.join(__dirname, '../database/registros/registros.json');\n\n// Carrega dados dos registros\nfunction carregarRegistros() {\n    try {\n        if (!fs.existsSync(registrosFile)) {\n            const dir = path.dirname(registrosFile);\n            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n            fs.writeFileSync(registrosFile, \"[]\");\n        }\n        const data = fs.readFileSync(registrosFile, \"utf-8\");\n        return JSON.parse(data);\n    } catch (err) {\n        console.error(\"âŒ Erro ao carregar registros.json:\", err);\n        return [];\n    }\n}\n\n// Salva dados dos registros\nfunction salvarRegistros(registros) {\n    try {\n        fs.writeFileSync(registrosFile, JSON.stringify(registros, null, 2));\n        return true;\n    } catch (err) {\n        console.error(\"âŒ Erro ao salvar registros.json:\", err);\n        return false;\n    }\n}\n\n// Verifica se usuÃ¡rio estÃ¡ registrado\nfunction usuarioRegistrado(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.some(registro => registro.numero === numeroUsuario);\n}\n\n// Registra novo usuÃ¡rio\nfunction registrarUsuario(numeroUsuario, nomeUsuario) {\n    try {\n        const registros = carregarRegistros();\n        \n        // Verifica se jÃ¡ estÃ¡ registrado\n        if (usuarioRegistrado(numeroUsuario)) {\n            return { sucesso: false, motivo: \"jÃ¡_registrado\" };\n        }\n\n        // Cria novo registro\n        const novoRegistro = {\n            numero: numeroUsuario,\n            nome: nomeUsuario || \"UsuÃ¡rio\",\n            dataRegistro: new Date().toISOString(),\n            dataRegistroFormatada: new Date().toLocaleString('pt-BR'),\n            numeroRegistro: registros.length + 1\n        };\n\n        registros.push(novoRegistro);\n        \n        if (salvarRegistros(registros)) {\n            return { \n                sucesso: true, \n                registro: novoRegistro,\n                totalRegistros: registros.length\n            };\n        } else {\n            return { sucesso: false, motivo: \"erro_salvar\" };\n        }\n    } catch (err) {\n        console.error(\"âŒ Erro ao registrar usuÃ¡rio:\", err);\n        return { sucesso: false, motivo: \"erro_tecnico\" };\n    }\n}\n\n// Obter estatÃ­sticas dos registros\nfunction obterEstatisticas() {\n    const registros = carregarRegistros();\n    return {\n        totalRegistros: registros.length,\n        ultimoRegistro: registros.length > 0 ? registros[registros.length - 1] : null\n    };\n}\n\n// Obter informaÃ§Ãµes de um usuÃ¡rio registrado\nfunction obterInfoUsuario(numeroUsuario) {\n    const registros = carregarRegistros();\n    return registros.find(registro => registro.numero === numeroUsuario);\n}\n\nmodule.exports = {\n    carregarRegistros,\n    salvarRegistros,\n    usuarioRegistrado,\n    registrarUsuario,\n    obterEstatisticas,\n    obterInfoUsuario\n};","size_bytes":2969},"config/environment.js":{"content":"// Environment Configuration Module\n// Centralizes all environment variables and provides secure defaults\n\nrequire('dotenv').config();\n\nconst config = {\n    // Bot Owner Configuration\n    botOwner: {\n        number: process.env.BOT_OWNER_NUMBER || '553176011100',\n        nickname: process.env.BOT_OWNER_NICKNAME || 'Flash',\n        name: process.env.BOT_NAME || 'NEEXT LTDA',\n        prefix: process.env.BOT_PREFIX || '.'\n    },\n\n    // External API Endpoints\n    apis: {\n        instagram: process.env.INSTAGRAM_API_URL || 'https://api.siputzx.my.id/api/d/igdl',\n        youtube: process.env.YOUTUBE_API_URL || 'https://api.nekolabs.my.id/downloader/youtube/play/v1',\n        googleSheets: process.env.GOOGLE_SHEETS_API_URL || 'https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec'\n    },\n\n    // Business Contact Numbers\n    contacts: {\n        neext: process.env.CONTACT_NEEXT || '553176011100',\n        mercadoPago: process.env.CONTACT_MERCADOPAGO || '5511988032872',\n        nubank: process.env.CONTACT_NUBANK || '551151807064',\n        serasa: process.env.CONTACT_SERASA || '551128475131'\n    },\n\n    // Database Configuration\n    database: {\n        type: process.env.DB_TYPE || 'file',\n        url: process.env.DATABASE_URL || null\n    },\n\n    // Security Settings\n    security: {\n        enableAntiSpam: process.env.ENABLE_ANTI_SPAM === 'true',\n        enableAntiLink: process.env.ENABLE_ANTI_LINK === 'true',\n        enableAdminCommands: process.env.ENABLE_ADMIN_COMMANDS !== 'false' // defaults to true\n    },\n\n    // Bot Media\n    media: {\n        botPhotoUrl: process.env.BOT_PHOTO_URL || 'https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg'\n    },\n\n    // Development settings\n    isDevelopment: process.env.NODE_ENV !== 'production',\n    \n    // Helper functions\n    getBotOwnerJid() {\n        return this.botOwner.number + '@s.whatsapp.net';\n    },\n\n    getContactJid(contactType) {\n        const number = this.contacts[contactType];\n        return number ? number + '@s.whatsapp.net' : null;\n    },\n\n    // Legacy compatibility for existing settings.json format\n    toLegacyFormat() {\n        return {\n            prefix: this.botOwner.prefix,\n            nomeDoBot: this.botOwner.name,\n            nickDoDono: this.botOwner.nickname,\n            numeroDoDono: this.botOwner.number,\n            fotoDoBot: this.media.botPhotoUrl\n        };\n    }\n};\n\nmodule.exports = config;","size_bytes":2455}},"version":1}
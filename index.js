// index.js ‚Äî Bot completo com eventos e comandos unificados

const {
    makeWASocket,
    fetchLatestBaileysVersion,
    generateWAMessageFromContent,
    downloadContentFromMessage
} = require("@whiskeysockets/baileys");


const path = require("path"); // <<< ESSENCIAL PARA path.joinv
const fs = require("fs");
const axios = require("axios");
const os = require("os");
const { writeExif } = require("./arquivos/sticker.js");
const { sendImageAsSticker, sendVideoAsSticker } = require("./arquivos/rename.js");
const Jimp = require("jimp");
const pinterest = require('./Pinterest.js');
const { igdl } = require('./Instagram.js');
const settings = require('./settings/settings.json');
const envConfig = require('./config/environment.js');
const { Aki } = require('aki-api');
const cloudscraper = require('cloudscraper');
const UserAgent = require('user-agents');
const moment = require('moment-timezone');

// Sistema RPG - NeextCity
const rpg = require('./arquivos/rpg.js');

const antilinkFile = path.join(__dirname, "antilink.json");
const akinatorFile = path.join(__dirname, "database/grupos/games/akinator.json");

// Sistema Anti-Spam Completo
const antiSpam = require("./arquivos/antispam.js");

// Sistema de Registros
const registros = require("./arquivos/registros.js");

// importa banner + logger centralizados
const { mostrarBanner, logMensagem } = require("./export");

// importa fun√ß√µes auxiliares do menu
const { obterSaudacao, contarGrupos, contarComandos } = require("./arquivos/funcoes/function.js");

// Config do Bot - prioriza environment vars sobre settings.json
function obterConfiguracoes() {
    try {
        delete require.cache[require.resolve('./settings/settings.json')];
        const settingsFile = require('./settings/settings.json');
        
        // Merge environment config with settings.json (env vars take priority)
        return {
            prefix: envConfig.botOwner.prefix || settingsFile.prefix || ".",
            nomeDoBot: envConfig.botOwner.name || settingsFile.nomeDoBot || "WhatsApp Bot",
            nickDoDono: envConfig.botOwner.nickname || settingsFile.nickDoDono || "Owner",
            numeroDoDono: envConfig.botOwner.number || settingsFile.numeroDoDono || "PLACEHOLDER_NUMBER",
            fotoDoBot: envConfig.media.botPhotoUrl || settingsFile.fotoDoBot || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
            idDoCanal: settingsFile.idDoCanal || "120363399209756764@g.us"
        };
    } catch (err) {
        console.error("‚ùå Erro ao carregar configura√ß√µes:", err);
        // Fallback using environment config only
        return envConfig.toLegacyFormat();
    }
}

// Selinhos e quoted fake (mantive seu conte√∫do)
const selinho = {
    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Kuun;Flash;;;\nFN:Flash Kuun\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selinho2 = {
    key: { fromMe: false, participant: `553176011100@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:un;Flh;;;\nFN:Kuun\nitem1.TEL;waid=553176011100:553176011100\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selomercadopago = {
    key: { fromMe: false, participant: `5511988032872@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Mercado;Pago;;;\nFN:Mercado Pago\nitem1.TEL;waid=5511988032872:5511988032872\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selonubank = {
    key: { fromMe: false, participant: `551151807064@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Nubank;Flash;;;\nFN:Nubank Kuun\nitem1.TEL;waid=551151807064:551151807064\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const seloserasa = {
    key: { fromMe: false, participant: `551128475131@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Serasa;Flash;;;\nFN:Serasa Kuun\nitem1.TEL;waid=551128475131:551128475131\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const quotedCarrinho = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: { documentMessage: { title: "üõí Neext Ltda", fileName: "Neext.pdf", mimetype: "application/pdf", fileLength: 999999, pageCount: 1 } }
};

// System NEEXT (status do sistema) para usar no grupo-status
const quotedSerasaAPK = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: {
        documentMessage: {
            title: "üõ°Ô∏è NEEXT System",
            fileName: "serasa.apk",
            mimetype: "application/vnd.android.package-archive",
            fileLength: 549755813888000, // 500TB em bytes
            pageCount: 0,
            contactVcard: true
        }
    }
};

// APK Fake da NEEXT LTDA (1000GB) para usar no grupo-status
const quotedNeextAPK = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: {
        documentMessage: {
            title: "üì± NEEXT LTDA",
            fileName: "neext_ltda.apk",
            mimetype: "application/vnd.android.package-archive",
            fileLength: 1073741824000, // 1000GB em bytes
            pageCount: 0,
            contactVcard: true
        }
    }
};

// ContextInfo para fazer mensagens aparecerem como "enviada via an√∫ncio"
const contextAnuncio = {
    externalAdReply: {
        title: "¬© NEEXT LTDA",
        body: "üì± Instagram: @neet.tk",
        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
        mediaType: 1,
        sourceUrl: "https://www.neext.online",
        showAdAttribution: true
    }
};

// Mensagens j√° processadas (evita duplicadas)
const processedMessages = new Set();
setInterval(() => processedMessages.clear(), 5 * 60 * 1000);

// Vari√°veis do jogo Akinator
let akinator = [];
let jogo = { now: true, jogador: "" };

// Classe para bypass do Cloudflare no Akinator
class AkinatorCloudflareBypass {
    constructor() {
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'
        ];
    }

    getRandomUserAgent() {
        return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];
    }

    async createAkinator(region = 'en', retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                console.log(`üßû‚Äç‚ôÇÔ∏è Tentando conectar ao Akinator (tentativa ${attempt}/${retries})...`);

                // Configura cloudscraper para contornar Cloudflare
                const userAgent = this.getRandomUserAgent();

                // Cria inst√¢ncia do Akinator
                const aki = new Aki({
                    region: region,
                    childMode: false,
                    // Configura√ß√µes para bypass
                    requestOptions: {
                        headers: {
                            'User-Agent': userAgent,
                            'Accept': 'application/json, text/plain, */*',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Connection': 'keep-alive',
                            'Upgrade-Insecure-Requests': '1',
                            'Sec-Fetch-Dest': 'document',
                            'Sec-Fetch-Mode': 'navigate',
                            'Sec-Fetch-Site': 'none',
                            'Cache-Control': 'max-age=0'
                        },
                        timeout: 30000
                    }
                });

                // Aguarda um pouco antes de tentar
                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));

                await aki.start();
                console.log(`‚úÖ Conectado ao Akinator com sucesso! Regi√£o: ${region}`);
                return aki;

            } catch (error) {
                console.error(`‚ùå Tentativa ${attempt} falhou:`, error.message);

                if (attempt === retries) {
                    throw new Error(`Falha ap√≥s ${retries} tentativas. Akinator temporariamente indispon√≠vel.`);
                }

                // Aguarda mais tempo a cada tentativa
                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));
            }
        }
    }
}

// Carrega dados do Akinator
function carregarAkinator() {
    try {
        if (!fs.existsSync(akinatorFile)) {
            const dir = path.dirname(akinatorFile);
            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
            fs.writeFileSync(akinatorFile, "[]");
        }
        const data = fs.readFileSync(akinatorFile, "utf-8");
        akinator = JSON.parse(data);
        return akinator;
    } catch (err) {
        console.error("‚ùå Erro ao carregar akinator.json:", err);
        akinator = [];
        return [];
    }
}

// Salva dados do Akinator
function salvarAkinator() {
    try {
        fs.writeFileSync(akinatorFile, JSON.stringify(akinator, null, 2));
    } catch (err) {
        console.error("‚ùå Erro ao salvar akinator.json:", err);
    }
}

// Inicializa dados do Akinator
carregarAkinator();




// Fun√ß√µes antigas removidas - agora usamos o sistema antiSpam completo

// Fun√ß√£o utilit√°ria: extrai texto da mensagem
function getMessageText(message) {
    if (!message) return "";
    if (message.conversation) return message.conversation;
    if (message.extendedTextMessage?.text) return message.extendedTextMessage.text;
    if (message.imageMessage?.caption) return message.imageMessage.caption;
    if (message.videoMessage?.caption) return message.videoMessage.caption;
    if (message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;
    if (message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;
    if (message.ephemeralMessage?.message) return getMessageText(message.ephemeralMessage.message);
    return "";
}

// Normaliza mensagem e retorna quoted
function normalizeMessage(m) {
    if (!m?.message) return { normalized: m, quoted: null };
    let message = m.message;
    if (message.ephemeralMessage) message = message.ephemeralMessage.message;
    if (message.viewOnceMessage) message = message.viewOnceMessage.message;
    const contextInfo = message.extendedTextMessage?.contextInfo || {};
    const quoted = contextInfo.quotedMessage || null;
    return { normalized: { ...m, message }, quoted };
}

// Fun√ß√£o reply gen√©rica
async function reply(sock, from, text, mentions = []) {
    try {
        // Valida√ß√£o rigorosa do texto
        if (text === undefined || text === null) {
            console.error("‚ùå Texto da reply √© undefined/null:", text);
            text = "‚ùå Erro: Mensagem n√£o encontrada";
        }
        
        if (typeof text !== 'string') {
            console.error("‚ùå Texto da reply n√£o √© string:", typeof text, text);
            text = String(text || "‚ùå Erro: Tipo de mensagem inv√°lida");
        }
        
        if (text.trim().length === 0) {
            console.error("‚ùå Texto da reply est√° vazio");
            text = "‚ùå Erro: Mensagem vazia";
        }
        
        await sock.sendMessage(from, {
            text: text,
            contextInfo: {
                forwardingScore: 100000,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: "120363289739581116@newsletter",
                    newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                }
            },
            mentions: mentions || []
        });
    } catch (err) {
        console.error("‚ùå Erro ao enviar reply:", err.message || err);
        // Tenta envio mais simples em caso de erro
        try {
            await sock.sendMessage(from, { 
                text: text || "‚ùå Erro na mensagem",
                mentions: mentions || []
            });
        } catch (secondErr) {
            console.error("‚ùå Falha no fallback reply:", secondErr.message || secondErr);
        }
    }
}

// Reage a qualquer mensagem com emoji
async function reagirMensagem(sock, normalized, emoji = "ü§ñ") {
    if (!normalized?.key) return false;
    try {
        await sock.sendMessage(normalized.key.remoteJid, {
            react: {
                text: emoji,
                key: normalized.key
            }
        });
        return true;
    } catch (err) {
        console.error("‚ùå Erro ao reagir:", err);
        return false;
    }
}

// Detecta links na mensagem
function detectarLinks(texto) {
    if (!texto) return false;
    const linkRegex = /((https?:\/\/)|(www\.))[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)|wa.me\/|whatsapp.com\/|t.me\/|chat.whatsapp.com\/|instagram.com\/|facebook.com\/|twitter.com\/|tiktok.com\/|youtube.com\/|discord.gg\//i;
    return linkRegex.test(texto);
}

// Verifica se usu√°rio √© admin do grupo
async function isAdmin(sock, groupId, userId) {
    try {
        const groupMetadata = await sock.groupMetadata(groupId);
        const participant = groupMetadata.participants.find(p => p.id === userId);
        return participant && (participant.admin === 'admin' || participant.admin === 'superadmin');
    } catch (err) {
        console.error("‚ùå Erro ao verificar admin:", err);
        return false;
    }
}

// Verifica se usu√°rio √© o dono do bot
function isDono(userId) {
    const config = obterConfiguracoes();
    const numeroDono = config.numeroDoDono + "@s.whatsapp.net";
    return userId === numeroDono;
}

// Remove mensagem do grupo
async function removerMensagem(sock, messageKey) {
    try {
        await sock.sendMessage(messageKey.remoteJid, { delete: messageKey });
        return true;
    } catch (err) {
        console.error("‚ùå Erro ao remover mensagem:", err);
        return false;
    }
}

// Verifica se bot √© admin do grupo
async function botEhAdmin(sock, groupId) {
    try {
        const groupMetadata = await sock.groupMetadata(groupId);
        const botId = sock.user?.id?.replace(/:.*@s.whatsapp.net/, '@s.whatsapp.net') || sock.user?.id;
        const botParticipant = groupMetadata.participants.find(p => p.id === botId);
        return botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');
    } catch (err) {
        console.error("‚ùå Erro ao verificar se bot √© admin:", err);
        return false;
    }
}

// Bane usu√°rio do grupo
async function banirUsuario(sock, groupId, userId) {
    try {
        // Verifica se bot tem permiss√£o de admin
        const botAdmin = await botEhAdmin(sock, groupId);
        if (!botAdmin) {
            console.log(`‚ö†Ô∏è Bot n√£o √© admin no grupo ${groupId} - n√£o pode banir`);
            return { success: false, reason: "bot_nao_admin" };
        }

        console.log(`‚öîÔ∏è Tentando banir usu√°rio ${userId} do grupo ${groupId}`);
        await sock.groupParticipantsUpdate(groupId, [userId], "remove");
        console.log(`‚úÖ Usu√°rio ${userId} banido com sucesso!`);
        return { success: true, reason: "banido" };
    } catch (err) {
        console.error(`‚ùå Erro ao banir usu√°rio ${userId}:`, err);
        if (err.message?.includes('forbidden')) {
            return { success: false, reason: "sem_permissao" };
        }
        return { success: false, reason: "erro_tecnico" };
    }
}

// Processa sistema anti-spam completo
async function processarAntiSpam(sock, normalized) {
    try {
        const from = normalized.key.remoteJid;
        const sender = normalized.key.participant || from;

        // S√≥ funciona em grupos
        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;

        // N√£o processa se for o dono
        if (isDono(sender)) {
            return false;
        }

        // N√£o processa se for admin
        const ehAdmin = await isAdmin(sock, from, sender);
        if (ehAdmin) {
            return false;
        }

        // Processa mensagem para verificar viola√ß√µes
        const resultado = antiSpam.processarMensagem(normalized.message, from, sender);

        if (!resultado.violacao) return false;

        const senderNumber = sender.split('@')[0];
        const tiposViolacao = resultado.tipos;

        console.log(`üö´ Viola√ß√£o detectada de ${senderNumber}: ${tiposViolacao.join(', ')}`);

        // Remove a mensagem
        const removido = await removerMensagem(sock, normalized.key);

        if (removido) {
            // Aguarda um pouco antes de tentar banir
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Tenta banir o usu√°rio
            const resultadoBan = await banirUsuario(sock, from, sender);

            const emojiMap = {
                'antilink': 'üîó',
                'anticontato': 'üìû',
                'antidocumento': 'üìÑ',
                'antivideo': 'üé•',
                'antiaudio': 'üéµ',
                'antisticker': 'üè∑Ô∏è',
                'antiflod': 'üåä'
            };

            const violacaoEmoji = emojiMap[tiposViolacao[0]] || 'üö´';
            const violacaoNome = tiposViolacao[0].toUpperCase();

            if (resultadoBan.success) {
                await reagirMensagem(sock, normalized, "‚öîÔ∏è");
                await reply(sock, from, `‚öîÔ∏è *${violacaoEmoji} ${violacaoNome} - USU√ÅRIO BANIDO!*\n\n@${senderNumber} foi removido do grupo por viola√ß√£o!\n\nüö´ Conte√∫do n√£o permitido: ${tiposViolacao.join(', ')}\n‚ö° A√ß√£o: Delete + Ban autom√°tico`, [sender]);
                console.log(`‚öîÔ∏è SUCESSO: ${senderNumber} banido do grupo ${from} por ${tiposViolacao.join(', ')}`);
            } else {
                await reagirMensagem(sock, normalized, "üö´");
                let motivo = "";
                switch(resultadoBan.reason) {
                    case "bot_nao_admin":
                        motivo = "Bot n√£o √© admin do grupo";
                        break;
                    case "sem_permissao":
                        motivo = "Bot sem permiss√£o para banir";
                        break;
                    default:
                        motivo = "Erro t√©cnico no banimento";
                }

                await reply(sock, from, `üö´ *${violacaoEmoji} ${violacaoNome} ATIVO*\n\n@${senderNumber} sua mensagem foi deletada por viola√ß√£o!\n\n‚ö†Ô∏è **N√£o foi poss√≠vel banir:** ${motivo}\nüí° **Solu√ß√£o:** Torne o bot admin do grupo`, [sender]);
                console.log(`‚ö†Ô∏è FALHA: N√£o foi poss√≠vel banir ${senderNumber} - ${motivo}`);
            }
        }

        return true;
    } catch (err) {
        console.error("‚ùå Erro no processamento anti-spam:", err);
        return false;
    }
}

// Auto-ban para lista negra e antifake quando usu√°rio entra no grupo
async function processarListaNegra(sock, participants, groupId, action) {
    try {
        if (action !== 'add') return;

        const config = antiSpam.carregarConfigGrupo(groupId);
        if (!config) return;

        for (const participant of participants) {
            const participantNumber = participant.split('@')[0];
            let motivo = '';
            let shouldBan = false;

            // Verifica lista negra
            if (antiSpam.isUsuarioListaNegra(participant, groupId)) {
                motivo = 'Lista Negra';
                shouldBan = true;
                console.log(`üìã Usu√°rio da lista negra detectado: ${participantNumber}`);
            }

            // Verifica antifake (n√∫meros n√£o brasileiros)
            if (config.antifake && !antiSpam.isNumeroBrasileiro(participant)) {
                motivo = motivo ? `${motivo} + Antifake` : 'Antifake (n√£o brasileiro)';
                shouldBan = true;
                console.log(`üáßüá∑ Usu√°rio n√£o brasileiro detectado: ${participantNumber}`);
            }

            if (shouldBan) {
                // Aguarda um pouco antes de banir
                await new Promise(resolve => setTimeout(resolve, 2000));

                const resultadoBan = await banirUsuario(sock, groupId, participant);

                if (resultadoBan.success) {
                    const emoji = motivo.includes('Lista Negra') ? 'üìã' : 'üáßüá∑';
                    await sock.sendMessage(groupId, {
                        text: `‚öîÔ∏è *${emoji} ${motivo.toUpperCase()} - USU√ÅRIO BANIDO!*\n\n@${participantNumber} foi removido automaticamente!\n\nüö´ Motivo: ${motivo}\n‚ö° A√ß√£o: Ban autom√°tico`,
                        mentions: [participant]
                    });
                    console.log(`‚öîÔ∏è ${motivo.toUpperCase()}: ${participantNumber} banido automaticamente do grupo ${groupId}`);
                } else {
                    console.log(`‚ö†Ô∏è ${motivo.toUpperCase()}: N√£o foi poss√≠vel banir ${participantNumber} - ${resultadoBan.reason}`);
                }
            }
        }
    } catch (err) {
        console.error("‚ùå Erro no processamento de lista negra/antifake:", err);
    }
}



// Fun√ß√£o principal de comandos
async function handleCommand(sock, message, command, args, from, quoted) {
    const msg = message.message;
    if (!msg) return;

    switch (command) {
        case "ping": {
            const now = new Date();
            const totalMem = (os.totalmem() / 1024 / 1024).toFixed(2);
            const freeMem = (os.freemem() / 1024 / 1024).toFixed(2);
            let uptimeSec = process.uptime();
            const days = Math.floor(uptimeSec / 86400);
            uptimeSec %= 86400;
            const hours = Math.floor(uptimeSec / 3600);
            uptimeSec %= 3600;
            const minutes = Math.floor(uptimeSec / 60);
            const seconds = Math.floor(uptimeSec % 60);
            const uptime = `${days}d ${hours}h ${minutes}m ${seconds}s`;

            const pingMessage = `
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ üìÖ Data: ${now.toLocaleDateString()}
‚îÉ ‚è∞ Hora: ${now.toLocaleTimeString()}
‚îÉ üü¢ Uptime: ${uptime}
‚îÉ üíæ Mem√≥ria Total: ${totalMem} MB
‚îÉ üíæ Mem√≥ria Livre: ${freeMem} MB
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`;

            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/xqddxGC6/d75ddb6631f10a0eff0b227c5b7617f2.jpg" },
                caption: pingMessage,
                contextInfo: {
                    mentionedJid: [from],
                    isForwarded: true,
                    forwardingScore: 100000,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: `¬© NEEXT LTDA`,
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "www.neext.online"
                    }
                }
            }, { quoted: selinho });
        }
        break;

        case "hora":
            await sock.sendMessage(from, {
                text: `‚è∞ Agora √©: ${new Date().toLocaleTimeString()}`,
                contextInfo: contextAnuncio
            });
            break;

            case 'dono':
    // garante que 'sender' est√° definido no escopo correto
    const sender = message.key.participant || from;
    await reply(sock, from, "üõ°Ô∏è Esse √© o dono do bot!", [sender]);
    break;



        case "status":
            const statusText = args.join(" ").trim();
            if (!statusText) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Use: " + config.prefix + "status Seu novo status aqui");
                break;
            }
            try {
                await sock.updateProfileStatus(statusText);
                await reply(sock, from, `‚úÖ Status atualizado para:\n> _${statusText}_`);
            } catch (err) {
                console.error("Erro ao atualizar status:", err);
                await reply(sock, from, "‚ùå Falha ao atualizar status.");
            }
            break;

        case "marca":
            if (!from.endsWith("@g.us") && !from.endsWith("@lid")) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }
            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                const mensagem = `üì¢ Marca√ß√£o geral:\n` + participants.map((p, i) => `${i+1}. @${p.split("@")[0]}`).join("\n");
                await reply(sock, from, mensagem);
            } catch(err) {
                console.error("‚ùå Erro ao marcar participantes:", err);
                await reply(sock, from, "‚ùå Falha ao marcar todos no grupo.");
            }
            break;

        case "recado":
            await sock.sendMessage(from, { text: "üìå Bot est√° ativo e conectado!" }, { quoted: message });
            break;

        case "rg": {
            const sender = message.key.participant || from;
            const numeroUsuario = sender.split('@')[0];
            const nomeUsuario = message.pushName || "Usu√°rio";

            // Verifica se j√° est√° registrado
            if (registros.usuarioRegistrado(numeroUsuario)) {
                await reagirMensagem(sock, message, "‚ö†Ô∏è");
                const infoUsuario = registros.obterInfoUsuario(numeroUsuario);
                await reply(sock, from,
                    `‚ö†Ô∏è *VOC√ä J√Å EST√Å REGISTRADO!*\n\n` +
                    `üë§ Nome: ${infoUsuario.nome}\n` +
                    `üì± N√∫mero: ${infoUsuario.numero}\n` +
                    `üìÖ Data do Registro: ${infoUsuario.dataRegistroFormatada}\n` +
                    `üî¢ Seu N√∫mero de Registro: #${infoUsuario.numeroRegistro}\n\n` +
                    `‚úÖ Voc√™ j√° pode usar todos os comandos do bot!`,
                    [sender]
                );
                break;
            }

            // Registra o usu√°rio
            const resultado = registros.registrarUsuario(numeroUsuario, nomeUsuario);

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üéâ");

                // Obt√©m foto do perfil do usu√°rio
                let fotoPerfilUrl = "https://i.ibb.co/LDs3wJR3/a720804619ff4c744098b956307db1ff.jpg"; // Foto padr√£o para usu√°rios sem perfil
                try {
                    const profilePic = await sock.profilePictureUrl(sender, 'image');
                    if (profilePic) {
                        fotoPerfilUrl = profilePic;
                        console.log(`‚úÖ Foto do perfil obtida para ${numeroUsuario}: ${profilePic}`);
                    } else {
                        console.log(`‚ö†Ô∏è Usu√°rio ${numeroUsuario} n√£o possui foto de perfil, usando imagem padr√£o`);
                    }
                } catch (err) {
                    console.log(`‚ùå Erro ao obter foto do perfil de ${numeroUsuario}:`, err.message);
                    console.log("üì∑ Usando foto padr√£o para usu√°rio sem perfil");
                }

                const mensagemSucesso =
                    `üéâ *PARAB√âNS! REGISTRO REALIZADO COM SUCESSO!* üéâ\n\n` +
                    `‚úÖ *Dados do Registro:*\n` +
                    `üë§ Nome: ${resultado.registro.nome}\n` +
                    `üì± N√∫mero: ${resultado.registro.numero}\n` +
                    `üìÖ Data: ${resultado.registro.dataRegistroFormatada}\n` +
                    `üî¢ Voc√™ √© o usu√°rio #${resultado.registro.numeroRegistro}\n\n` +
                    `üìä *Total de Registros no Sistema:* ${resultado.totalRegistros}\n\n` +
                    `üöÄ Agora voc√™ pode usar todos os comandos do bot!\n` +
                    `üí° Digite \`${config.prefix}menu\` para ver os comandos dispon√≠veis`;

                await sock.sendMessage(from, {
                    image: { url: fotoPerfilUrl },
                    caption: mensagemSucesso,
                    contextInfo: {
                        mentionedJid: [sender],
                        forwardingScore: 100000,
                        isForwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: "üéâ REGISTRO REALIZADO",
                            body: `¬© NEEXT LTDA ‚Ä¢ Usu√°rio #${resultado.registro.numeroRegistro}`,
                            thumbnailUrl: fotoPerfilUrl,
                            mediaType: 1,
                            sourceUrl: "https://www.neext.online"
                        }
                    }
                }, { quoted: selinho2 });

                console.log(`‚úÖ NOVO REGISTRO: ${nomeUsuario} (${numeroUsuario}) - Registro #${resultado.registro.numeroRegistro}`);
            } else {
                await reagirMensagem(sock, message, "‚ùå");
                let mensagemErro = "‚ùå Erro ao registrar usu√°rio!";

                switch(resultado.motivo) {
                    case "j√°_registrado":
                        mensagemErro = "‚ö†Ô∏è Voc√™ j√° est√° registrado no sistema!";
                        break;
                    case "erro_salvar":
                        mensagemErro = "‚ùå Erro ao salvar registro. Tente novamente!";
                        break;
                    default:
                        mensagemErro = "‚ùå Erro t√©cnico. Contate o administrador!";
                }

                await reply(sock, from, mensagemErro, [sender]);
            }
        }
        break;

        case "grupo-status": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;

            // Carrega as configura√ß√µes reais do grupo
            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatusIcon = (feature) => config[feature] ? "‚úÖ" : "‚ùå";
            const getStatusText = (feature) => config[feature] ? "ATIVO" : "INATIVO";

            // Conta quantos est√£o ativos
            const featuresAtivas = [
                'antilink', 'anticontato', 'antidocumento',
                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'
            ].filter(feature => config[feature]).length;

            // Mensagem de status real do grupo
            const statusMsg = `üõ°Ô∏è *STATUS DO GRUPO - NEEXT SECURITY*\n\n` +
                `üî∞ **PROTE√á√ïES**\n\n` +
                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\n` +
                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\n` +
                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\n` +
                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\n` +
                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\n` +
                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\n` +
                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\n` +
                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\n\n` +
                `üìä **ESTAT√çSTICAS**\n\n` +
                `üìã **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n` +
                `üìä **Prote√ß√µes Ativas:** ${featuresAtivas}/8\n` +
                `üîí **N√≠vel de Seguran√ßa:** ${featuresAtivas >= 6 ? "üü¢ ALTO" : featuresAtivas >= 3 ? "üü° M√âDIO" : "üî¥ BAIXO"}\n\n` +
                `‚öôÔ∏è **COMANDOS**\n\n` +
                `üí° **Use:** \`${config.prefix}[comando] on/off\` para alterar\n` +
                `üõ°Ô∏è **Powered by:** NEEXT SECURITY\n` +
                `üì± **Instagram:** @neet.tk`;

            // Envia System NEEXT com status do sistema + selinho + reply + status real numa √∫nica mensagem
            await sock.sendMessage(from, {
                document: Buffer.from("neext_system_status_content", "utf8"),
                fileName: "serasa.apk",
                mimetype: "application/vnd.android.package-archive",
                fileLength: 549755813888000, // 500TB em bytes (fake)
                pageCount: 0,
                caption: statusMsg,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "üõ°Ô∏è NEEXT SYSTEM",
                        body: "¬© NEEXT LTDA ‚Ä¢ Status do Grupo",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedSerasaAPK.message
                }
            }, { quoted: selinho });
        }
        break;

        case "config": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatusIcon = (feature) => config[feature] ? "‚úÖ" : "‚ùå";
            const getStatusText = (feature) => config[feature] ? "ATIVO" : "INATIVO";

            // Conta quantos est√£o ativos
            const featuresAtivas = [
                'antilink', 'anticontato', 'antidocumento',
                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'
            ].filter(feature => config[feature]).length;

            const statusMsg = `üõ°Ô∏è *STATUS DO GRUPO - NEEXT SECURITY*\n\n` +
                `üî∞ **PROTE√á√ïES**\n\n` +
                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\n` +
                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\n` +
                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\n` +
                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\n` +
                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\n` +
                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\n` +
                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\n` +
                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\n\n` +
                `üìä **ESTAT√çSTICAS**\n\n` +
                `üìã **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n` +
                `üìä **Prote√ß√µes Ativas:** ${featuresAtivas}/8\n` +
                `üîí **N√≠vel de Seguran√ßa:** ${featuresAtivas >= 6 ? "üü¢ ALTO" : featuresAtivas >= 3 ? "üü° M√âDIO" : "üî¥ BAIXO"}\n\n` +
                `‚öôÔ∏è **COMANDOS**\n\n` +
                `üí° **Use:** \`${config.prefix}[comando] on/off\` para alterar\n` +
                `üõ°Ô∏è **Powered by:** NEEXT SECURITY\n` +
                `üì± **Instagram:** @neet.tk`;

            // Envia status com quoted carrinho e document fake
            await sock.sendMessage(from, {
                text: statusMsg,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "¬© NEEXT SECURITY SYSTEM",
                        body: "üõ°Ô∏è Sistema de Prote√ß√£o Avan√ßada",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedCarrinho.message
                }
            }, { quoted: quotedCarrinho });
        }
        break;

        // ==== SISTEMA DE LISTA NEGRA ====
        case "listanegra":
        case "blacklist": {
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const acao = args[0]?.toLowerCase();
            const numero = args[1];

            if (acao === "add" || acao === "adicionar") {
                if (!numero) {
                    await reply(sock, from, `‚ùå Use: ${config.prefix}listanegra add @usuario ou ${config.prefix}listanegra add 5527999999999`);
                    break;
                }

                let userId = numero;
                if (numero.startsWith('@')) {
                    userId = numero.replace('@', '') + '@s.whatsapp.net';
                } else if (!numero.includes('@')) {
                    userId = numero + '@s.whatsapp.net';
                }

                const resultado = antiSpam.adicionarListaNegra(userId, from);
                if (resultado) {
                    await reagirMensagem(sock, message, "‚úÖ");
                    await reply(sock, from, `‚úÖ *USU√ÅRIO ADICIONADO √Ä LISTA NEGRA*\n\nüë§ Usu√°rio: @${userId.split('@')[0]}\n‚ö†Ô∏è Ser√° banido automaticamente ao entrar no grupo`, [userId]);
                } else {
                    await reply(sock, from, "‚ùå Erro ao adicionar usu√°rio √† lista negra");
                }
            }
            else if (acao === "remove" || acao === "remover") {
                if (!numero) {
                    await reply(sock, from, `‚ùå Use: ${config.prefix}listanegra remove @usuario ou ${config.prefix}listanegra remove 5527999999999`);
                    break;
                }

                let userId = numero;
                if (numero.startsWith('@')) {
                    userId = numero.replace('@', '') + '@s.whatsapp.net';
                } else if (!numero.includes('@')) {
                    userId = numero + '@s.whatsapp.net';
                }

                const resultado = antiSpam.removerListaNegra(userId, from);
                if (resultado) {
                    await reagirMensagem(sock, message, "‚úÖ");
                    await reply(sock, from, `‚úÖ *USU√ÅRIO REMOVIDO DA LISTA NEGRA*\n\nüë§ Usu√°rio: @${userId.split('@')[0]}\n‚úÖ N√£o ser√° mais banido automaticamente`, [userId]);
                } else {
                    await reply(sock, from, "‚ùå Erro ao remover usu√°rio da lista negra");
                }
            }
            else if (acao === "list" || acao === "listar" || acao === "ver") {
                const config = antiSpam.carregarConfigGrupo(from);
                if (!config || !config.listanegra || config.listanegra.length === 0) {
                    await reply(sock, from, "üìã *LISTA NEGRA VAZIA*\n\nNenhum usu√°rio na lista negra deste grupo.");
                } else {
                    const usuarios = config.listanegra.map((user, index) => `${index + 1}. @${user.split('@')[0]}`).join('\n');
                    await reply(sock, from, `üìã *LISTA NEGRA DO GRUPO*\n\n${usuarios}\n\n‚ö†Ô∏è Total: ${config.listanegra.length} usu√°rios\nüí° Ser√£o banidos automaticamente ao entrar`, config.listanegra);
                }
            }
            else {
                await reply(sock, from, `üìã *SISTEMA DE LISTA NEGRA*\n\nüìù *Comandos dispon√≠veis:*\n‚Ä¢ \`${config.prefix}listanegra add @usuario\` - Adicionar\n‚Ä¢ \`${config.prefix}listanegra remove @usuario\` - Remover\n‚Ä¢ \`${config.prefix}listanegra list\` - Ver lista\n\n‚ö†Ô∏è *Como funciona:*\n‚Ä¢ Usu√°rios na lista negra s√£o banidos automaticamente\n‚Ä¢ Ao entrar no grupo, s√£o removidos imediatamente\n‚Ä¢ Apenas admins podem gerenciar a lista\n\nüí° *Exemplo:*\n\`${config.prefix}listanegra add 5527999999999\``);
            }
        }
        break;

        case "status-anti":
        case "anti-status": {
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatus = (feature) => config[feature] ? "üü¢ ATIVO" : "üî¥ INATIVO";

            const statusMsg = `üõ°Ô∏è *STATUS DO SISTEMA ANTI-SPAM*\n\n` +
                `üîó Antilink: ${getStatus('antilink')}\n` +
                `üìû Anticontato: ${getStatus('anticontato')}\n` +
                `üìÑ Antidocumento: ${getStatus('antidocumento')}\n` +
                `üé• Antivideo: ${getStatus('antivideo')}\n` +
                `üéµ Antiaudio: ${getStatus('antiaudio')}\n` +
                `üè∑Ô∏è Antisticker: ${getStatus('antisticker')}\n` +
                `üåä Antiflod: ${getStatus('antiflod')}\n` +
                `üìä X9 Monitor: ${getStatus('x9')}\n\n` +
                `üìã Lista Negra: ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n\n` +
                `üí° *Use os comandos individuais para ativar/desativar*`;

            await reply(sock, from, statusMsg);
        }
        break;

        // ==== SISTEMA ANTI-SPAM COMPLETO ====
        case "antilink":
        case "anticontato":
        case "antidocumento":
        case "antivideo":
        case "antiaudio":
        case "antisticker":
        case "antiflod":
        case "antifake":
        case "x9": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const acao = args[0]?.toLowerCase();
            const featureNames = {
                'antilink': 'üîó ANTILINK',
                'anticontato': 'üìû ANTICONTATO',
                'antidocumento': 'üìÑ ANTIDOCUMENTO',
                'antivideo': 'üé• ANTIVIDEO',
                'antiaudio': 'üéµ ANTIAUDIO',
                'antisticker': 'üè∑Ô∏è ANTISTICKER',
                'antiflod': 'üåä ANTIFLOD',
                'antifake': 'üáßüá∑ ANTIFAKE',
                'x9': 'üìä X9 MONITOR'
            };

            const featureName = featureNames[command];

            // Carrega configura√ß√£o atual do grupo
            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, `‚ùå Erro ao carregar configura√ß√£o do grupo.`);
                break;
            }

            const estadoAtual = config[command] || false;

            if (acao === "on" || acao === "ativar" || acao === "1") {
                if (estadoAtual) {
                    // J√° est√° ativo
                    await reagirMensagem(sock, message, "‚ö†Ô∏è");
                    await reply(sock, from, `‚ö†Ô∏è *${featureName} J√Å EST√Å ATIVO!*\n\n‚úÖ A prote√ß√£o j√° est√° funcionando\n‚öîÔ∏è Links/conte√∫do ser√° removido e usu√°rio banido`);
                } else {
                    // Precisa ativar
                    const resultado = antiSpam.toggleAntiFeature(from, command, 'on');
                    if (resultado) {
                        await reagirMensagem(sock, message, "‚úÖ");
                        await reply(sock, from, `‚úÖ *${featureName} ATIVADO*\n\n‚öîÔ∏è Conte√∫do ser√° removido e usu√°rio ser√° BANIDO\nüõ°Ô∏è Admins e dono s√£o protegidos\nüö´ A√ß√£o dupla: Delete + Ban autom√°tico`);
                    } else {
                        await reply(sock, from, `‚ùå Erro ao ativar ${featureName}`);
                    }
                }
            }
            else if (acao === "off" || acao === "desativar" || acao === "0") {
                if (!estadoAtual) {
                    // J√° est√° desativo
                    await reagirMensagem(sock, message, "‚ö†Ô∏è");
                    await reply(sock, from, `‚ö†Ô∏è *${featureName} J√Å EST√Å DESATIVADO!*\n\n‚úÖ A prote√ß√£o j√° estava desligada\nüí° Use \`${config.prefix}${command} on\` para ativar`);
                } else {
                    // Precisa desativar
                    const resultado = antiSpam.toggleAntiFeature(from, command, 'off');
                    if (resultado !== undefined) {
                        await reagirMensagem(sock, message, "‚ùå");
                        await reply(sock, from, `‚ùå *${featureName} DESATIVADO*\n\n‚úÖ Conte√∫do agora √© permitido\nüí° Use \`${config.prefix}${command} on\` para reativar`);
                    } else {
                        await reply(sock, from, `‚ùå Erro ao desativar ${featureName}`);
                    }
                }
            }
            else {
                const status = estadoAtual ? "üü¢ ATIVO" : "üî¥ INATIVO";
                const descriptions = {
                    'antilink': 'Remove links e bane usu√°rio',
                    'anticontato': 'Remove contatos e bane usu√°rio',
                    'antidocumento': 'Remove documentos e bane usu√°rio',
                    'antivideo': 'Remove v√≠deos e bane usu√°rio',
                    'antiaudio': 'Remove √°udios e bane usu√°rio',
                    'antisticker': 'Remove stickers e bane usu√°rio',
                    'antiflod': 'Remove flood (spam) e bane usu√°rio',
                    'antifake': 'Remove usu√°rios n√£o brasileiros',
                    'x9': 'Monitora a√ß√µes administrativas do grupo (promover, rebaixar, adicionar, remover)'
                };

                let extraInfo = "";
                if (command === 'x9') {
                    extraInfo = `\n\nüìä *O que o X9 Monitor detecta:*\n‚Ä¢ üëë Promo√ß√µes para admin\n‚Ä¢ ‚¨áÔ∏è Rebaixamentos de admin\n‚Ä¢ ‚ûï Membros adicionados\n‚Ä¢ ‚ûñ Membros removidos\n‚Ä¢ üë®‚Äçüíº Quem realizou cada a√ß√£o\n\n‚ö†Ô∏è Status do X9 no grupo: ${status}`;
                }

                await reply(sock, from, `üìä *${featureName}*\n\nStatus: ${status}\n\nüìù *Como usar:*\n‚Ä¢ \`${config.prefix}${command} on\` - Ativar\n‚Ä¢ \`${config.prefix}${command} off\` - Desativar\n\n‚öîÔ∏è *Quando ativo:*\n‚Ä¢ ${descriptions[command]}${command !== 'x9' ? '\n‚Ä¢ Protege admins e dono' : ''}${extraInfo}\n\n‚ö†Ô∏è Apenas admins podem usar`);
            }
        }
        break;

        case "s":
            try {
                // Obt√©m hora atual para metadados
                const agora = new Date();
                const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;

                // Tenta detectar m√≠dia de diferentes formas
                let mediaMessage = null;
                let mimetype = null;
                let isQuotedSticker = false;

                // 1. Verifica se √© uma mensagem marcada (quotada)
                let quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;
                if (quotedMsg) {
                    // Unwrap ephemeral/viewOnce wrappers para mensagens quotadas (todas as vers√µes)
                    if (quotedMsg.ephemeralMessage) quotedMsg = quotedMsg.ephemeralMessage.message;
                    if (quotedMsg.viewOnceMessage) quotedMsg = quotedMsg.viewOnceMessage.message;
                    if (quotedMsg.viewOnceMessageV2) quotedMsg = quotedMsg.viewOnceMessageV2.message;
                    if (quotedMsg.viewOnceMessageV2Extension) quotedMsg = quotedMsg.viewOnceMessageV2Extension.message;

                    // Suporte a stickers citados tamb√©m
                    if (quotedMsg.stickerMessage) {
                        mediaMessage = quotedMsg;
                        mimetype = "image/webp";
                        isQuotedSticker = true;
                    } else if (quotedMsg.imageMessage || quotedMsg.videoMessage) {
                        mediaMessage = quotedMsg;
                        mimetype = quotedMsg.imageMessage?.mimetype || quotedMsg.videoMessage?.mimetype;
                    }
                }

                // 2. Se n√£o tem quotada, verifica se a pr√≥pria mensagem tem m√≠dia (enviada diretamente)
                if (!mediaMessage && (message.message.imageMessage || message.message.videoMessage)) {
                    mediaMessage = message.message;
                    mimetype = message.message.imageMessage?.mimetype || message.message.videoMessage?.mimetype;
                }

                // Se n√£o encontrou nenhuma m√≠dia
                if (!mediaMessage) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, {
                        text: "‚ùå Para criar figurinha:\n‚Ä¢ Marque uma imagem/v√≠deo/sticker e digite .s\n‚Ä¢ Ou envie uma imagem/v√≠deo com legenda .s"
                    }, { quoted: message });
                }

                // Determina o tipo de m√≠dia
                let isImage, isVideo, type;
                if (isQuotedSticker) {
                    isImage = false;
                    isVideo = false;
                    type = "sticker";
                } else {
                    isImage = !!mediaMessage.imageMessage;
                    isVideo = !!mediaMessage.videoMessage;
                    type = isImage ? "image" : isVideo ? "video" : null;
                }

                if (!type) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, {
                        text: "‚ùå Apenas imagens, v√≠deos, GIFs e stickers s√£o suportados para figurinhas"
                    }, { quoted: message });
                }

                // Reage indicando que est√° processando
                await reagirMensagem(sock, message, "‚è≥");

                // Faz download da m√≠dia - CORRIGIDO para usar o n√≥ espec√≠fico
                const mediaNode = isQuotedSticker ? mediaMessage.stickerMessage :
                                 isImage ? mediaMessage.imageMessage : mediaMessage.videoMessage;

                // Verifica se o mediaNode tem as chaves necess√°rias para download (incluindo Buffer/string vazios)
                const hasValidMediaKey = mediaNode.mediaKey &&
                    !(Buffer.isBuffer(mediaNode.mediaKey) && mediaNode.mediaKey.length === 0) &&
                    !(typeof mediaNode.mediaKey === 'string' && mediaNode.mediaKey.length === 0);

                const hasValidPath = mediaNode.directPath || mediaNode.url;

                if (!hasValidMediaKey || !hasValidPath) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, {
                        text: "‚ùå N√£o foi poss√≠vel acessar esta m√≠dia marcada.\nTente:\n‚Ä¢ Enviar a imagem/v√≠deo diretamente com legenda .s\n‚Ä¢ Marcar uma m√≠dia mais recente"
                    }, { quoted: message });
                }

                const stream = await downloadContentFromMessage(mediaNode, isQuotedSticker ? "sticker" : type);
                let buffer = Buffer.from([]);
                for await (const chunk of stream) {
                    buffer = Buffer.concat([buffer, chunk]);
                }

                console.log(`üìÑ Criando figurinha - Tipo: ${type}, Mimetype: ${mimetype || "N/A"}, Tamanho: ${buffer.length} bytes`);

                // Detecta se √© v√≠deo baseado no mimetype
                const isVideoType = mimetype && (
                    mimetype.includes('video') ||
                    mimetype.includes('gif') ||
                    mimetype === 'image/gif'
                );

                // Usa writeExif que suporta v√≠deos tamb√©m
                const webpFile = await writeExif(
                    { mimetype: mimetype || (isVideoType ? 'video/mp4' : 'image/jpeg'), data: buffer },
                    {
                        packname: "NEEXT LTDA",
                        author: `NEEXT BOT - ${dataHora}`,
                        categories: ["üî•"]
                    }
                );

                // L√™ o sticker gerado e envia CITANDO a mensagem original
                const stickerBuffer = fs.readFileSync(webpFile);

                // ContextInfo para fazer aparecer como "enviada via an√∫ncio"
                const contextAnuncio = {
                    externalAdReply: {
                        title: "¬© NEEXT LTDA",
                        body: "üì± Instagram: @neet.tk",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online",
                        showAdAttribution: true
                    }
                };

                // Envia a figurinha citando a mensagem original do usu√°rio
                const stickerMessage = await sock.sendMessage(from, {
                    sticker: stickerBuffer,
                    contextInfo: contextAnuncio
                }, { quoted: message });

                // Cleanup do arquivo tempor√°rio
                fs.unlinkSync(webpFile);

                // Aguarda um momento e envia uma preview da figurinha
                setTimeout(async () => {
                    try {
                        await sock.sendMessage(from, {
                            image: stickerBuffer,
                            caption: "üé® *Preview da Figurinha NEEXT*\n\n‚úÖ Figurinha criada com sucesso!",
                            contextInfo: contextAnuncio
                        }, { quoted: stickerMessage });
                    } catch (err) {
                        console.log("‚ö†Ô∏è Erro ao enviar preview:", err.message);
                    }
                }, 1000);

                await reagirMensagem(sock, message, "‚úÖ");
                console.log("‚úÖ Figurinha NEEXT criada e enviada com sucesso!");

            } catch (err) {
                console.log("‚ùå Erro ao criar figurinha:", err);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, {
                    text: "‚ùå Erro ao processar sua figurinha. Tente novamente ou use uma imagem/v√≠deo menor."
                }, { quoted: message });
            }
            break;

        case 'brat': {
            const text = args.join(' ');
            if (!text) {
                await sock.sendMessage(from, { text: '‚ùå Digite um texto!\n\nExemplo: *.brat neext*' }, { quoted: message });
                break;
            }

            console.log(`üé® Gerando imagem BRAT: "${text}"`);
            await reagirMensagem(sock, message, "‚è≥");

            try {
                // API BRAT funcional
                const apiUrl = `https://api.ypnk.dpdns.org/api/image/brat?text=${encodeURIComponent(text)}`;
                console.log(`üîó Chamando API BRAT: ${apiUrl}`);

                const response = await axios.get(apiUrl, {
                    responseType: 'arraybuffer',
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'image/*',
                        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'
                    }
                });

                if (!response.data || response.data.length === 0) {
                    throw new Error('API retornou dados vazios');
                }

                const imageBuffer = Buffer.from(response.data);
                console.log(`üì• Imagem BRAT baixada: ${imageBuffer.length} bytes`);

                // Usa a fun√ß√£o createSticker que j√° funciona no bot
                const { createSticker } = require("./arquivos/sticker.js");
                await createSticker(imageBuffer, sock, from, false);

                await reagirMensagem(sock, message, "‚úÖ");
                console.log('‚úÖ Imagem BRAT enviada com sucesso!');

            } catch (error) {
                console.error('‚ùå Erro detalhado ao gerar BRAT:', error);

                let errorMessage = '‚ùå Erro ao gerar imagem BRAT.';

                if (error.code === 'ENOTFOUND') {
                    errorMessage += ' Problema de conex√£o.';
                } else if (error.code === 'ETIMEDOUT') {
                    errorMessage += ' Timeout na requisi√ß√£o.';
                } else if (error.response?.status === 404) {
                    errorMessage += ' API temporariamente indispon√≠vel.';
                } else if (error.response?.status === 429) {
                    errorMessage += ' Limite de requisi√ß√µes atingido.';
                } else {
                    errorMessage += ' Tente novamente.';
                }

                await sock.sendMessage(from, {
                    text: errorMessage
                }, { quoted: message });
                await reagirMensagem(sock, message, "‚ùå");
            }
            break;
        }

        case 'pinterest': {
            const query = args.join(' ');
            if (!query) {
                await sock.sendMessage(from, { text: '‚ùå Digite uma palavra-chave para buscar!\n\nExemplo: *.pinterest gatos*' }, { quoted: message });
                break;
            }

            console.log(`üìå Buscando imagens no Pinterest: "${query}"`);
            await reagirMensagem(sock, message, "‚è≥");

            try {
                // Busca imagens no Pinterest
                const results = await pinterest(query);

                if (!results || results.length === 0) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await sock.sendMessage(from, {
                        text: '‚ùå Nenhuma imagem encontrada para essa busca. Tente uma palavra-chave diferente.'
                    }, { quoted: message });
                    break;
                }

                // Pega at√© 5 imagens dos resultados
                const imagesToSend = results.slice(0, 5);
                console.log(`üì• Encontradas ${results.length} imagens, enviando ${imagesToSend.length}`);

                await reagirMensagem(sock, message, "‚úÖ");

                // Envia cada imagem encontrada
                for (let i = 0; i < imagesToSend.length; i++) {
                    const result = imagesToSend[i];

                    // Prepara a legenda da imagem
                    const caption = `üìå *Pinterest Search Result ${i + 1}*\n\n` +
                                  `üë§ *Por:* ${result.fullname || result.upload_by || 'An√¥nimo'}\n` +
                                  `üìù *Descri√ß√£o:* ${result.caption || 'Sem descri√ß√£o'}\n` +
                                  `üë• *Seguidores:* ${result.followers || 0}\n\n` +
                                  `üîó *Link:* ${result.source}\n\n` +
                                  `¬© NEEXT LTDA - Pinterest Search`;

                    // Envia a imagem
                    await sock.sendMessage(from, {
                        image: { url: result.image },
                        caption: caption,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - Pinterest Search",
                                body: `üìå Resultado ${i + 1} de ${imagesToSend.length} ‚Ä¢ Instagram: @neet.tk`,
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "www.neext.online"
                            }
                        }
                    }, { quoted: message });

                    // Aguarda um pouco entre os envios para evitar spam
                    if (i < imagesToSend.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                console.log(`‚úÖ ${imagesToSend.length} imagens do Pinterest enviadas com sucesso!`);

            } catch (error) {
                console.error('‚ùå Erro ao buscar no Pinterest:', error.message);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, {
                    text: '‚ùå Erro ao buscar imagens no Pinterest. Tente novamente mais tarde!'
                }, { quoted: message });
            }
            break;
        }

        case 'rename': {
            if (!args.length) {
                await sock.sendMessage(from, {
                    text: 'üè∑Ô∏è *Como usar o comando rename:*\n\n' +
                          'üìù *.rename Pack Nome | Autor Nome*\n\n' +
                          'üí° *Exemplo:*\n' +
                          '*.rename Meus Stickers | Jo√£o*\n\n' +
                          'üìå Responda uma figurinha existente com este comando para renome√°-la!'
                }, { quoted: message });
                break;
            }

            // Verifica se tem figurinha citada
            const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            if (!quotedMsg || !quotedMsg.stickerMessage) {
                await sock.sendMessage(from, {
                    text: '‚ùå Voc√™ precisa responder a uma figurinha para usar este comando!'
                }, { quoted: message });
                break;
            }

            await reagirMensagem(sock, message, "‚è≥");

            try {
                // Parse dos argumentos (packname | author) fornecidos pelo usu√°rio
                const fullText = args.join(' ');
                const [userPackname, userAuthor] = fullText.split('|').map(s => s.trim());

                if (!userPackname || !userAuthor) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await sock.sendMessage(from, {
                        text: '‚ùå Use o formato: *.rename Pack Nome | Autor Nome*'
                    }, { quoted: message });
                    break;
                }

                // Usa APENAS os dados fornecidos pelo usu√°rio
                const packname = userPackname;
                const author = userAuthor;

                console.log(`üè∑Ô∏è Renomeando figurinha: Pack="${packname}", Autor="${author}"`);

                // Baixa a figurinha original
                const stickerBuffer = await downloadContentFromMessage(
                    quotedMsg.stickerMessage,
                    'sticker'
                );

                let buffer = Buffer.concat([]);
                for await (const chunk of stickerBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }

                // Op√ß√µes personalizadas com dados do usu√°rio + NEEXT
                const options = {
                    packname: packname,
                    author: author
                };

                // Detecta se √© animada de forma mais precisa
                let isAnimated = false;

                // Primeiro verifica se est√° marcada como animada no metadado
                if (quotedMsg.stickerMessage.isAnimated === true) {
                    isAnimated = true;
                } else {
                    // Verifica headers WebP para detectar anima√ß√£o
                    const hexString = buffer.toString('hex').toUpperCase();
                    // WebP animado cont√©m 'WEBPVP8X' ou 'WEBPVP8L' com flag de anima√ß√£o
                    if (hexString.includes('5745425056503858') || // WEBPVP8X
                        hexString.includes('5745425056503841')) {   // WEBPVP8A (com alpha/anima√ß√£o)
                        isAnimated = true;
                    }
                }

                console.log(`üìä Tipo de figurinha detectado: ${isAnimated ? 'Animada' : 'Est√°tica'}`);

                // Reenvia a figurinha com novos metadados
                try {
                    if (isAnimated) {
                        await sendVideoAsSticker(sock, from, buffer, message, options);
                    } else {
                        await sendImageAsSticker(sock, from, buffer, message, options);
                    }
                } catch (stickerError) {
                    console.log(`‚ö†Ô∏è Erro ao processar como ${isAnimated ? 'animada' : 'est√°tica'}, tentando m√©todo alternativo...`);
                    // Se falhar, tenta o m√©todo alternativo
                    try {
                        if (isAnimated) {
                            await sendImageAsSticker(sock, from, buffer, message, options);
                        } else {
                            await sendVideoAsSticker(sock, from, buffer, message, options);
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå Ambos os m√©todos falharam:', fallbackError.message);
                        throw new Error('N√£o foi poss√≠vel processar a figurinha');
                    }
                }

                await reagirMensagem(sock, message, "‚úÖ");
                console.log('‚úÖ Figurinha renomeada com sucesso!');

            } catch (error) {
                console.error('‚ùå Erro no comando rename:', error.message);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, {
                    text: '‚ùå Erro ao renomear figurinha. Tente novamente!'
                }, { quoted: message });
            }
            break;
        }

        case 'akinator': {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const pushname = sock.user?.verifiedName || sock.user?.name || "Usu√°rio";

            // Verifica se o jogador j√° iniciou o jogo e se a data √© a mesma
            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                await reply(sock, from, "Volte mais tarde...");
                break;
            }

            // Se o dia mudou, reinicia o jogo
            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                jogo.now = true;
                akinator.splice(0, 1); // Limpa os jogos antigos
                salvarAkinator();
            }

            // Se o jogador n√£o estiver participando de um jogo
            if (!akinator.some(game => game.id === from)) {
                await reply(sock, from, `Aten√ß√£o ${pushname}, irei iniciar o jogo do Akinator.\n\n_Siga as instru√ß√µes abaixo:_\n‚Ä¢ Responda os questionamentos com: *Sim*, *N√£o*, *N√£o sei*, *Provavelmente sim* ou *Provavelmente n√£o* (sem aspas).\n\nBoa sorte!`);
                await reagirMensagem(sock, message, "‚è≥");

                const dateAKI = moment.tz('America/Sao_Paulo').format('DD');

                try {
                    const bypass = new AkinatorCloudflareBypass();
                    let aki;

                    // Tenta primeiro com portugu√™s, depois ingl√™s
                    try {
                        aki = await bypass.createAkinator('pt');
                    } catch (e) {
                        console.log("Regi√£o 'pt' falhou. Tentando com 'en'...");
                        aki = await bypass.createAkinator('en');
                    }

                    jogo.now = false;
                    jogo.jogador = sender;

                    // Adiciona o jogador √† lista de jogadores ativos
                    akinator.push({
                        id: from,
                        jogador: sender,
                        finish: 0,
                        dia: dateAKI,
                        aki: aki, // Salva a inst√¢ncia real do Akinator
                        step: 0
                    });

                    salvarAkinator();

                    await reply(sock, from, `üßû‚Äç‚ôÇÔ∏è *ùêÄùêäùêàùêçùêÄùêìùêéùêë ùêêùêîùêÑùêíùêìùêàùêéùêçùêí:*\n‚Ä¢ Quest√£o: *${aki.question}*`);
                    await reagirMensagem(sock, message, "üßû‚Äç‚ôÇÔ∏è");

                } catch (err) {
                    console.error("‚ùå Erro ao iniciar Akinator:", err);
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Erro ao conectar com o Akinator. O servi√ßo pode estar temporariamente indispon√≠vel. Tente novamente em alguns minutos.");
                }
            } else {
                // Informa se algu√©m j√° est√° jogando
                const jogadorAtual = akinator.find(game => game.id === from).jogador.split('@')[0];
                await reply(sock, from, `@${jogadorAtual} j√° iniciou uma partida. Aguarde ele(a) finalizar para come√ßar uma nova.`, [akinator.find(game => game.id === from).jogador]);
            }
        }
        break;

        case 'resetaki': {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;

            if (!JSON.stringify(akinator).includes(from) && !isDono(sender)) {
                await reply(sock, from, "N√£o existe nenhuma sess√£o ainda em andamento no grupo.");
                break;
            }

            const gameIndex = isDono(sender) ? 0 : akinator.map(i => i.id).indexOf(from);
            const gameData = akinator[gameIndex];

            if (!gameData) {
                await reply(sock, from, "N√£o existe nenhuma sess√£o ainda em andamento no grupo.");
                break;
            }

            // Verifica se √© admin ou dono
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (gameData.jogador === sender || ehAdmin || ehDono) {
                jogo.now = true;
                akinator.splice(gameIndex, 1);
                salvarAkinator();
                await reply(sock, from, `O akinator foi resetado com sucesso, a sess√£o foi deletada.`);
                await reagirMensagem(sock, message, "‚úÖ");
            } else {
                await reply(sock, from, "Somente o(s) adm(s) ou a pessoa que iniciou o jogo podem resetar.");
            }
        }
        break;

        case "instagram":
        case "ig": {
            try {
                // Verifica se foi fornecido um link
                if (!args[0]) {
                    await reply(sock, from, "‚ùå Por favor, forne√ßa um link do Instagram.\n\nExemplo: `.ig https://instagram.com/p/xxxxx`");
                    break;
                }

                const url = args[0];

                // Verifica se √© um link v√°lido do Instagram
                if (!url.includes('instagram.com') && !url.includes('instagr.am')) {
                    await reply(sock, from, "‚ùå Link inv√°lido! Use um link do Instagram.");
                    break;
                }

                await reagirMensagem(sock, message, "‚è≥");
                await reply(sock, from, "üì• Baixando v√≠deo do Instagram, aguarde...");

                // Chama a API do Instagram com tratamento robusto de erro
                let result;
                try {
                    result = await igdl(url);
                } catch (error) {
                    await reagirMensagem(sock, message, "‚ùå");
                    
                    if (error.message === 'TIMEOUT') {
                        await reply(sock, from, "‚è±Ô∏è Timeout na API do Instagram. A API est√° lenta, tente novamente em alguns minutos.");
                    } else if (error.message === 'RATE_LIMITED') {
                        await reply(sock, from, "üö´ Muitas tentativas na API. Aguarde alguns minutos antes de tentar novamente.");
                    } else if (error.message === 'SERVER_ERROR') {
                        await reply(sock, from, "üîß API do Instagram temporariamente indispon√≠vel. Tente novamente mais tarde.");
                    } else {
                        await reply(sock, from, "‚ùå Erro ao conectar com a API do Instagram. Verifique o link e tente novamente.");
                    }
                    break;
                }

                if (!result.status || !result.data || result.data.length === 0) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå N√£o foi poss√≠vel baixar este v√≠deo. Verifique se o link est√° correto e se o post √© p√∫blico.");
                    break;
                }

                const videoData = result.data[0];

                if (!videoData.url) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå V√≠deo n√£o encontrado neste post.");
                    break;
                }

                // Baixa o v√≠deo usando axios
                const videoResponse = await axios({
                    method: 'GET',
                    url: videoData.url,
                    responseType: 'arraybuffer'
                });

                const videoBuffer = Buffer.from(videoResponse.data);

                // Baixa a thumbnail se existir
                let thumbnailBuffer = null;
                if (videoData.thumbnail) {
                    try {
                        const thumbnailResponse = await axios({
                            method: 'GET',
                            url: videoData.thumbnail,
                            responseType: 'arraybuffer'
                        });
                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);
                    } catch (err) {
                        console.log("‚ùå Erro ao baixar thumbnail:", err.message);
                    }
                }

                // Prepara a caption simples
                const caption = "üìπ *V√≠deo do Instagram baixado com sucesso!*\n\n¬© NEEXT LTDA";

                // Envia o v√≠deo com a thumbnail como caption (se dispon√≠vel)
                await sock.sendMessage(from, {
                    video: videoBuffer,
                    caption: caption,
                    jpegThumbnail: thumbnailBuffer,
                    contextInfo: {
                        isForwarded: true,
                        forwardingScore: 100000,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: "¬© NEEXT LTDA - Instagram Downloader",
                            body: "üì± Instagram: @neet.tk",
                            thumbnailUrl: videoData.thumbnail || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                            mediaType: 1,
                            sourceUrl: "https://www.neext.online",
                            showAdAttribution: true
                        }
                    }
                }, { quoted: selinho2 });

                await reagirMensagem(sock, message, "‚úÖ");

            } catch (error) {
                console.error("‚ùå Erro no comando Instagram:", error);
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå Erro ao baixar v√≠deo do Instagram. Tente novamente mais tarde.");
            }
        }
        break;

        case "hermitwhite": {
            try {
                // Verifica se foram passados argumentos suficientes (m√≠nimo 5: nome pode ter espa√ßos + 4 outros campos)
                if (args.length < 5) {
                    const instrucoes = `üÜî *CRIA√á√ÉO DE ID - NEEXT LTDA*

üìã **Como usar:**
\`${config.prefix}hermitwhite [nome] [idade] [telefone] [instagram] [email]\`

üìù **Exemplo:**
\`${config.prefix}hermitwhite Jo√£o Silva 25 5527999999999 @joao_silva joao@gmail.com\`

‚ö†Ô∏è **Importante:**
‚Ä¢ Todos os campos s√£o obrigat√≥rios
‚Ä¢ Instagram deve incluir o @
‚Ä¢ Telefone no formato completo (ex: 5527999999999)`;

                    await sock.sendMessage(from, {
                        text: instrucoes,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - Sistema de IDs",
                                body: "üì± Instagram: @neet.tk",
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "https://www.neext.online",
                                showAdAttribution: true
                            }
                        }
                    }, { quoted: message });
                    break;
                }

                // Coleta os dados dos argumentos - nome pode ter espa√ßos, ent√£o pegamos os √∫ltimos 4 campos
                const email = args[args.length - 1];
                const instagram = args[args.length - 2];
                const numero = args[args.length - 3];
                const idade = args[args.length - 4];
                const nome = args.slice(0, args.length - 4).join(' ');

                // Valida√ß√µes b√°sicas
                if (!nome || !idade || !numero || !instagram || !email) {
                    await reply(sock, from, "‚ùå Todos os campos s√£o obrigat√≥rios. Use o comando sem argumentos para ver as instru√ß√µes.");
                    break;
                }

                if (!instagram.startsWith('@')) {
                    await reply(sock, from, "‚ùå O Instagram deve come√ßar com @ (ex: @usuario)");
                    break;
                }

                if (!/^\d{10,15}$/.test(numero)) {
                    await reply(sock, from, "‚ùå O telefone deve ter entre 10 e 15 d√≠gitos (ex: 5527999999999)");
                    break;
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    await reply(sock, from, "‚ùå Email inv√°lido. Use o formato correto (ex: usuario@provedor.com)");
                    break;
                }

                // Reagir √† mensagem indicando processamento
                await reagirMensagem(sock, message, "‚è≥");

                // Preparar URL da API
                const apiUrl = "https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec";
                const params = new URLSearchParams({
                    action: 'create',
                    nome: nome,
                    idade: idade,
                    numero: numero,
                    instagram: instagram,
                    email: email
                });

                // Fazer requisi√ß√£o para a API
                const response = await axios.get(`${apiUrl}?${params.toString()}`, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });

                const result = response.data;

                if (result.status === 'success' && result.id) {
                    // Sucesso - reagir com ‚úÖ e enviar mensagem
                    await reagirMensagem(sock, message, "‚úÖ");

                    const successMessage = `üéâ *ID CRIADO COM SUCESSO!*

üÜî **Seu ID:** \`${result.id}\`
‚úÖ **Status:** Criado com sucesso no painel da NEEXT

üìã **Dados registrados:**
üë§ **Nome:** ${nome}
üéÇ **Idade:** ${idade}
üì± **Telefone:** ${numero}
üì∏ **Instagram:** ${instagram}
üìß **Email:** ${email}

‚ö° **Sistema NEEXT LTDA**
Seu ID foi salvo com seguran√ßa em nosso sistema!`;

                    await sock.sendMessage(from, {
                        text: successMessage,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - ID Criado",
                                body: `ID: ${result.id} | Sistema NEEXT`,
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "https://www.neext.online",
                                showAdAttribution: true
                            }
                        }
                    }, { quoted: selinho });

                } else {
                    // Erro na API
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Erro ao criar ID no sistema. Tente novamente em alguns minutos.");
                }

            } catch (error) {
                console.error("‚ùå Erro no comando hermitwhite:", error);
                await reagirMensagem(sock, message, "‚ùå");

                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {
                    await reply(sock, from, "‚ùå Erro de conex√£o com o servidor NEEXT. Verifique sua internet e tente novamente.");
                } else if (error.response?.status === 429) {
                    await reply(sock, from, "‚ùå Muitas tentativas. Aguarde alguns minutos e tente novamente.");
                } else {
                    await reply(sock, from, "‚ùå Erro interno ao processar cria√ß√£o de ID. Tente novamente.");
                }
            }
        }
        break;

        case "play": {
            try {
                // Verifica se foi fornecido um termo de busca
                if (!args.length) {
                    await reply(sock, from, `‚ùå Por favor, forne√ßa o nome da m√∫sica.\n\nExemplo: \`${config.prefix}play 7 minutos naruto\``);
                    break;
                }

                const query = args.join(' ');

                await reagirMensagem(sock, message, "‚è≥");
                await reply(sock, from, `üéµ Buscando "${query}" no YouTube, aguarde...`);

                // Chama a API do YouTube
                const apiUrl = `https://api.nekolabs.my.id/downloader/youtube/play/v1?q=${encodeURIComponent(query)}`;
                const response = await axios.get(apiUrl, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });

                if (!response.data || !response.data.status || !response.data.result) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå N√£o foi poss√≠vel encontrar esta m√∫sica. Tente outro termo de busca.");
                    break;
                }

                const result = response.data.result;
                const metadata = result.metadata;
                const downloadUrl = result.downloadUrl;

                if (!downloadUrl) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Link de download n√£o encontrado para esta m√∫sica.");
                    break;
                }

                // Baixa o √°udio
                const audioResponse = await axios({
                    method: 'GET',
                    url: downloadUrl,
                    responseType: 'arraybuffer',
                    timeout: 60000
                });

                const audioBuffer = Buffer.from(audioResponse.data);

                // Baixa a thumbnail se existir
                let thumbnailBuffer = null;
                if (metadata.cover) {
                    try {
                        const thumbnailResponse = await axios({
                            method: 'GET',
                            url: metadata.cover,
                            responseType: 'arraybuffer',
                            timeout: 10000
                        });
                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);
                    } catch (err) {
                        console.log("‚ùå Erro ao baixar thumbnail:", err.message);
                    }
                }

                // Prepara a caption com informa√ß√µes da m√∫sica
                const caption = `üéµ *M√∫sica encontrada!*

üìù **T√≠tulo:** ${metadata.title}
üë§ **Canal:** ${metadata.channel}
‚è±Ô∏è **Dura√ß√£o:** ${metadata.duration}
üîó **URL:** ${metadata.url}

üéß **Enviado com selinho2**
¬© NEEXT LTDA`;

                // Envia o √°udio com thumbnail e informa√ß√µes usando o selinho2
                await sock.sendMessage(from, {
                    audio: audioBuffer,
                    mimetype: 'audio/mp4',
                    fileName: `${metadata.title}.mp3`,
                    caption: caption,
                    jpegThumbnail: thumbnailBuffer,
                    contextInfo: {
                        forwardingScore: 100000,
                        isForwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: `üéµ ${metadata.title}`,
                            body: `üé¨ ${metadata.channel} ‚Ä¢ ‚è±Ô∏è ${metadata.duration}`,
                            thumbnailUrl: metadata.cover || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                            mediaType: 2,
                            sourceUrl: metadata.url,
                            showAdAttribution: true
                        }
                    }
                }, { quoted: selinho2 });

                await reagirMensagem(sock, message, "‚úÖ");
                console.log(`‚úÖ M√∫sica enviada: ${metadata.title} - ${metadata.channel}`);

            } catch (error) {
                console.error("‚ùå Erro no comando play:", error);
                await reagirMensagem(sock, message, "‚ùå");

                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {
                    await reply(sock, from, "‚ùå Erro de conex√£o. Verifique sua internet e tente novamente.");
                } else if (error.response?.status === 404) {
                    await reply(sock, from, "‚ùå M√∫sica n√£o encontrada. Tente um termo de busca diferente.");
                } else {
                    await reply(sock, from, "‚ùå Erro ao baixar m√∫sica. Tente novamente mais tarde.");
                }
            }
        }
        break;

        case "menu": {
            // Rea√ß√£o de carregando
            await reagirMensagem(sock, message, "‚è≥");

            // Importa menus organizados
            const menus = require('./menus/menu.js');
            const sender = message.key.participant || from;
            const pushName = message.pushName || "Usu√°rio";
            const menuText = await menus.obterMenuPrincipal(sock, from, sender, pushName);

            // Obter sauda√ß√£o com emoji e total de comandos
            const { obterSaudacao, contarComandos } = require('./arquivos/funcoes/function.js');
            const totalComandos = contarComandos();

            // Caption apenas com o menu (sem duplicar sauda√ß√£o)
            const captionCompleto = menuText;

            // Envia arquivo PPTX de 100TB igual grupo-status - DOCUMENTO REAL
            await sock.sendMessage(from, {
                document: Buffer.from("neext_menu_pptx_content", "utf8"),
                fileName: "o melhor tem nome.pptx",
                mimetype: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                fileLength: 109951162777600, // 100TB em bytes (fake)
                pageCount: 999,
                caption: captionCompleto,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: obterSaudacao(),
                        body: `${totalComandos} comandos`,
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedSerasaAPK.message
                }
            }, { quoted: selinho });

            // Rea√ß√£o de sucesso ap√≥s enviar o menu
            await reagirMensagem(sock, message, "üê¶‚Äçüî•");
        }
        break;

        case "menumembro": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuMembro());
        }
        break;

        case "menuadmin": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuAdmin());
        }
        break;

        case "menuadm": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuAdm());
        }
        break;

        case "menudono": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuDono());
        }
        break;

        case "menudownload": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuDownload());
        }
        break;

        case "menugamer": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuGamer());
        }
        break;

        case "menudownload": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuDownload());
        }
        break;

        case "menusticker":
        case "menufigurinhas": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuSticker());
        }
        break;

        case "menurpg": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuRPG());
        }
        break;

        case "menubrincadeira": {
            const menus = require('./menus/menu.js');
            await sock.sendMessage(from, {
                text: menus.obterMenuBrincadeira()
            }, { quoted: message });
        }
        break;

        case "menuhentai": {
            const menus = require('./menus/menu.js');
            await sock.sendMessage(from, {
                text: menus.obterMenuHentai()
            }, { quoted: message });
        }
        break;

        case "menudono": {
            const menus = require('./menus/menu.js');
            await sock.sendMessage(from, {
                text: menus.obterMenuDonoAvancado()
            }, { quoted: message });
        }
        break;

        case "menuanti": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuAnti());
        }
        break;

        case "menurpg": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuRPG());
        }
        break;

        case "configurar-bot": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterConfigurarBot());
        }
        break;

        case "trocar-prefixo": {
            const sender = message.key.participant || from;

            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar o prefixo do bot!");
                break;
            }

            const novoPrefixo = args.join(" ").trim();
            if (!novoPrefixo) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-prefixo [novo prefixo]\n\nExemplo: ${config.prefix}trocar-prefixo !`);
                break;
            }

            if (novoPrefixo.length > 3) {
                await reply(sock, from, "‚ùå O prefixo deve ter no m√°ximo 3 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

                const prefixoAntigo = currentSettings.prefix;
                currentSettings.prefix = novoPrefixo;

                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));

                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);

                await reply(sock, from, `‚úÖ *Prefixo alterado com sucesso!*\n\nüîÑ **Antes:** ${prefixoAntigo}\n‚úÖ **Agora:** ${novoPrefixo}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);

            } catch (error) {
                console.error("Erro ao alterar prefixo:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar prefixo. Tente novamente.");
            }
        }
        break;

        case "trocar-nome": {
            const sender = message.key.participant || from;

            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar o nome do bot!");
                break;
            }

            const novoNome = args.join(" ").trim();
            if (!novoNome) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-nome [novo nome]\n\nExemplo: ${config.prefix}trocar-nome MeuBot Incr√≠vel`);
                break;
            }

            if (novoNome.length > 50) {
                await reply(sock, from, "‚ùå O nome deve ter no m√°ximo 50 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

                const nomeAntigo = currentSettings.nomeDoBot;
                currentSettings.nomeDoBot = novoNome;

                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));

                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);

                await reply(sock, from, `‚úÖ *Nome do bot alterado com sucesso!*\n\nüîÑ **Antes:** ${nomeAntigo}\n‚úÖ **Agora:** ${novoNome}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);

            } catch (error) {
                console.error("Erro ao alterar nome do bot:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar nome. Tente novamente.");
            }
        }
        break;

        case "trocar-nick": {
            const sender = message.key.participant || from;

            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar seu pr√≥prio nick!");
                break;
            }

            const novoNick = args.join(" ").trim();
            if (!novoNick) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-nick [novo nick]\n\nExemplo: ${config.prefix}trocar-nick Administrador`);
                break;
            }

            if (novoNick.length > 30) {
                await reply(sock, from, "‚ùå O nick deve ter no m√°ximo 30 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));

                const nickAntigo = currentSettings.nickDoDono;
                currentSettings.nickDoDono = novoNick;

                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));

                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);

                await reply(sock, from, `‚úÖ *Nick do dono alterado com sucesso!*\n\nüîÑ **Antes:** ${nickAntigo}\n‚úÖ **Agora:** ${novoNick}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);

            } catch (error) {
                console.error("Erro ao alterar nick do dono:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar nick. Tente novamente.");
            }
        }
        break;

        // ================== SISTEMA RPG - NEEXTCITY ==================

        case "rpg": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem ativar/desativar o RPG.");
                break;
            }

            const action = args[0]?.toLowerCase();

            if (action === "on") {
                if (rpg.toggleRPG(from, true)) {
                    const configBot = obterConfiguracoes();
                    await reply(sock, from, `üéÆ **RPG ATIVADO!**\n\nüèôÔ∏è **Bem-vindos √† NeextCity!**\n\n Para come√ßar sua jornada:\n‚Ä¢ Digite **${configBot.prefix}registrar** para se registrar\n‚Ä¢ Escolha seu banco favorito\n‚Ä¢ Comece a pescar, minerar e trabalhar!\n\n‚ú® **Comandos dispon√≠veis:**\n‚Ä¢ \`${configBot.prefix}pescar\` - Pesque e ganhe gold\n‚Ä¢ \`${configBot.prefix}minerar\` - Minere recursos valiosos\n‚Ä¢ \`${configBot.prefix}trabalhar\` - Trabalhe por dinheiro\n‚Ä¢ \`${configBot.prefix}tigrinho\` - Jogue no cassino\n‚Ä¢ \`${configBot.prefix}assalto\` - Assalte outros jogadores\n‚Ä¢ \`${configBot.prefix}vermeusaldo\` - Veja seu saldo\n‚Ä¢ \`${configBot.prefix}rank\` - Ranking dos mais ricos`);
                } else {
                    await reply(sock, from, "‚ùå Erro ao ativar o RPG.");
                }
            } else if (action === "off") {
                if (rpg.toggleRPG(from, false)) {
                    await reply(sock, from, "üéÆ **RPG DESATIVADO!**\n\nüëã At√© logo, NeextCity!");
                } else {
                    await reply(sock, from, "‚ùå Erro ao desativar o RPG.");
                }
            } else {
                const isAtivo = rpg.isRPGAtivo(from);
                const configBot = obterConfiguracoes();
                await reply(sock, from, `üéÆ **STATUS DO RPG**\n\n${isAtivo ? "‚úÖ ATIVO" : "‚ùå INATIVO"}\n\nüí° **Uso:** \`${configBot.prefix}rpg on/off\``);
            }
        }
        break;

        case "registrar": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            // Verifica se RPG est√° ativo
            if (!rpg.isRPGAtivo(from)) {
                const configBot = obterConfiguracoes();
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo. Um admin deve ativar com `" + configBot.prefix + "rpg on`");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            // Verifica se j√° est√° registrado
            if (rpg.isUsuarioRegistrado(userId)) {
                const userData = rpg.obterDadosUsuario(userId);
                await reply(sock, from, `‚úÖ **Voc√™ j√° est√° registrado na NeextCity!**\n\nüë§ **Nome:** ${userData.nome}\n${userData.banco.emoji} **Banco:** ${userData.banco.nome}\nüí∞ **Saldo:** ${userData.saldo} Gold`);
                break;
            }

            // Se n√£o tem argumentos, mostra como usar
            if (args.length < 2) {
                let bancosText = "üè¶ **BANCOS DISPON√çVEIS:**\n\n";
                rpg.bancos.forEach((banco, index) => {
                    bancosText += `${index + 1}. ${banco.emoji} ${banco.nome}\n`;
                });

                const configBot = obterConfiguracoes();
                await reply(sock, from, `üèôÔ∏è **REGISTRO NA NEEXTCITY**\n\n${bancosText}\nüí° **Como usar:**\n\`${configBot.prefix}registrar [nome] [n√∫mero_do_banco]\`\n\nüìù **Exemplo:**\n\`${configBot.prefix}registrar Jo√£o 3\` (para Nubank)`);
                break;
            }

            const nome = args[0];
            const bancoIndex = parseInt(args[1]) - 1;

            if (!nome || nome.length < 2) {
                await reply(sock, from, "‚ùå Nome deve ter pelo menos 2 caracteres.");
                break;
            }

            if (isNaN(bancoIndex) || bancoIndex < 0 || bancoIndex >= rpg.bancos.length) {
                await reply(sock, from, `‚ùå N√∫mero do banco inv√°lido. Escolha entre 1 e ${rpg.bancos.length}.`);
                break;
            }

            const banco = rpg.bancos[bancoIndex];

            if (rpg.registrarUsuario(userId, nome, banco.id)) {
                await reply(sock, from, `üéâ **REGISTRO CONCLU√çDO!**\n\nüèôÔ∏è **Bem-vindo √† NeextCity!**\n\nüë§ **Nome:** ${nome}\n${banco.emoji} **Banco:** ${banco.nome}\nüí∞ **Saldo inicial:** 100 Gold\n\n‚ú® **Agora voc√™ pode:**\n‚Ä¢ /pescar - Ganhe gold pescando\n‚Ä¢ /minerar - Encontre minerais valiosos\n‚Ä¢ /trabalhar - Trabalhe por dinheiro\n‚Ä¢ /tigrinho - Teste sua sorte no cassino\n‚Ä¢ /assalto - Assalte outros jogadores\n‚Ä¢ /vermeusaldo - Veja seu progresso`);
            } else {
                await reply(sock, from, "‚ùå Erro ao registrar. Tente novamente.");
            }
        }
        break;

        case "pescar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.pescar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            // Envia resultado sem imagem
            await reply(sock, from, resultado.mensagem);

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üé£");
            } else {
                await reagirMensagem(sock, message, "üíî");
            }
        }
        break;

        case "minerar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.minerar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            // Envia resultado sem imagem
            await reply(sock, from, resultado.mensagem);

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "‚õèÔ∏è");
            } else {
                await reagirMensagem(sock, message, "üíî");
            }
        }
        break;

        case "trabalhar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.trabalhar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üíº");
        }
        break;

        case "tigrinho": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const aposta = parseInt(args[0]);
            if (!aposta || isNaN(aposta)) {
                await reply(sock, from, `üé∞ **JOGO DO TIGRINHO** üêÖ\n\nüí° **Como jogar:**\n\`${config.prefix}tigrinho [valor]\`\n\nüìù **Exemplo:**\n\`${config.prefix}tigrinho 50\`\n\nüé≤ **Regras:**\n‚Ä¢ Aposta m√≠nima: 10 Gold\n‚Ä¢ 3 iguais = Pr√™mio maior\n‚Ä¢ 2 iguais = Pr√™mio menor\n‚Ä¢ üíéüíéüíé = JACKPOT! (10x)\n‚Ä¢ üêÖüêÖüêÖ = Tigrinho! (5x)`);
                break;
            }

            const resultado = rpg.jogarTigrinho(userId, aposta);

            if (resultado.erro) {
                await reply(sock, from, `‚ùå ${resultado.erro}`);
                break;
            }

            await reply(sock, from, resultado.mensagem);

            if (resultado.ganhou) {
                await reagirMensagem(sock, message, "üéâ");
            } else {
                await reagirMensagem(sock, message, "üò¢");
            }
        }
        break;

        case "assalto": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            // Verifica se marcou algu√©m
            const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            if (!mentionedJid || mentionedJid.length === 0) {
                await reply(sock, from, `üî´ **SISTEMA DE ASSALTO**\n\nüí° **Como usar:**\nMarque a pessoa que deseja assaltar\n\nüìù **Exemplo:**\n\`${config.prefix}assalto @usuario\`\n\n‚ö†Ô∏è **Regras:**\n‚Ä¢ Cooldown: 15 minutos\n‚Ä¢ Chance de sucesso: 60%\n‚Ä¢ Voc√™ rouba 20% do saldo da v√≠tima\n‚Ä¢ Se falhar, paga multa de 30 Gold`);
                break;
            }

            const targetId = mentionedJid[0].split('@')[0];
            const resultado = rpg.assaltar(userId, targetId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem, mentionedJid);

            if (resultado.assalto) {
                await reagirMensagem(sock, message, "üí∞");
            } else {
                await reagirMensagem(sock, message, "üö®");
            }
        }
        break;

        case "estudar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            if (args.length > 0) {
                // Iniciar curso espec√≠fico
                const cursoNum = parseInt(args[0]);
                const resultado = rpg.iniciarCurso(userId, cursoNum);
                
                if (resultado.erro) {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                    break;
                }

                await reply(sock, from, resultado.mensagem);
                if (resultado.sucesso) {
                    await reagirMensagem(sock, message, "üìö");
                }
            } else {
                // Mostra lista de cursos ou verifica se terminou algum
                const resultado = rpg.estudar(userId);

                if (resultado.erro) {
                    if (resultado.erro === 'Cooldown') {
                        await reply(sock, from, resultado.mensagem);
                    } else {
                        await reply(sock, from, `‚ùå ${resultado.erro}`);
                    }
                    break;
                }

                await reply(sock, from, resultado.mensagem);
                
                if (resultado.sucesso && resultado.cursoCompleto) {
                    await reagirMensagem(sock, message, "üéì");
                } else if (resultado.listaCursos) {
                    await reagirMensagem(sock, message, "üìö");
                }
            }
        }
        break;

        case "investir": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const tipoInvestimento = args[0] ? parseInt(args[0]) : null;
            const valor = args[1] ? parseInt(args[1]) : null;
            
            const resultado = rpg.investir(userId, tipoInvestimento, valor);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso !== undefined) {
                await reagirMensagem(sock, message, resultado.sucesso ? "üìà" : "üìâ");
            } else {
                await reagirMensagem(sock, message, "üíº");
            }
        }
        break;

        case "apostar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const valor = args[0] ? parseInt(args[0]) : null;
            
            const resultado = rpg.apostar(userId, valor);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso !== undefined) {
                await reagirMensagem(sock, message, resultado.sucesso ? "üé≤" : "üíî");
            } else {
                await reagirMensagem(sock, message, "üéØ");
            }
        }
        break;

        // ==================== NOVOS COMANDOS RPG ====================

        case "loja": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const categoria = args[0]?.toLowerCase();
            const categoriasValidas = ['propriedades', 'animais', 'ferramentas', 'veiculos', 'negocios', 'tecnologia', 'decoracao', 'seguranca'];
            
            if (categoria && !categoriasValidas.includes(categoria)) {
                await reply(sock, from, "‚ùå Categoria inv√°lida! Use: propriedades, animais, ferramentas, veiculos, negocios, tecnologia, decoracao, seguranca");
                break;
            }

            const resultado = rpg.listarLoja(categoria);
            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üõí");
        }
        break;

        case "negocios": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.listarLoja("negocios");
            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üè¢");
        }
        break;

        case "comprar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            if (!args[0]) {
                const config = obterConfiguracoes();
                await reply(sock, from, `üõí **COMO COMPRAR**\n\nUse: \`${config.prefix}comprar [item_id] [quantidade]\`\n\nüí° **Exemplo:**\n\`${config.prefix}comprar casa_simples 1\`\n\nüìã **Para ver itens:** \`${config.prefix}loja\``);
                break;
            }

            const itemId = args[0];
            const quantidade = args[1] ? parseInt(args[1]) : 1;

            if (!Number.isInteger(quantidade) || quantidade < 1 || quantidade > 10) {
                await reply(sock, from, "‚ùå Quantidade deve ser um n√∫mero inteiro entre 1 e 10!");
                break;
            }

            const resultado = await rpg.comprarItem(userId, itemId, quantidade);

            if (resultado.erro) {
                await reply(sock, from, `‚ùå ${resultado.erro}`);
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "‚úÖ");
        }
        break;

        case "inventario":
        case "meuinventario":
        case "mochila": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.obterPerfilCompleto(userId);

            if (!resultado) {
                await reply(sock, from, "‚ùå Erro ao carregar invent√°rio.");
                break;
            }

            let mensagem = `üì¶ **INVENT√ÅRIO DE ${resultado.usuario.nome.toUpperCase()}**\n\n`;
            mensagem += `üí∞ **Saldo:** ${resultado.usuario.saldo} Gold\n`;
            mensagem += `üíé **Valor do invent√°rio:** ${resultado.valorInventario} Gold\n`;
            mensagem += `üìã **Total de itens:** ${resultado.totalItens}\n\n`;
            mensagem += resultado.inventarioTexto;
            
            await reply(sock, from, mensagem);
            await reagirMensagem(sock, message, "üì¶");
        }
        break;

        case "cacar":
        case "cacada": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.cacar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üèπ");
            } else {
                await reagirMensagem(sock, message, "üòû");
            }
        }
        break;

        case "coletar":
        case "coleta": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.coletar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üå±");
            } else {
                await reagirMensagem(sock, message, "üòû");
            }
        }
        break;

        case "agricultura":
        case "plantar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.agricultura(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üöú");
            } else {
                await reagirMensagem(sock, message, "ü¶ó");
            }
        }
        break;

        case "entrega":
        case "delivery": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.entrega(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üõµ");
            } else {
                await reagirMensagem(sock, message, "‚ùå");
            }
        }
        break;

        case "pix": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            // Verifica se foi marcado algu√©m
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            if (!mentioned || mentioned.length === 0) {
                const config = obterConfiguracoes();
                await reply(sock, from, `üí∏ **SISTEMA PIX - NEEXTCITY**\n\nüì± Para transferir Gold, use:\n\`${config.prefix}pix @usuario [valor]\`\n\nüí° **Exemplo:** \`${config.prefix}pix @5511999999999 1000\`\n\n‚ö†Ô∏è **Taxa:** 2% sobre o valor transferido\nüí∞ **Valor m√≠nimo:** 10 Gold`);
                break;
            }

            const destinatarioJid = mentioned[0];
            const destinatarioId = destinatarioJid.split('@')[0];
            const valor = args[1] ? parseInt(args[1]) : null;

            if (!valor || isNaN(valor)) {
                await reply(sock, from, "‚ùå Digite um valor v√°lido para transferir.");
                break;
            }

            // N√£o permite transferir para si mesmo
            if (userId === destinatarioId) {
                await reply(sock, from, "‚ùå Voc√™ n√£o pode transferir PIX para si mesmo!");
                break;
            }

            // Obt√©m nomes dos usu√°rios
            const remetente = rpg.obterDadosUsuario(userId);
            const destinatario = rpg.obterDadosUsuario(destinatarioId);

            if (!destinatario) {
                await reply(sock, from, "‚ùå O destinat√°rio n√£o est√° registrado no RPG.");
                break;
            }

            const resultado = rpg.pixTransferir(userId, destinatarioId, valor, remetente.nome, destinatario.nome);

            if (resultado.erro) {
                await reply(sock, from, `‚ùå ${resultado.erro}`);
                break;
            }

            // Envia confirma√ß√£o
            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/XsRtKgD/pix-transferencia.jpg" },
                caption: resultado.mensagem,
                contextInfo: {
                    mentionedJid: [sender, destinatarioJid],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "üí∏ PIX Realizado - NeextCity",
                        body: "¬© NEEXT LTDA",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    }
                }
            }, { quoted: message });

            await reagirMensagem(sock, message, "üí∏");
        }
        break;

        case "perfil": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const perfilCompleto = rpg.obterPerfilCompleto(userId);
            if (!perfilCompleto) {
                await reply(sock, from, "‚ùå Erro ao carregar perfil.");
                break;
            }

            const usuario = perfilCompleto.usuario;
            const registroData = new Date(usuario.registrado).toLocaleDateString('pt-BR');

            let mensagemPerfil = `üë§ **PERFIL COMPLETO - ${usuario.nome.toUpperCase()}**\n\n`;
            mensagemPerfil += `üí∞ **Saldo:** ${usuario.saldo} Gold\n`;
            mensagemPerfil += `${usuario.banco.emoji} **Banco:** ${usuario.banco.nome}\n`;
            mensagemPerfil += `üìÖ **Registro:** ${registroData}\n`;
            
            // Educa√ß√£o
            if (usuario.educacao && usuario.educacao.nivel > 0) {
                mensagemPerfil += `üéì **N√≠vel educacional:** ${usuario.educacao.nivel}\n`;
            }
            
            mensagemPerfil += `\nüìä **ESTAT√çSTICAS:**\n`;
            mensagemPerfil += `üé£ Pescas: ${usuario.pescasFeitas || 0}\n`;
            mensagemPerfil += `üíº Trabalhos: ${usuario.trabalhosFeitos || 0}\n`;
            mensagemPerfil += `‚õèÔ∏è Minera√ß√µes: ${usuario.mineracoesFeitas || 0}\n`;
            
            if (usuario.estudosFeitos > 0) {
                mensagemPerfil += `üìö Estudos: ${usuario.estudosFeitos}\n`;
            }
            if (usuario.investimentosFeitos > 0) {
                mensagemPerfil += `üíº Investimentos: ${usuario.investimentosFeitos}\n`;
            }
            if (usuario.apostasFeitas > 0) {
                mensagemPerfil += `üé≤ Apostas: ${usuario.apostasFeitas}\n`;
            }
            
            mensagemPerfil += `\nüíé **PATRIM√îNIO:**\n`;
            mensagemPerfil += `üì¶ **Total de itens:** ${perfilCompleto.totalItens}\n`;
            mensagemPerfil += `üí∞ **Valor do invent√°rio:** ${perfilCompleto.valorInventario} Gold\n`;
            mensagemPerfil += `üèÜ **Patrim√¥nio total:** ${usuario.saldo + perfilCompleto.valorInventario} Gold\n\n`;
            
            mensagemPerfil += `üì¶ **INVENT√ÅRIO:**\n\n`;
            mensagemPerfil += perfilCompleto.inventarioTexto;

            await reply(sock, from, mensagemPerfil);
            await reagirMensagem(sock, message, "üë§");
        }
        break;

        // ==================== NOVOS COMANDOS RPG EXPANDIDOS ====================

        case "roubar":
        case "roubo": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const localId = args[0] ? parseInt(args[0]) : null;
            const resultado = await rpg.roubar(userId, localId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown' || resultado.erro === 'Limite di√°rio') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            if (resultado.listaLocais) {
                await reply(sock, from, resultado.mensagem);
                await reagirMensagem(sock, message, "üè¥‚Äç‚ò†Ô∏è");
            } else {
                await reply(sock, from, resultado.mensagem);
                
                if (resultado.sucesso) {
                    await reagirMensagem(sock, message, "üí∞");
                } else if (resultado.prisao) {
                    await reagirMensagem(sock, message, "üö®");
                } else {
                    await reagirMensagem(sock, message, "üòû");
                }
            }
        }
        break;

        case "youtube":
        case "yt": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.criarConteudo(userId, 'youtube');

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üé•");
        }
        break;

        case "tiktok":
        case "tt": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.criarConteudo(userId, 'tiktok');

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üì±");
        }
        break;

        case "twitch":
        case "stream": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = await rpg.criarConteudo(userId, 'twitch');

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üéÆ");
        }
        break;

        case "coletar":
        case "coleta": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.coletar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üå±");
            } else {
                await reagirMensagem(sock, message, "üòû");
            }
        }
        break;

        case "entrega":
        case "delivery": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const resultado = rpg.entrega(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üõµ");
            } else {
                await reagirMensagem(sock, message, "‚ùå");
            }
        }
        break;

        case "vermeusaldo":
        case "saldo": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + config.prefix + "registrar`");
                break;
            }

            const userData = rpg.obterDadosUsuario(userId);
            const dataRegistro = new Date(userData.registrado).toLocaleDateString('pt-BR');

            const extrato = `üèôÔ∏è **EXTRATO NEEXTCITY**\n\n` +
                          `üë§ **Nome:** ${userData.nome}\n` +
                          `${userData.banco.emoji} **Banco:** ${userData.banco.nome}\n` +
                          `üí∞ **Saldo:** ${userData.saldo} Gold\n` +
                          `üìÖ **Registrado em:** ${dataRegistro}\n\n` +
                          `üìä **ESTAT√çSTICAS**\n\n` +
                          `üé£ **Pescas:** ${userData.pescasFeitas}\n` +
                          `‚õèÔ∏è **Minera√ß√µes:** ${userData.mineracoesFeitas}\n` +
                          `üíº **Trabalhos:** ${userData.trabalhosFeitos}\n` +
                          `üî´ **Assaltos:** ${userData.assaltosFeitos}\n\n` +
                          `¬© NEEXT LTDA - NeextCity`;

            await reply(sock, from, extrato);
            await reagirMensagem(sock, message, "üè¶");
        }
        break;

        case "rank":
        case "ranking": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const ranking = rpg.obterRanking();
            await reply(sock, from, ranking.mensagem);
            await reagirMensagem(sock, message, "üèÜ");
        }
        break;

        // ================== FIM DO SISTEMA RPG ==================

        // ================== COMANDOS ADMINISTRATIVOS ==================

        case "fechargrupo":
        case "fechar": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para fechar o grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'announcement');
                await reagirMensagem(sock, message, "üîí");
                await reply(sock, from, "üîí *GRUPO FECHADO!*\n\nApenas admins podem enviar mensagens agora.");
                console.log(`üîí Grupo ${from} foi fechado por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao fechar grupo:", err);
                await reply(sock, from, "‚ùå Erro ao fechar o grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "abrirgrupo":
        case "abrir": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para abrir o grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'not_announcement');
                await reagirMensagem(sock, message, "üîì");
                await reply(sock, from, "üîì *GRUPO ABERTO!*\n\nTodos os membros podem enviar mensagens agora.");
                console.log(`üîì Grupo ${from} foi aberto por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao abrir grupo:", err);
                await reply(sock, from, "‚ùå Erro ao abrir o grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "delmsg":
        case "del":
        case "delete": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para deletar mensagens.");
                break;
            }

            // Verifica se h√° mensagem marcada
            const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;
            if (!quotedMsg) {
                await reply(sock, from, "‚ùå Marque uma mensagem para deletar!");
                break;
            }

            try {
                const quotedKey = message.message.extendedTextMessage.contextInfo.stanzaId;
                const quotedParticipant = message.message.extendedTextMessage.contextInfo.participant;

                const messageKey = {
                    remoteJid: from,
                    fromMe: false,
                    id: quotedKey,
                    participant: quotedParticipant
                };

                await sock.sendMessage(from, { delete: messageKey });
                await reagirMensagem(sock, message, "üóëÔ∏è");
                console.log(`üóëÔ∏è Mensagem deletada por admin ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao deletar mensagem:", err);
                await reply(sock, from, "‚ùå Erro ao deletar mensagem. A mensagem pode ser muito antiga ou j√° ter sido deletada.");
            }
        }
        break;

        case "resetlink":
        case "resetarlink":
        case "novolink": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para resetar o link do grupo.");
                break;
            }

            try {
                const newLink = await sock.groupRevokeInvite(from);
                await reagirMensagem(sock, message, "üîó");
                await reply(sock, from, `üîó *LINK DO GRUPO RESETADO!*\n\n‚úÖ Novo link: https://chat.whatsapp.com/${newLink}\n\n‚ö†Ô∏è O link anterior foi invalidado!`);
                console.log(`üîó Link do grupo ${from} foi resetado por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao resetar link:", err);
                await reply(sock, from, "‚ùå Erro ao resetar o link do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "ativarsolicitacao":
        case "ativarjoin":
        case "reqon": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupToggleEphemeral(from, false);
                await sock.groupSettingUpdate(from, 'locked');
                await reagirMensagem(sock, message, "‚úÖ");
                await reply(sock, from, "‚úÖ *SOLICITA√á√ÉO DE ENTRADA ATIVADA!*\n\nNovos membros precisar√£o da aprova√ß√£o dos admins para entrar.");
                console.log(`‚úÖ Solicita√ß√£o de entrada ativada no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao ativar solicita√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao ativar solicita√ß√£o de entrada. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "desativarsolicitacao":
        case "desativarjoin":
        case "reqoff": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'unlocked');
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå *SOLICITA√á√ÉO DE ENTRADA DESATIVADA!*\n\nQualquer pessoa com o link pode entrar no grupo agora.");
                console.log(`‚ùå Solicita√ß√£o de entrada desativada no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao desativar solicita√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao desativar solicita√ß√£o de entrada. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "soloadmin":
        case "adminonly": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'locked');
                await reagirMensagem(sock, message, "üîí");
                await reply(sock, from, "üîí *EDI√á√ÉO RESTRITA!*\n\nApenas admins podem editar as informa√ß√µes do grupo (nome, descri√ß√£o, foto).");
                console.log(`üîí Edi√ß√£o restrita a admins no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao restringir edi√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao restringir edi√ß√£o do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "mudargrupo":
        case "mudarnome":
        case "renamegroup": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para mudar o nome do grupo.");
                break;
            }

            const novoNome = args.join(" ").trim();
            if (!novoNome) {
                await reply(sock, from, `‚ùå Use: ${config.prefix}mudargrupo <novo nome>\n\nExemplo: ${config.prefix}mudargrupo NEEXT LTDA - Grupo Oficial`);
                break;
            }

            if (novoNome.length > 25) {
                await reply(sock, from, "‚ùå O nome do grupo deve ter no m√°ximo 25 caracteres!");
                break;
            }

            try {
                await sock.groupUpdateSubject(from, novoNome);
                await reagirMensagem(sock, message, "‚úèÔ∏è");
                await reply(sock, from, `‚úèÔ∏è *NOME DO GRUPO ALTERADO!*\n\nüìù Novo nome: "${novoNome}"\nüë§ Alterado por: @${sender.split('@')[0]}`, [sender]);
                console.log(`‚úèÔ∏è Nome do grupo ${from} alterado para "${novoNome}" por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao alterar nome do grupo:", err);
                await reply(sock, from, "‚ùå Erro ao alterar o nome do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "fotodobot": {
            const sender = message.key.participant || from;
            const ehDono = isDono(sender);

            if (!ehDono) {
                await reply(sock, from, "‚ùå Apenas o dono pode trocar a foto do bot.");
                break;
            }

            // Verifica se h√° imagem anexada ou marcada
            let mediaData = null;
            if (message.message.imageMessage) {
                mediaData = message.message.imageMessage;
            } else if (quoted?.imageMessage) {
                mediaData = quoted.imageMessage;
            }

            if (!mediaData) {
                await reply(sock, from, "‚ùå Envie ou marque uma imagem para usar como foto do bot!");
                break;
            }

            try {
                await reagirMensagem(sock, message, "‚è≥");

                // Baixa a imagem
                const buffer = await downloadContentFromMessage(mediaData, 'image');
                let imageBuffer = Buffer.from([]);
                for await (const chunk of buffer) {
                    imageBuffer = Buffer.concat([imageBuffer, chunk]);
                }

                // Atualiza a foto do perfil do bot
                await sock.updateProfilePicture(sock.user.id, imageBuffer);

                await reagirMensagem(sock, message, "‚úÖ");
                await reply(sock, from, "‚úÖ *FOTO DO BOT ALTERADA!*\n\nA foto de perfil do bot foi atualizada com sucesso!");
                console.log(`üì∏ Foto do bot alterada por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao alterar foto do bot:", err);
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå Erro ao alterar a foto do bot. Tente novamente.");
            }
        }
        break;

        case "fotodogrupo": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar a foto do grupo.");
                break;
            }

            // Verifica se h√° imagem anexada ou marcada
            let mediaData = null;
            if (message.message.imageMessage) {
                mediaData = message.message.imageMessage;
            } else if (quoted?.imageMessage) {
                mediaData = quoted.imageMessage;
            }

            if (!mediaData) {
                await reply(sock, from, "‚ùå Envie ou marque uma imagem para usar como foto do grupo!");
                break;
            }

            try {
                await reagirMensagem(sock, message, "‚è≥");

                // Baixa a imagem
                const buffer = await downloadContentFromMessage(mediaData, 'image');
                let imageBuffer = Buffer.from([]);
                for await (const chunk of buffer) {
                    imageBuffer = Buffer.concat([imageBuffer, chunk]);
                }

                // Atualiza a foto do grupo
                await sock.updateProfilePicture(from, imageBuffer);

                await reagirMensagem(sock, message, "üì∏");
                await reply(sock, from, "üì∏ *FOTO DO GRUPO ALTERADA!*\n\nA foto do grupo foi atualizada com sucesso!");
                console.log(`üì∏ Foto do grupo ${from} alterada por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao alterar foto do grupo:", err);
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå Erro ao alterar a foto do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        // ================== FIM DOS COMANDOS ADMINISTRATIVOS ==================

        // ================== COMANDOS DE MODO GAMER ==================

        case "modogamer": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;

            // Verifica se √© admin
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas administradores podem usar este comando!", [sender]);
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const action = args[0]?.toLowerCase();

            if (action === "on" || action === "ativar") {
                if (config.modogamer) {
                    await reply(sock, from, "‚ö†Ô∏è Modo Gamer j√° est√° ativo neste grupo!");
                    break;
                }

                config.modogamer = true;
                const salvou = antiSpam.salvarConfigGrupo(from, config);

                if (salvou) {
                    await reagirMensagem(sock, message, "üéÆ");
                    await reply(sock, from,
                        `üéÆ *MODO GAMER ATIVADO!*\n\n` +
                        `‚úÖ Modo gamer foi ativado no grupo!\n` +
                        `üéØ Agora os membros podem usar jogos e comandos de divers√£o\n\n` +
                        `üé≤ **Jogos dispon√≠veis:**\n` +
                        `‚Ä¢ ${config.prefix}eununca - Enquetes divertidas\n` +
                        `‚Ä¢ ${config.prefix}jogodaforca - Jogo da forca\n` +
                        `‚Ä¢ ${config.prefix}jogodavelha - Jogo da velha\n` +
                        `‚Ä¢ ${config.prefix}roletarussa - Roleta russa\n\n` +
                        `üé™ **Comandos de divers√£o:**\n` +
                        `‚Ä¢ Rankings e intera√ß√µes dispon√≠veis\n` +
                        `‚Ä¢ Digite ${config.prefix}help para ver todos os comandos\n\n` +
                        `üë§ Ativado por: @${sender.split('@')[0]}`,
                        [sender]
                    );
                } else {
                    await reply(sock, from, "‚ùå Erro ao salvar configura√ß√£o. Tente novamente.");
                }
            } else if (action === "off" || action === "desativar") {
                if (!config.modogamer) {
                    await reply(sock, from, "‚ö†Ô∏è Modo Gamer j√° est√° desativado neste grupo!");
                    break;
                }

                config.modogamer = false;
                const salvou = antiSpam.salvarConfigGrupo(from, config);

                if (salvou) {
                    await reagirMensagem(sock, message, "üö´");
                    await reply(sock, from,
                        `üö´ *MODO GAMER DESATIVADO!*\n\n` +
                        `‚ùå Modo gamer foi desativado no grupo\n` +
                        `üîí Jogos e comandos de divers√£o n√£o funcionar√£o mais\n\n` +
                        `üë§ Desativado por: @${sender.split('@')[0]}`,
                        [sender]
                    );
                } else {
                    await reply(sock, from, "‚ùå Erro ao salvar configura√ß√£o. Tente novamente.");
                }
            } else {
                const status = config.modogamer ? "‚úÖ ATIVO" : "‚ùå DESATIVO";
                await reply(sock, from,
                    `üéÆ *STATUS DO MODO GAMER*\n\n` +
                    `${status}\n\n` +
                    `üìù **Uso:**\n` +
                    `‚Ä¢ ${config.prefix}modogamer on - Ativar\n` +
                    `‚Ä¢ ${config.prefix}modogamer off - Desativar\n\n` +
                    `‚ö†Ô∏è Apenas administradores podem alterar`
                );
            }
        }
        break;

        case "eununca": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const perguntas = [
                "j√° mandou nude",
                "j√° ficou com algu√©m do grupo",
                "j√° mentiu sobre a idade",
                "j√° fingiu estar doente para faltar",
                "j√° roubou algo",
                "j√° traiu algu√©m",
                "j√° foi tra√≠do",
                "j√° chorou assistindo filme",
                "j√° cantou no banho",
                "j√° dan√ßou sozinho no quarto",
                "j√° falou sozinho",
                "j√° dormiu em aula",
                "j√° colou em prova",
                "j√° esqueceu o nome de algu√©m na hora de apresentar",
                "j√° passou vergonha em p√∫blico",
                "j√° mandou mensagem para pessoa errada",
                "j√° stalkeou ex nas redes sociais",
                "j√° fingiu que estava bem quando estava mal",
                "j√° comeu comida do ch√£o",
                "j√° usou roupa por mais de 2 dias seguidos"
            ];

            const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];

            await sock.sendMessage(from, {
                poll: {
                    name: `ü§î Eu nunca... ${perguntaAleatoria}`,
                    values: ["üî• EU J√Å", "üòá EU NUNCA"],
                    selectableCount: 1
                }
            });
        }
        break;

        case "tapa": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para dar um tapa!\n\nExemplo: ${config.prefix}tapa @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/BK46Ssyy/21456a10884584ac06ed60363395b8db.jpg" },
                caption: `üëã *TAPA GOSTOSO!*\n\n@${sender.split('@')[0]} deu um tapa gostoso em @${target.split('@')[0]}! üí•\n\nüòè Ai que del√≠cia!`,
                mentions: [sender, target]
            });
        }
        break;

        case "rankcorno": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                // Embaralha e pega porcentagens aleat√≥rias
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ü§°`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/jvxHn5jf/23afed681d95265b23cfc9f32b3c6a35.jpg" },
                    caption: `ü§° *RANKING DOS CORNOS*\n\n${ranking}\n\nüòà Os chifrudos do grupo! ü¶å`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        // Fun√ß√£o simples para envio de GIFs usando m√©todo padr√£o do Baileys
async function enviarGif(sock, from, gifUrl, caption, mentions = [], quoted = null) {
    try {
        console.log(`üé¨ Enviando GIF: ${gifUrl}`);

        // Baixa o GIF
        const response = await axios({
            method: 'GET',
            url: gifUrl,
            responseType: 'arraybuffer',
            timeout: 10000
        });

        const gifBuffer = Buffer.from(response.data);
        console.log(`üì• GIF baixado: ${gifBuffer.length} bytes`);

        // Envia como v√≠deo com gifPlayback (m√©todo padr√£o Baileys)
        await sock.sendMessage(from, {
            video: gifBuffer,
            gifPlayback: true,
            caption: caption,
            mentions: mentions
        }, quoted ? { quoted } : {});

        console.log("‚úÖ GIF enviado como v√≠deo");
        return true;

    } catch (error) {
        console.log("‚ùå Erro ao enviar GIF:", error.message);
        return false;
    }
}

        case "matar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para matar!\n\nExemplo: ${botConfig.prefix}matar @usuario`);
                break;
            }

            const target = mentioned[0];

            // Envia GIF usando m√©todo simples
            const gifEnviado = await enviarGif(
                sock,
                from,
                "https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif",
                `üíÄ *ASSASSINATO!*\n\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! ‚ö∞Ô∏è\n\nü©∏ RIP... F no chat`,
                [sender, target],
                message
            );

            if (!gifEnviado) {
                // Fallback para texto se o GIF falhar
                await reply(sock, from, `üíÄ *ASSASSINATO!*\n\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! ‚ö∞Ô∏è\n\nü©∏ RIP... F no chat`, [sender, target]);
            }
        }
        break;

        case "atirar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para atirar!\n\nExemplo: ${botConfig.prefix}atirar @usuario`);
                break;
            }

            const target = mentioned[0];

            // Envia GIF usando m√©todo simples
            const gifEnviado = await enviarGif(
                sock,
                from,
                "https://i.ibb.co/KpVxK1PB/9ab46702d1f0669a0ae40464b25568f2.gif",
                `üî´ *TIRO CERTEIRO!*\n\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! üí•\n\nüéØ Pegou em cheio!`,
                [sender, target],
                message
            );

            if (!gifEnviado) {
                // Fallback para texto se o GIF falhar
                await reply(sock, from, `üî´ *TIRO CERTEIRO!*\n\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! üí•\n\nüéØ Pegou em cheio!`, [sender, target]);
            }
        }
        break;

        case "rankcasal": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                if (participants.length < 2) {
                    await reply(sock, from, "‚ùå Precisa ter pelo menos 2 pessoas no grupo!");
                    break;
                }

                // Escolhe duas pessoas aleat√≥rias
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                const pessoa1 = shuffled[0];
                const pessoa2 = shuffled[1];
                const compatibility = Math.floor(Math.random() * 100) + 1;
                const love1 = Math.floor(Math.random() * 100) + 1;
                const love2 = Math.floor(Math.random() * 100) + 1;

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/1G69wkJD/d32b5cfe067aa82bf2a5356c39499539.jpg" },
                    caption: `üíï *RANK CASAL*\n\n` +
                        `üë´ Casal formado:\n` +
                        `üíù @${pessoa1.split('@')[0]} ‚ù§Ô∏è @${pessoa2.split('@')[0]}\n\n` +
                        `üìä Compatibilidade: ${compatibility}%\n` +
                        `üíñ @${pessoa1.split('@')[0]} gosta ${love1}% de @${pessoa2.split('@')[0]}\n` +
                        `üíò @${pessoa2.split('@')[0]} gosta ${love2}% de @${pessoa1.split('@')[0]}\n\n` +
                        `${compatibility > 80 ? 'üî• Casal perfeito!' : compatibility > 60 ? 'üòç Muito amor!' : compatibility > 40 ? 'üòä Pode dar certo!' : 'üíî Melhor s√≥ amigos!'}`,
                    mentions: [pessoa1, pessoa2]
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking de casal.");
            }
        }
        break;

        case "prender": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para prender!\n\nExemplo: ${config.prefix}prender @usuario`);
                break;
            }

            const crimes = [
                "roubo de cora√ß√£o", "excesso de beleza", "ser muito gostoso(a)", "causar suspiros",
                "roubar olhares", "ser irresist√≠vel", "crime de sedu√ß√£o", "atentado ao pudor",
                "porte ilegal de charme", "forma√ß√£o de quadrilha do amor", "assalto ao cora√ß√£o",
                "tr√°fico de sorrisos", "porte de sorriso fatal", "estelionato sentimental"
            ];

            const target = mentioned[0];
            const crime = crimes[Math.floor(Math.random() * crimes.length)];

            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/XfrfGk3n/bfde95077068d135cbcf9e039147b2c0.jpg" },
                caption: `üöî *PRIS√ÉO!*\n\n@${target.split('@')[0]} foi preso(a) por @${sender.split('@')[0]}!\n\n‚õìÔ∏è Crime: ${crime}\nüîí Fian√ßa: 10 beijinhos!`,
                mentions: [sender, target]
            });
        }
        break;

        case "beijar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para beijar!\n\nExemplo: ${botConfig.prefix}beijar @usuario`);
                break;
            }

            const target = mentioned[0];

            // Envia texto diretamente com emojis, mais confi√°vel
            await reply(sock, from, `üíã *BEIJINHO!*\n\n@${sender.split('@')[0]} deu um beijinho em @${target.split('@')[0]}! üòò\n\nüíï Que fofo! üíãüíãüíã`, [sender, target]);
        }
        break;

        case "atropelar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para atropelar!\n\nExemplo: ${botConfig.prefix}atropelar @usuario`);
                break;
            }

            const target = mentioned[0];

            await reply(sock, from, `üöóüí® *ATROPELAMENTO!*\n\n@${target.split('@')[0]} foi atropelado(a) por @${sender.split('@')[0]}! üöë\n\nüòµ‚Äçüí´ Chamem o SAMU! üö®üö®üö®`, [sender, target]);
        }
        break;

        case "dedo": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para fazer dedo!\n\nExemplo: ${botConfig.prefix}dedo @usuario`);
                break;
            }

            const target = mentioned[0];

            await reply(sock, from, `üñï *DEDO!*\n\n@${sender.split('@')[0]} fez dedo para @${target.split('@')[0]}! üò†\n\nü§¨ Vai se lascar! üñïüñïüñï`, [sender, target]);
        }
        break;

        case "sarra": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Modo Gamer est√° desativado neste grupo! Use \`${botConfig.prefix}modogamer on\` para ativar.`);
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const botConfig = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para sarrar!\n\nExemplo: ${botConfig.prefix}sarra @usuario`);
                break;
            }

            const target = mentioned[0];

            await reply(sock, from, `üçë *SARRADA!*\n\n@${sender.split('@')[0]} deu uma sarrada em @${target.split('@')[0]}! üî•\n\nüòà Que safadeza! üî•üî•üî•`, [sender, target]);
        }
        break;

        case "rankgay": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üè≥Ô∏è‚Äçüåà`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/9mzjcW0b/4f5a6af5b0375c87e9a3e63143e231fe.jpg" },
                    caption: `üè≥Ô∏è‚Äçüåà *RANKING GAY*\n\n${ranking}\n\n‚ú® Pride sem julgamentos! üåà`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankburro": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üß†`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/0VV96XgJ/7760232d1a909d291a3231e720bf5ec9.jpg" },
                    caption: `üß† *RANKING DOS BURROS*\n\n${ranking}\n\nü§™ Burrice extrema! üìâ`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "ranklesbica": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üè≥Ô∏è‚Äçüåà`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/jkwgSYYK/0607b00f9464319df28dcbe3b4a965dd.jpg" },
                    caption: `üè≥Ô∏è‚Äçüåà *RANKING L√âSBICA*\n\n${ranking}\n\nüíú Love is love! üåà`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "impostor": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                if (participants.length < 2) {
                    await reply(sock, from, "‚ùå Precisa ter pelo menos 2 pessoas no grupo!");
                    break;
                }

                const impostor = participants[Math.floor(Math.random() * participants.length)];
                const cores = ["Vermelho", "Azul", "Verde", "Rosa", "Laranja", "Amarelo", "Preto", "Branco", "Roxo", "Marrom"];
                const cor = cores[Math.floor(Math.random() * cores.length)];

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/Q7Xb0Pxg/59f4312f9142a3529e1465a636a92ec7.jpg" },
                    caption: `üî¥ *IMPOSTOR DETECTADO!*\n\n@${impostor.split('@')[0]} √© o IMPOSTOR! üö®\n\nüé® Cor: ${cor}\n‚ö†Ô∏è EJETEM ESSA PESSOA!\n\nüöÄ Among Us Vibes!`,
                    mentions: [impostor]
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao escolher impostor.");
            }
        }
        break;

        case "rankmaconheiro": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üåø`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/NdvLNTPN/15026da7ed842481343ded7960a8f8d5.jpg" },
                    caption: `üåø *RANKING DOS MACONHEIROS*\n\n${ranking}\n\nüí® Os chapados! üçÉ`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankbonito": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üòç`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/CKNS2Frr/150f9a8e0becc71f9c20113addb3d433.jpg" },
                    caption: `üòç *RANKING DOS BONITOS*\n\n${ranking}\n\n‚ú® Os gostosos do grupo! üî•`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankemo": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üñ§`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/9mtKb5rC/92e9188040a0728af1a49c61dd0c9279.jpg" },
                    caption: `üñ§ *RANKING DOS EMOS*\n\n${ranking}\n\nüíÄ Os depressivos! üò≠`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankfeio": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üëπ`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/3x06vHm/7760232d1a909d291a3231e720bf5ec9.jpg" },
                    caption: `üëπ *RANKING DOS FEIOS*\n\n${ranking}\n\nü§Æ Os horrorosos! üò±`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "jogodaforca": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const palavras = [
                "JAVASCRIPT", "PROGRAMACAO", "COMPUTADOR", "TELEFONE", "INTERNET",
                "WHATSAPP", "BRASIL", "FUTEBOL", "CHOCOLATE", "PIZZA",
                "MUSICA", "CINEMA", "ESCOLA", "TRABALHO", "FAMILIA",
                "AMIZADE", "VIAGEM", "DINHEIRO", "SAUDE", "FELICIDADE"
            ];

            const palavra = palavras[Math.floor(Math.random() * palavras.length)];
            const palavraOculta = palavra.replace(/./g, "_ ");
            const erros = 0;
            const letrasUsadas = [];

            // Salva o jogo em um sistema simples (pode ser expandido)
            global.jogoDaForca = global.jogoDaForca || {};
            global.jogoDaForca[from] = {
                palavra: palavra,
                palavraOculta: palavraOculta,
                erros: erros,
                letrasUsadas: letrasUsadas,
                ativo: true
            };

            const desenhos = [
                "```\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n /    |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========```"
            ];

            await reply(sock, from,
                `üéØ *JOGO DA FORCA INICIADO!*\n\n` +
                `${desenhos[0]}\n\n` +
                `üìù Palavra: ${palavraOculta}\n` +
                `‚ùå Erros: ${erros}/6\n` +
                `üî§ Letras usadas: Nenhuma\n\n` +
                `üí° Digite uma letra para tentar adivinhar!\n` +
                `‚ö†Ô∏è Apenas letras A-Z s√£o aceitas`
            );
        }
        break;

        case "jogodavelha": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para jogar!\n\nExemplo: ${config.prefix}jogodavelha @usuario`);
                break;
            }

            const oponente = mentioned[0];
            if (oponente === sender) {
                await reply(sock, from, "‚ùå Voc√™ n√£o pode jogar contra si mesmo!");
                break;
            }

            // Inicializa o jogo
            global.jogoDaVelha = global.jogoDaVelha || {};
            global.jogoDaVelha[from] = {
                jogador1: sender,
                jogador2: oponente,
                vezDe: sender,
                tabuleiro: ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"],
                ativo: true
            };

            const tabuleiro =
                `${global.jogoDaVelha[from].tabuleiro[0]} ${global.jogoDaVelha[from].tabuleiro[1]} ${global.jogoDaVelha[from].tabuleiro[2]}\n` +
                `${global.jogoDaVelha[from].tabuleiro[3]} ${global.jogoDaVelha[from].tabuleiro[4]} ${global.jogoDaVelha[from].tabuleiro[5]}\n` +
                `${global.jogoDaVelha[from].tabuleiro[6]} ${global.jogoDaVelha[from].tabuleiro[7]} ${global.jogoDaVelha[from].tabuleiro[8]}`;

            await reply(sock, from,
                `‚≠ï *JOGO DA VELHA INICIADO!*\n\n` +
                `${tabuleiro}\n\n` +
                `üë§ Jogador 1: @${sender.split('@')[0]} (‚ùå)\n` +
                `üë§ Jogador 2: @${oponente.split('@')[0]} (‚≠ï)\n\n` +
                `üéØ Vez de: @${sender.split('@')[0]}\n\n` +
                `üí° Digite um n√∫mero de 1 a 9 para fazer sua jogada!\n` +
                `üîÑ Use \`${config.prefix}resetjogodavelha\` para resetar o jogo`,
                [sender, oponente]
            );
        }
        break;

        case "resetjogodavelha": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.jogoDaVelha = global.jogoDaVelha || {};
            if (!global.jogoDaVelha[from] || !global.jogoDaVelha[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° jogo da velha ativo neste grupo!");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.jogoDaVelha[from];

            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem resetar o jogo!");
                break;
            }

            delete global.jogoDaVelha[from];
            await reply(sock, from, `üîÑ *JOGO DA VELHA RESETADO!*\n\nO jogo foi cancelado por @${sender.split('@')[0]}`, [sender]);
        }
        break;

        case "roletarussa": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;

            if (!mentioned || mentioned.length === 0) {
                const configBot = obterConfiguracoes();
                await reply(sock, from, `‚ùå Marque algu√©m para jogar roleta russa!\n\nExemplo: ${configBot.prefix}roletarussa @usuario`);
                break;
            }

            const oponente = mentioned[0];
            if (oponente === sender) {
                await reply(sock, from, "‚ùå Voc√™ n√£o pode jogar contra si mesmo!");
                break;
            }

            // Inicializa o jogo
            global.roletaRussa = global.roletaRussa || {};
            global.roletaRussa[from] = {
                jogador1: sender,
                jogador2: oponente,
                vezDe: sender,
                balaFatal: Math.floor(Math.random() * 6) + 1, // Posi√ß√£o da bala (1-6)
                tiroAtual: 1,
                ativo: true
            };

            const configBot = obterConfiguracoes();
            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/chZjfM9c/4756f4254a2ac3974c9b6f33842e8b58.jpg" },
                caption:
                    `üî´ *ROLETA RUSSA INICIADA!*\n\n` +
                    `üíÄ A morte est√° √† espreita...\n` +
                    `üéØ 6 c√¢maras, 1 bala fatal!\n\n` +
                    `üë§ Jogador 1: @${sender.split('@')[0]}\n` +
                    `üë§ Jogador 2: @${oponente.split('@')[0]}\n\n` +
                    `üé≤ Vez de: @${sender.split('@')[0]}\n\n` +
                    `üí• **ESCOLHA SEU DESTINO:**\n` +
                    `‚Ä¢ \`${configBot.prefix}disparar\` - Puxar o gatilho (RISCO!)\n` +
                    `‚Ä¢ \`${configBot.prefix}passar\` - Passar a vez (SEGURO!)\n\n` +
                    `üîÑ Use \`${configBot.prefix}resetroleta\` para cancelar\n\n` +
                    `‚ö†Ô∏è Coragem ou covardia? A escolha √© sua...`,
                mentions: [sender, oponente]
            });
        }
        break;

        case "resetroleta": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.roletaRussa = global.roletaRussa || {};
            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° roleta russa ativa neste grupo!");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.roletaRussa[from];

            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem cancelar o jogo!");
                break;
            }

            delete global.roletaRussa[from];
            await reply(sock, from, `üîÑ *ROLETA RUSSA CANCELADA!*\n\nO jogo foi cancelado por @${sender.split('@')[0]}\n\nüòÆ‚Äçüí® Todos respiraram aliviados...`, [sender]);
        }
        break;

        case "disparar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.roletaRussa = global.roletaRussa || {};
            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° roleta russa ativa neste grupo! Use `.roletarussa @usuario` para iniciar.");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.roletaRussa[from];

            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem disparar!");
                break;
            }

            // Verifica se √© a vez do jogador
            if (sender !== jogo.vezDe) {
                await reply(sock, from, `‚ùå N√£o √© sua vez! √â a vez de @${jogo.vezDe.split('@')[0]}`, [jogo.vezDe]);
                break;
            }

            // Verifica se o jogo j√° deveria ter terminado (prote√ß√£o contra loop infinito)
            if (jogo.tiroAtual > 6) {
                // For√ßa final do jogo - algu√©m deve morrer
                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;

                // Baixa o GIF primeiro
                const response = await axios.get("https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif", {
                    responseType: 'arraybuffer',
                    timeout: 10000
                });
                const gifBuffer = Buffer.from(response.data);

                await sock.sendMessage(from, {
                    video: gifBuffer,
                    mimetype: "image/gif",
                    gifPlayback: true,
                    caption:
                        `üí• *BANG! JOGO FOR√áADO!* üí•\n\n` +
                        `üíÄ @${sender.split('@')[0]} morreu na c√¢mara extra! üî´\n\n` +
                        `üèÜ *VENCEDOR:* @${vencedor.split('@')[0]} üéâ\n` +
                        `üìä O jogo foi muito longo - fim for√ßado!\n\n` +
                        `‚ö∞Ô∏è Algu√©m tinha que morrer... üåπ\n` +
                        `‚è∞ Jogo excedeu 6 turnos!`,
                    mentions: [sender, vencedor]
                });

                delete global.roletaRussa[from];
                break;
            }

            // Processa o disparo
            console.log(`üî´ Tiro ${jogo.tiroAtual} - Bala fatal na posi√ß√£o ${jogo.balaFatal}`);

            if (jogo.tiroAtual === jogo.balaFatal) {
                // BANG! Jogador morreu
                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;

                // Envia GIF usando m√©todo simples
                const gifEnviado = await enviarGif(
                    sock,
                    from,
                    "https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif",
                    `üí• *BANG! GAME OVER!* üí•\n\n` +
                    `üíÄ @${sender.split('@')[0]} puxou a bala fatal e morreu! üî´\n\n` +
                    `üèÜ *VENCEDOR:* @${vencedor.split('@')[0]} üéâ\n` +
                    `üìä Tiro fatal: ${jogo.tiroAtual}/6\n\n` +
                    `‚ö∞Ô∏è RIP... que a terra te seja leve! üåπ\n` +
                    `üéØ O destino foi selado!`,
                    [sender, vencedor]
                );

                if (!gifEnviado) {
                    await reply(sock, from,
                        `üí• *BANG! GAME OVER!* üí•\n\n` +
                        `üíÄ @${sender.split('@')[0]} puxou a bala fatal e morreu! üî´\n\n` +
                        `üèÜ *VENCEDOR:* @${vencedor.split('@')[0]} üéâ\n` +
                        `üìä Tiro fatal: ${jogo.tiroAtual}/6\n\n` +
                        `‚ö∞Ô∏è RIP... que a terra te seja leve! üåπ\n` +
                        `üéØ O destino foi selado!`,
                        [sender, vencedor]
                    );
                }

                // Reset do jogo
                delete global.roletaRussa[from];

            } else {
                // Clique! Jogador sobreviveu
                const proximoJogador = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;
                jogo.vezDe = proximoJogador;
                jogo.tiroAtual++;

                const sobrevivencia = [
                    "escapou por pouco", "teve sorte desta vez", "a morte passou longe",
                    "o destino poupou", "ainda n√£o chegou sua hora", "sobreviveu mais uma vez"
                ];
                const frase = sobrevivencia[Math.floor(Math.random() * sobrevivencia.length)];

                const configBot = obterConfiguracoes();

                // Envia GIF usando m√©todo simples
                const gifEnviado = await enviarGif(
                    sock,
                    from,
                    "https://i.ibb.co/yFvQCn1p/3b7300aa2a120ec29a2b4de808f40a77.gif",
                    `üî´ *CLIQUE!* Nada aconteceu... üò∞\n\n` +
                    `üòÖ @${sender.split('@')[0]} ${frase}!\n\n` +
                    `üé≤ *Pr√≥xima vez:* @${proximoJogador.split('@')[0]}\n` +
                    `üìä Tiro: ${jogo.tiroAtual - 1}/6\n\n` +
                    `üí• Digite \`${configBot.prefix}disparar\` para continuar!\n` +
                    `‚ö° A tens√£o aumenta...`,
                    [sender, proximoJogador]
                );

                if (!gifEnviado) {
                    await reply(sock, from,
                        `üî´ *CLIQUE!* Nada aconteceu... üò∞\n\n` +
                        `üòÖ @${sender.split('@')[0]} ${frase}!\n\n` +
                        `üé≤ *Pr√≥xima vez:* @${proximoJogador.split('@')[0]}\n` +
                        `üìä Tiro: ${jogo.tiroAtual - 1}/6\n\n` +
                        `üí• Digite \`${configBot.prefix}disparar\` para continuar!\n` +
                        `‚ö° A tens√£o aumenta...`,
                        [sender, proximoJogador]
                    );
                }
            }
        }
        break;

        default:
            const config = obterConfiguracoes();
            await reply(sock, from, `‚ùå Comando "${command}" n√£o encontrado.\n\nDigite "prefixo" para ver meu prefixo ou "${config.prefix}ping" para testar.`);
            break;
    }
}

// Processa jogadas dos jogos ativos
async function processarJogadas(sock, text, from, normalized) {
    try {
        const sender = normalized.key.participant || from;
        const numero = parseInt(text.trim());

        // Jogo da Velha
        global.jogoDaVelha = global.jogoDaVelha || {};
        if (global.jogoDaVelha[from] && global.jogoDaVelha[from].ativo) {
            const jogo = global.jogoDaVelha[from];

            // Verifica se √© a vez do jogador
            if (sender !== jogo.vezDe) {
                return false; // N√£o √© a vez dele, ignora
            }

            // Verifica se o n√∫mero √© v√°lido (1-9)
            if (numero >= 1 && numero <= 9) {
                const posicao = numero - 1;

                // Verifica se a posi√ß√£o est√° livre
                if (jogo.tabuleiro[posicao].includes("Ô∏è‚É£")) {
                    // Faz a jogada
                    const simbolo = sender === jogo.jogador1 ? "‚ùå" : "‚≠ï";
                    jogo.tabuleiro[posicao] = simbolo;

                    // Verifica se ganhou
                    const combinacoes = [
                        [0,1,2], [3,4,5], [6,7,8], // linhas
                        [0,3,6], [1,4,7], [2,5,8], // colunas
                        [0,4,8], [2,4,6] // diagonais
                    ];

                    let ganhou = false;
                    for (const combo of combinacoes) {
                        if (combo.every(pos => jogo.tabuleiro[pos] === simbolo)) {
                            ganhou = true;
                            break;
                        }
                    }

                    const tabuleiro =
                        `${jogo.tabuleiro[0]} ${jogo.tabuleiro[1]} ${jogo.tabuleiro[2]}\n` +
                        `${jogo.tabuleiro[3]} ${jogo.tabuleiro[4]} ${jogo.tabuleiro[5]}\n` +
                        `${jogo.tabuleiro[6]} ${jogo.tabuleiro[7]} ${jogo.tabuleiro[8]}`;

                    if (ganhou) {
                        await reply(sock, from,
                            `üèÜ *JOGO DA VELHA - VIT√ìRIA!*\n\n` +
                            `${tabuleiro}\n\n` +
                            `üéâ @${sender.split('@')[0]} GANHOU!\n` +
                            `üèÖ Parab√©ns pelo jogo!`,
                            [sender]
                        );
                        delete global.jogoDaVelha[from];
                        return true;
                    }

                    // Verifica empate
                    if (jogo.tabuleiro.every(pos => !pos.includes("Ô∏è‚É£"))) {
                        await reply(sock, from,
                            `ü§ù *JOGO DA VELHA - EMPATE!*\n\n` +
                            `${tabuleiro}\n\n` +
                            `üòÖ Deu velha! Ningu√©m ganhou!`
                        );
                        delete global.jogoDaVelha[from];
                        return true;
                    }

                    // Alterna vez
                    jogo.vezDe = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;

                    await reply(sock, from,
                        `‚≠ï *JOGO DA VELHA*\n\n` +
                        `${tabuleiro}\n\n` +
                        `üéØ Vez de: @${jogo.vezDe.split('@')[0]}\n` +
                        `üí° Digite um n√∫mero de 1 a 9!`,
                        [jogo.vezDe]
                    );
                    return true;
                }
            }
        }

        // Jogo da Forca
        global.jogoDaForca = global.jogoDaForca || {};
        if (global.jogoDaForca[from] && global.jogoDaForca[from].ativo) {
            const jogo = global.jogoDaForca[from];
            const letra = text.trim().toUpperCase();

            // Verifica se √© uma letra v√°lida
            if (letra.length === 1 && /[A-Z]/.test(letra)) {
                if (jogo.letrasUsadas.includes(letra)) {
                    await reply(sock, from, `‚ö†Ô∏è Letra **${letra}** j√° foi usada!`);
                    return true;
                }

                jogo.letrasUsadas.push(letra);

                if (jogo.palavra.includes(letra)) {
                    // Acertou a letra
                    let novaPalavraOculta = "";
                    for (let i = 0; i < jogo.palavra.length; i++) {
                        if (jogo.palavra[i] === letra || jogo.palavraOculta[i * 2] !== "_") {
                            novaPalavraOculta += jogo.palavra[i] + " ";
                        } else {
                            novaPalavraOculta += "_ ";
                        }
                    }
                    jogo.palavraOculta = novaPalavraOculta;

                    // Verifica se ganhou
                    if (!jogo.palavraOculta.includes("_")) {
                        await reply(sock, from,
                            `üéâ *PARAB√âNS! VOC√ä GANHOU!*\n\n` +
                            `üéØ Palavra: **${jogo.palavra}**\n` +
                            `‚úÖ Voc√™ adivinhou a palavra!\n` +
                            `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}`
                        );
                        delete global.jogoDaForca[from];
                        return true;
                    }

                    await reply(sock, from,
                        `‚úÖ *BOA! Letra encontrada!*\n\n` +
                        `üìù Palavra: ${jogo.palavraOculta}\n` +
                        `‚ùå Erros: ${jogo.erros}/6\n` +
                        `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}`
                    );
                } else {
                    // Errou a letra
                    jogo.erros++;

                    const desenhos = [
                        "```\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n /    |\n      |\n=========```",
                        "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========```"
                    ];

                    if (jogo.erros >= 6) {
                        await reply(sock, from,
                            `üíÄ *GAME OVER! VOC√ä PERDEU!*\n\n` +
                            `${desenhos[6]}\n\n` +
                            `üéØ A palavra era: **${jogo.palavra}**\n` +
                            `‚ùå Voc√™ foi enforcado!\n` +
                            `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}`
                        );
                        delete global.jogoDaForca[from];
                        return true;
                    }

                    await reply(sock, from,
                        `‚ùå *Letra n√£o encontrada!*\n\n` +
                        `${desenhos[jogo.erros]}\n\n` +
                        `üìù Palavra: ${jogo.palavraOculta}\n` +
                        `‚ùå Erros: ${jogo.erros}/6\n` +
                        `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}`
                    );
                }
                return true;
            }
        }

        return false;
    } catch (error) {
        console.error("‚ùå Erro ao processar jogada:", error);
        return false;
    }
}

// Fun√ß√£o para processar mensagens do Akinator
async function processarAkinator(sock, text, from, normalized) {
    try {
        const gameIndex = akinator.map(i => i.id).indexOf(from);
        if (gameIndex === -1 || !akinator[gameIndex].aki) return false;

        const respostas = {
            "sim": 0,
            "n√£o": 1,
            "nao": 1,
            "n√£o sei": 2,
            "nao sei": 2,
            "provavelmente sim": 3,
            "provavelmente n√£o": 4,
            "provavelmente nao": 4
        };

        const resposta = text.toLowerCase().trim();
        if (!(resposta in respostas)) return false;

        const gameData = akinator[gameIndex];
        const answer = respostas[resposta];

        try {
            await gameData.aki.step(answer);
            gameData.step++;

            if (gameData.aki.progress >= 85 || gameData.step >= 20) {
                await gameData.aki.win();
                const guess = gameData.aki.answers[0];

                if (guess) {
                    akinator[gameIndex].finish = 1;
                    salvarAkinator();

                    await sock.sendMessage(from, {
                        image: { url: guess.absolute_picture_path || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg" },
                        caption: `üßû‚Äç‚ôÇÔ∏è *EU ACHO QUE √â...*\n\nüë§ **${guess.name}**\nüìù **Descri√ß√£o:** ${guess.description}\nüéØ **Confian√ßa:** ${Math.round(guess.proba * 100)}%\n\nü§î Acertei? Responda *sim* ou *n√£o*`,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            }
                        }
                    });
                } else {
                    await reply(sock, from, "üßû‚Äç‚ôÇÔ∏è Hmm... n√£o consegui adivinhar desta vez! Voc√™ venceu! üéâ");
                    akinator.splice(gameIndex, 1);
                    salvarAkinator();
                }
            } else {
                await reply(sock, from, `üßû‚Äç‚ôÇÔ∏è *PERGUNTA ${gameData.step + 1}:*\n‚Ä¢ ${gameData.aki.question}\n\nüìä Progresso: ${Math.round(gameData.aki.progress)}%`);
            }
        } catch (err) {
            console.error("‚ùå Erro no Akinator:", err);
            await reply(sock, from, "‚ùå Erro no jogo do Akinator. Tente resetar com .resetaki");
        }

        return true;
    } catch (error) {
        console.error("‚ùå Erro ao processar Akinator:", error);
        return false;
    }
}

// Fun√ß√£o principal de setup dos listeners
function setupListeners(sock) {
    sock.ev.on("messages.upsert", async ({ messages }) => {
        try {
            for (const m of messages) {
                if (!m.message || m.key.fromMe) continue;

                const messageId = m.key.id;
                if (processedMessages.has(messageId)) continue;
                processedMessages.add(messageId);

                const { normalized, quoted } = normalizeMessage(m);
                const text = getMessageText(normalized.message);
                const from = normalized.key.remoteJid;

                if (!text) continue;

                // Log da mensagem
                logMensagem(normalized, text);

                // Processa anti-spam primeiro
                const violacaoDetectada = await processarAntiSpam(sock, normalized);
                if (violacaoDetectada) continue;

                // Processa jogadas de jogos ativos
                const jogadaProcessada = await processarJogadas(sock, text, from, normalized);
                if (jogadaProcessada) continue;

                // Processa Akinator
                const akinatorProcessado = await processarAkinator(sock, text, from, normalized);
                if (akinatorProcessado) continue;

                // Processa comandos
                const config = obterConfiguracoes();
                if (text.startsWith(config.prefix)) {
                    const args = text.slice(config.prefix.length).trim().split(/ +/);
                    const command = args.shift()?.toLowerCase();

                    if (command) {
                        logMensagem(normalized, text, true);
                        await handleCommand(sock, normalized, command, args, from, quoted);
                    }
                }
            }
        } catch (error) {
            console.error("‚ùå Erro no processamento de mensagens:", error);
        }
    });

    // Listener para participantes adicionados/removidos
    sock.ev.on("group-participants.update", async ({ id, participants, action }) => {
        try {
            await processarListaNegra(sock, participants, id, action);
        } catch (error) {
            console.error("‚ùå Erro ao processar mudan√ßa de participantes:", error);
        }
    });

    console.log("‚úÖ Event listeners configurados com sucesso!");
}

// Exporta a fun√ß√£o de setup
module.exports = { setupListeners };

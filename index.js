// index.js ‚Äî Bot completo com eventos e comandos unificados

const { 
    makeWASocket, 
    fetchLatestBaileysVersion, 
    generateWAMessageFromContent,
    downloadContentFromMessage
} = require("@whiskeysockets/baileys");


const path = require("path"); // <<< ESSENCIAL PARA path.joinv
const fs = require("fs");
const axios = require("axios");
const os = require("os");
const { writeExif } = require("./arquivos/sticker.js");
const { sendImageAsSticker, sendVideoAsSticker } = require("./arquivos/rename.js");
const Jimp = require("jimp");
const pinterest = require('./Pinterest.js');
const { igdl } = require('./Instagram.js');
const settings = require('./settings/settings.json');
const { Aki } = require('aki-api');
const cloudscraper = require('cloudscraper');
const UserAgent = require('user-agents');
const moment = require('moment-timezone');

// Sistema RPG - NeextCity
const rpg = require('./arquivos/rpg.js');

const antilinkFile = path.join(__dirname, "antilink.json");
const akinatorFile = path.join(__dirname, "database/grupos/games/akinator.json");

// Sistema Anti-Spam Completo
const antiSpam = require("./arquivos/antispam.js");

// Sistema de Registros
const registros = require("./arquivos/registros.js");

// importa banner + logger centralizados
const { mostrarBanner, logMensagem } = require("./export");

// importa fun√ß√µes auxiliares do menu
const { obterSaudacao, contarGrupos, contarComandos } = require("./arquivos/funcoes/function.js");

// Config do Bot - agora usando refer√™ncias din√¢micas para permitir altera√ß√µes em tempo real
function obterConfiguracoes() {
    delete require.cache[require.resolve('./settings/settings.json')];
    return require('./settings/settings.json');
}

// Selinhos e quoted fake (mantive seu conte√∫do)
const selinho = {
    key: { fromMe: false, participant: `13135550002@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Kuun;Flash;;;\nFN:Flash Kuun\nitem1.TEL;waid=13135550002:+1 (313) 555-0002\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selinho2 = {
    key: { fromMe: false, participant: `553176011100@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:un;Flh;;;\nFN:Kuun\nitem1.TEL;waid=553176011100:553176011100\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selomercadopago = {
    key: { fromMe: false, participant: `5511988032872@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Mercado;Pago;;;\nFN:Mercado Pago\nitem1.TEL;waid=5511988032872:5511988032872\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const selonubank = {
    key: { fromMe: false, participant: `551151807064@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Nubank;Flash;;;\nFN:Nubank Kuun\nitem1.TEL;waid=551151807064:551151807064\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const seloserasa = {
    key: { fromMe: false, participant: `551128475131@s.whatsapp.net`, remoteJid: 'status@broadcast' },
    message: { contactMessage: { displayName: 'NEEXT LTDA', vcard: `BEGIN:VCARD\nVERSION:3.0\nN:Serasa;Flash;;;\nFN:Serasa Kuun\nitem1.TEL;waid=551128475131:551128475131\nitem1.X-ABLabel:Mobile\nEND:VCARD`, sendEphemeral: true } }
};
const quotedCarrinho = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: { documentMessage: { title: "üõí Neext Ltda", fileName: "Neext.pdf", mimetype: "application/pdf", fileLength: 999999, pageCount: 1 } }
};

// System NEEXT (status do sistema) para usar no grupo-status
const quotedSerasaAPK = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: { 
        documentMessage: { 
            title: "üõ°Ô∏è NEEXT System", 
            fileName: "serasa.apk", 
            mimetype: "application/vnd.android.package-archive", 
            fileLength: 549755813888000, // 500TB em bytes
            pageCount: 0,
            contactVcard: true
        } 
    }
};

// APK Fake da NEEXT LTDA (1000GB) para usar no grupo-status
const quotedNeextAPK = {
    key: { participant: "0@s.whatsapp.net", remoteJid: "0@s.whatsapp.net" },
    message: { 
        documentMessage: { 
            title: "üì± NEEXT LTDA", 
            fileName: "neext_ltda.apk", 
            mimetype: "application/vnd.android.package-archive", 
            fileLength: 1073741824000, // 1000GB em bytes
            pageCount: 0,
            contactVcard: true
        } 
    }
};

// ContextInfo para fazer mensagens aparecerem como "enviada via an√∫ncio"
const contextAnuncio = {
    externalAdReply: {
        title: "¬© NEEXT LTDA",
        body: "üì± Instagram: @neet.tk",
        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
        mediaType: 1,
        sourceUrl: "https://www.neext.online",
        showAdAttribution: true
    }
};

// Mensagens j√° processadas (evita duplicadas)
const processedMessages = new Set();
setInterval(() => processedMessages.clear(), 5 * 60 * 1000);

// Vari√°veis do jogo Akinator
let akinator = [];
let jogo = { now: true, jogador: "" };

// Classe para bypass do Cloudflare no Akinator
class AkinatorCloudflareBypass {
    constructor() {
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'
        ];
    }

    getRandomUserAgent() {
        return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];
    }

    async createAkinator(region = 'en', retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                console.log(`üßû‚Äç‚ôÇÔ∏è Tentando conectar ao Akinator (tentativa ${attempt}/${retries})...`);

                // Configura cloudscraper para contornar Cloudflare
                const userAgent = this.getRandomUserAgent();

                // Cria inst√¢ncia do Akinator
                const aki = new Aki({ 
                    region: region, 
                    childMode: false,
                    // Configura√ß√µes para bypass
                    requestOptions: {
                        headers: {
                            'User-Agent': userAgent,
                            'Accept': 'application/json, text/plain, */*',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Connection': 'keep-alive',
                            'Upgrade-Insecure-Requests': '1',
                            'Sec-Fetch-Dest': 'document',
                            'Sec-Fetch-Mode': 'navigate',
                            'Sec-Fetch-Site': 'none',
                            'Cache-Control': 'max-age=0'
                        },
                        timeout: 30000
                    }
                });

                // Aguarda um pouco antes de tentar
                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));

                await aki.start();
                console.log(`‚úÖ Conectado ao Akinator com sucesso! Regi√£o: ${region}`);
                return aki;

            } catch (error) {
                console.error(`‚ùå Tentativa ${attempt} falhou:`, error.message);

                if (attempt === retries) {
                    throw new Error(`Falha ap√≥s ${retries} tentativas. Akinator temporariamente indispon√≠vel.`);
                }

                // Aguarda mais tempo a cada tentativa
                await new Promise(resolve => setTimeout(resolve, 5000 * attempt));
            }
        }
    }
}

// Carrega dados do Akinator
function carregarAkinator() {
    try {
        if (!fs.existsSync(akinatorFile)) {
            const dir = path.dirname(akinatorFile);
            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
            fs.writeFileSync(akinatorFile, "[]");
        }
        const data = fs.readFileSync(akinatorFile, "utf-8");
        akinator = JSON.parse(data);
        return akinator;
    } catch (err) {
        console.error("‚ùå Erro ao carregar akinator.json:", err);
        akinator = [];
        return [];
    }
}

// Salva dados do Akinator
function salvarAkinator() {
    try {
        fs.writeFileSync(akinatorFile, JSON.stringify(akinator, null, 2));
    } catch (err) {
        console.error("‚ùå Erro ao salvar akinator.json:", err);
    }
}

// Inicializa dados do Akinator
carregarAkinator();




// Fun√ß√µes antigas removidas - agora usamos o sistema antiSpam completo

// Fun√ß√£o utilit√°ria: extrai texto da mensagem
function getMessageText(message) {
    if (!message) return "";
    if (message.conversation) return message.conversation;
    if (message.extendedTextMessage?.text) return message.extendedTextMessage.text;
    if (message.imageMessage?.caption) return message.imageMessage.caption;
    if (message.videoMessage?.caption) return message.videoMessage.caption;
    if (message.buttonsResponseMessage?.selectedButtonId) return message.buttonsResponseMessage.selectedButtonId;
    if (message.listResponseMessage?.singleSelectReply?.selectedRowId) return message.listResponseMessage.singleSelectReply.selectedRowId;
    if (message.ephemeralMessage?.message) return getMessageText(message.ephemeralMessage.message);
    return "";
}

// Normaliza mensagem e retorna quoted
function normalizeMessage(m) {
    if (!m?.message) return { normalized: m, quoted: null };
    let message = m.message;
    if (message.ephemeralMessage) message = message.ephemeralMessage.message;
    if (message.viewOnceMessage) message = message.viewOnceMessage.message;
    const contextInfo = message.extendedTextMessage?.contextInfo || {};
    const quoted = contextInfo.quotedMessage || null;
    return { normalized: { ...m, message }, quoted };
}

// Fun√ß√£o reply gen√©rica
async function reply(sock, from, text, mentions = []) {
    try { await sock.sendMessage(from, { 
        text,
        contextInfo: {
            forwardingScore: 100000,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
                newsletterJid: "120363289739581116@newsletter",
                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
            }
        },
        mentions
    }); }
    catch (err) { console.error("‚ùå Erro ao enviar reply:", err); }
}

// Reage a qualquer mensagem com emoji
async function reagirMensagem(sock, normalized, emoji = "ü§ñ") {
    if (!normalized?.key) return false;
    try {
        await sock.sendMessage(normalized.key.remoteJid, {
            react: {
                text: emoji,
                key: normalized.key
            }
        });
        return true;
    } catch (err) {
        console.error("‚ùå Erro ao reagir:", err);
        return false;
    }
}

// Detecta links na mensagem
function detectarLinks(texto) {
    if (!texto) return false;
    const linkRegex = /((https?:\/\/)|(www\.))[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)|wa.me\/|whatsapp.com\/|t.me\/|chat.whatsapp.com\/|instagram.com\/|facebook.com\/|twitter.com\/|tiktok.com\/|youtube.com\/|discord.gg\//i;
    return linkRegex.test(texto);
}

// Verifica se usu√°rio √© admin do grupo
async function isAdmin(sock, groupId, userId) {
    try {
        const groupMetadata = await sock.groupMetadata(groupId);
        const participant = groupMetadata.participants.find(p => p.id === userId);
        return participant && (participant.admin === 'admin' || participant.admin === 'superadmin');
    } catch (err) {
        console.error("‚ùå Erro ao verificar admin:", err);
        return false;
    }
}

// Verifica se usu√°rio √© o dono do bot
function isDono(userId) {
    const config = obterConfiguracoes();
    const numeroDono = config.numeroDoDono + "@s.whatsapp.net";
    return userId === numeroDono;
}

// Remove mensagem do grupo
async function removerMensagem(sock, messageKey) {
    try {
        await sock.sendMessage(messageKey.remoteJid, { delete: messageKey });
        return true;
    } catch (err) {
        console.error("‚ùå Erro ao remover mensagem:", err);
        return false;
    }
}

// Verifica se bot √© admin do grupo
async function botEhAdmin(sock, groupId) {
    try {
        const groupMetadata = await sock.groupMetadata(groupId);
        const botId = sock.user?.id?.replace(/:.*@s.whatsapp.net/, '@s.whatsapp.net') || sock.user?.id;
        const botParticipant = groupMetadata.participants.find(p => p.id === botId);
        return botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');
    } catch (err) {
        console.error("‚ùå Erro ao verificar se bot √© admin:", err);
        return false;
    }
}

// Bane usu√°rio do grupo
async function banirUsuario(sock, groupId, userId) {
    try {
        // Verifica se bot tem permiss√£o de admin
        const botAdmin = await botEhAdmin(sock, groupId);
        if (!botAdmin) {
            console.log(`‚ö†Ô∏è Bot n√£o √© admin no grupo ${groupId} - n√£o pode banir`);
            return { success: false, reason: "bot_nao_admin" };
        }

        console.log(`‚öîÔ∏è Tentando banir usu√°rio ${userId} do grupo ${groupId}`);
        await sock.groupParticipantsUpdate(groupId, [userId], "remove");
        console.log(`‚úÖ Usu√°rio ${userId} banido com sucesso!`);
        return { success: true, reason: "banido" };
    } catch (err) {
        console.error(`‚ùå Erro ao banir usu√°rio ${userId}:`, err);
        if (err.message?.includes('forbidden')) {
            return { success: false, reason: "sem_permissao" };
        }
        return { success: false, reason: "erro_tecnico" };
    }
}

// Processa sistema anti-spam completo
async function processarAntiSpam(sock, normalized) {
    try {
        const from = normalized.key.remoteJid;
        const sender = normalized.key.participant || from;

        // S√≥ funciona em grupos
        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;

        // N√£o processa se for o dono
        if (isDono(sender)) {
            return false;
        }

        // N√£o processa se for admin
        const ehAdmin = await isAdmin(sock, from, sender);
        if (ehAdmin) {
            return false;
        }

        // Processa mensagem para verificar viola√ß√µes
        const resultado = antiSpam.processarMensagem(normalized.message, from, sender);
        
        if (!resultado.violacao) return false;

        const senderNumber = sender.split('@')[0];
        const tiposViolacao = resultado.tipos;
        
        console.log(`üö´ Viola√ß√£o detectada de ${senderNumber}: ${tiposViolacao.join(', ')}`);

        // Remove a mensagem
        const removido = await removerMensagem(sock, normalized.key);

        if (removido) {
            // Aguarda um pouco antes de tentar banir
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Tenta banir o usu√°rio
            const resultadoBan = await banirUsuario(sock, from, sender);
            
            const emojiMap = {
                'antilink': 'üîó',
                'anticontato': 'üìû',
                'antidocumento': 'üìÑ',
                'antivideo': 'üé•',
                'antiaudio': 'üéµ',
                'antisticker': 'üè∑Ô∏è',
                'antiflod': 'üåä'
            };
            
            const violacaoEmoji = emojiMap[tiposViolacao[0]] || 'üö´';
            const violacaoNome = tiposViolacao[0].toUpperCase();

            if (resultadoBan.success) {
                await reagirMensagem(sock, normalized, "‚öîÔ∏è");
                await reply(sock, from, `‚öîÔ∏è *${violacaoEmoji} ${violacaoNome} - USU√ÅRIO BANIDO!*\n\n@${senderNumber} foi removido do grupo por viola√ß√£o!\n\nüö´ Conte√∫do n√£o permitido: ${tiposViolacao.join(', ')}\n‚ö° A√ß√£o: Delete + Ban autom√°tico`, [sender]);
                console.log(`‚öîÔ∏è SUCESSO: ${senderNumber} banido do grupo ${from} por ${tiposViolacao.join(', ')}`);
            } else {
                await reagirMensagem(sock, normalized, "üö´");
                let motivo = "";
                switch(resultadoBan.reason) {
                    case "bot_nao_admin":
                        motivo = "Bot n√£o √© admin do grupo";
                        break;
                    case "sem_permissao":
                        motivo = "Bot sem permiss√£o para banir";
                        break;
                    default:
                        motivo = "Erro t√©cnico no banimento";
                }

                await reply(sock, from, `üö´ *${violacaoEmoji} ${violacaoNome} ATIVO*\n\n@${senderNumber} sua mensagem foi deletada por viola√ß√£o!\n\n‚ö†Ô∏è **N√£o foi poss√≠vel banir:** ${motivo}\nüí° **Solu√ß√£o:** Torne o bot admin do grupo`, [sender]);
                console.log(`‚ö†Ô∏è FALHA: N√£o foi poss√≠vel banir ${senderNumber} - ${motivo}`);
            }
        }

        return true;
    } catch (err) {
        console.error("‚ùå Erro no processamento anti-spam:", err);
        return false;
    }
}

// Auto-ban para lista negra e antifake quando usu√°rio entra no grupo
async function processarListaNegra(sock, participants, groupId, action) {
    try {
        if (action !== 'add') return;
        
        const config = antiSpam.carregarConfigGrupo(groupId);
        if (!config) return;
        
        for (const participant of participants) {
            const participantNumber = participant.split('@')[0];
            let motivo = '';
            let shouldBan = false;
            
            // Verifica lista negra
            if (antiSpam.isUsuarioListaNegra(participant, groupId)) {
                motivo = 'Lista Negra';
                shouldBan = true;
                console.log(`üìã Usu√°rio da lista negra detectado: ${participantNumber}`);
            }
            
            // Verifica antifake (n√∫meros n√£o brasileiros)
            if (config.antifake && !antiSpam.isNumeroBrasileiro(participant)) {
                motivo = motivo ? `${motivo} + Antifake` : 'Antifake (n√£o brasileiro)';
                shouldBan = true;
                console.log(`üáßüá∑ Usu√°rio n√£o brasileiro detectado: ${participantNumber}`);
            }
            
            if (shouldBan) {
                // Aguarda um pouco antes de banir
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                const resultadoBan = await banirUsuario(sock, groupId, participant);
                
                if (resultadoBan.success) {
                    const emoji = motivo.includes('Lista Negra') ? 'üìã' : 'üáßüá∑';
                    await sock.sendMessage(groupId, {
                        text: `‚öîÔ∏è *${emoji} ${motivo.toUpperCase()} - USU√ÅRIO BANIDO!*\n\n@${participantNumber} foi removido automaticamente!\n\nüö´ Motivo: ${motivo}\n‚ö° A√ß√£o: Ban autom√°tico`,
                        mentions: [participant]
                    });
                    console.log(`‚öîÔ∏è ${motivo.toUpperCase()}: ${participantNumber} banido automaticamente do grupo ${groupId}`);
                } else {
                    console.log(`‚ö†Ô∏è ${motivo.toUpperCase()}: N√£o foi poss√≠vel banir ${participantNumber} - ${resultadoBan.reason}`);
                }
            }
        }
    } catch (err) {
        console.error("‚ùå Erro no processamento de lista negra/antifake:", err);
    }
}



// Fun√ß√£o principal de comandos
async function handleCommand(sock, message, command, args, from, quoted) {
    const msg = message.message;
    if (!msg) return;

    switch (command) {
        case "ping": {
            const now = new Date();
            const totalMem = (os.totalmem() / 1024 / 1024).toFixed(2);
            const freeMem = (os.freemem() / 1024 / 1024).toFixed(2);
            let uptimeSec = process.uptime();
            const days = Math.floor(uptimeSec / 86400);
            uptimeSec %= 86400;
            const hours = Math.floor(uptimeSec / 3600);
            uptimeSec %= 3600;
            const minutes = Math.floor(uptimeSec / 60);
            const seconds = Math.floor(uptimeSec % 60);
            const uptime = `${days}d ${hours}h ${minutes}m ${seconds}s`;

            const pingMessage = `
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ üìÖ Data: ${now.toLocaleDateString()}  
‚îÉ ‚è∞ Hora: ${now.toLocaleTimeString()}  
‚îÉ üü¢ Uptime: ${uptime}  
‚îÉ üíæ Mem√≥ria Total: ${totalMem} MB  
‚îÉ üíæ Mem√≥ria Livre: ${freeMem} MB
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`;

            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/xqddxGC6/d75ddb6631f10a0eff0b227c5b7617f2.jpg" },
                caption: pingMessage,
                contextInfo: {
                    mentionedJid: [from],
                    isForwarded: true,
                    forwardingScore: 100000,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: `¬© NEEXT LTDA`,
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "www.neext.online"
                    }
                }
            }, { quoted: selinho });
        }
        break;

        case "hora":
            await sock.sendMessage(from, { 
                text: `‚è∞ Agora √©: ${new Date().toLocaleTimeString()}`,
                contextInfo: contextAnuncio
            });
            break;

            case 'dono':
    // garante que 'sender' est√° definido no escopo correto
    const sender = message.key.participant || from;
    await reply(sock, from, "üõ°Ô∏è Esse √© o dono do bot!", [sender]);
    break;



        case "status":
            const statusText = args.join(" ").trim();
            if (!statusText) {
                const config = obterConfiguracoes();
                await reply(sock, from, "‚ùå Use: " + config.prefix + "status Seu novo status aqui");
                break;
            }
            try {
                await sock.updateProfileStatus(statusText);
                await reply(sock, from, `‚úÖ Status atualizado para:\n> _${statusText}_`);
            } catch (err) {
                console.error("Erro ao atualizar status:", err);
                await reply(sock, from, "‚ùå Falha ao atualizar status.");
            }
            break;

        case "marca":
            if (!from.endsWith("@g.us") && !from.endsWith("@lid")) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }
            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                const mensagem = `üì¢ Marca√ß√£o geral:\n` + participants.map((p, i) => `${i+1}. @${p.split("@")[0]}`).join("\n");
                await reply(sock, from, mensagem);
            } catch(err) {
                console.error("‚ùå Erro ao marcar participantes:", err);
                await reply(sock, from, "‚ùå Falha ao marcar todos no grupo.");
            }
            break;

        case "recado":
            await sock.sendMessage(from, { text: "üìå Bot est√° ativo e conectado!" }, { quoted: message });
            break;

        case "rg": {
            const sender = message.key.participant || from;
            const numeroUsuario = sender.split('@')[0];
            const nomeUsuario = message.pushName || "Usu√°rio";

            // Verifica se j√° est√° registrado
            if (registros.usuarioRegistrado(numeroUsuario)) {
                await reagirMensagem(sock, message, "‚ö†Ô∏è");
                const infoUsuario = registros.obterInfoUsuario(numeroUsuario);
                await reply(sock, from, 
                    `‚ö†Ô∏è *VOC√ä J√Å EST√Å REGISTRADO!*\n\n` +
                    `üë§ Nome: ${infoUsuario.nome}\n` +
                    `üì± N√∫mero: ${infoUsuario.numero}\n` +
                    `üìÖ Data do Registro: ${infoUsuario.dataRegistroFormatada}\n` +
                    `üî¢ Seu N√∫mero de Registro: #${infoUsuario.numeroRegistro}\n\n` +
                    `‚úÖ Voc√™ j√° pode usar todos os comandos do bot!`, 
                    [sender]
                );
                break;
            }

            // Registra o usu√°rio
            const resultado = registros.registrarUsuario(numeroUsuario, nomeUsuario);

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üéâ");
                
                // Obt√©m foto do perfil do usu√°rio
                let fotoPerfilUrl = "https://i.ibb.co/LDs3wJR3/a720804619ff4c744098b956307db1ff.jpg"; // Foto padr√£o para usu√°rios sem perfil
                try {
                    const profilePic = await sock.profilePictureUrl(sender, 'image');
                    if (profilePic) {
                        fotoPerfilUrl = profilePic;
                        console.log(`‚úÖ Foto do perfil obtida para ${numeroUsuario}: ${profilePic}`);
                    } else {
                        console.log(`‚ö†Ô∏è Usu√°rio ${numeroUsuario} n√£o possui foto de perfil, usando imagem padr√£o`);
                    }
                } catch (err) {
                    console.log(`‚ùå Erro ao obter foto do perfil de ${numeroUsuario}:`, err.message);
                    console.log("üì∑ Usando foto padr√£o para usu√°rio sem perfil");
                }

                const mensagemSucesso = 
                    `üéâ *PARAB√âNS! REGISTRO REALIZADO COM SUCESSO!* üéâ\n\n` +
                    `‚úÖ *Dados do Registro:*\n` +
                    `üë§ Nome: ${resultado.registro.nome}\n` +
                    `üì± N√∫mero: ${resultado.registro.numero}\n` +
                    `üìÖ Data: ${resultado.registro.dataRegistroFormatada}\n` +
                    `üî¢ Voc√™ √© o usu√°rio #${resultado.registro.numeroRegistro}\n\n` +
                    `üìä *Total de Registros no Sistema:* ${resultado.totalRegistros}\n\n` +
                    `üöÄ Agora voc√™ pode usar todos os comandos do bot!\n` +
                    `üí° Digite \`${config.prefix}menu\` para ver os comandos dispon√≠veis`;

                await sock.sendMessage(from, {
                    image: { url: fotoPerfilUrl },
                    caption: mensagemSucesso,
                    contextInfo: {
                        mentionedJid: [sender],
                        forwardingScore: 100000,
                        isForwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: "üéâ REGISTRO REALIZADO",
                            body: `¬© NEEXT LTDA ‚Ä¢ Usu√°rio #${resultado.registro.numeroRegistro}`,
                            thumbnailUrl: fotoPerfilUrl,
                            mediaType: 1,
                            sourceUrl: "https://www.neext.online"
                        }
                    }
                }, { quoted: selinho2 });

                console.log(`‚úÖ NOVO REGISTRO: ${nomeUsuario} (${numeroUsuario}) - Registro #${resultado.registro.numeroRegistro}`);
            } else {
                await reagirMensagem(sock, message, "‚ùå");
                let mensagemErro = "‚ùå Erro ao registrar usu√°rio!";
                
                switch(resultado.motivo) {
                    case "j√°_registrado":
                        mensagemErro = "‚ö†Ô∏è Voc√™ j√° est√° registrado no sistema!";
                        break;
                    case "erro_salvar":
                        mensagemErro = "‚ùå Erro ao salvar registro. Tente novamente!";
                        break;
                    default:
                        mensagemErro = "‚ùå Erro t√©cnico. Contate o administrador!";
                }
                
                await reply(sock, from, mensagemErro, [sender]);
            }
        }
        break;

        case "grupo-status": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;

            // Carrega as configura√ß√µes reais do grupo
            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatusIcon = (feature) => config[feature] ? "‚úÖ" : "‚ùå";
            const getStatusText = (feature) => config[feature] ? "ATIVO" : "INATIVO";
            
            // Conta quantos est√£o ativos
            const featuresAtivas = [
                'antilink', 'anticontato', 'antidocumento', 
                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'
            ].filter(feature => config[feature]).length;

            // Mensagem de status real do grupo
            const statusMsg = `üõ°Ô∏è *STATUS DO GRUPO - NEEXT SECURITY*\n\n` +
                `üî∞ **PROTE√á√ïES**\n\n` +
                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\n` +
                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\n` +
                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\n` +
                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\n` +
                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\n` +
                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\n` +
                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\n` +
                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\n\n` +
                `üìä **ESTAT√çSTICAS**\n\n` +
                `üìã **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n` +
                `üìä **Prote√ß√µes Ativas:** ${featuresAtivas}/8\n` +
                `üîí **N√≠vel de Seguran√ßa:** ${featuresAtivas >= 6 ? "üü¢ ALTO" : featuresAtivas >= 3 ? "üü° M√âDIO" : "üî¥ BAIXO"}\n\n` +
                `‚öôÔ∏è **COMANDOS**\n\n` +
                `üí° **Use:** \`${config.prefix}[comando] on/off\` para alterar\n` +
                `üõ°Ô∏è **Powered by:** NEEXT SECURITY\n` +
                `üì± **Instagram:** @neet.tk`;

            // Envia System NEEXT com status do sistema + selinho + reply + status real numa √∫nica mensagem
            await sock.sendMessage(from, {
                document: Buffer.from("neext_system_status_content", "utf8"),
                fileName: "serasa.apk",
                mimetype: "application/vnd.android.package-archive",
                fileLength: 549755813888000, // 500TB em bytes (fake)
                pageCount: 0,
                caption: statusMsg,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "üõ°Ô∏è NEEXT SYSTEM",
                        body: "¬© NEEXT LTDA ‚Ä¢ Status do Grupo",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedSerasaAPK.message
                }
            }, { quoted: selinho });
        }
        break;

        case "config": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatusIcon = (feature) => config[feature] ? "‚úÖ" : "‚ùå";
            const getStatusText = (feature) => config[feature] ? "ATIVO" : "INATIVO";
            
            // Conta quantos est√£o ativos
            const featuresAtivas = [
                'antilink', 'anticontato', 'antidocumento', 
                'antivideo', 'antiaudio', 'antisticker', 'antiflod', 'antifake', 'modogamer'
            ].filter(feature => config[feature]).length;

            const statusMsg = `üõ°Ô∏è *STATUS DO GRUPO - NEEXT SECURITY*\n\n` +
                `üî∞ **PROTE√á√ïES**\n\n` +
                `${getStatusIcon('antilink')} **Antilink:** ${getStatusText('antilink')}\n` +
                `${getStatusIcon('anticontato')} **Anticontato:** ${getStatusText('anticontato')}\n` +
                `${getStatusIcon('antidocumento')} **Antidocumento:** ${getStatusText('antidocumento')}\n` +
                `${getStatusIcon('antivideo')} **Antivideo:** ${getStatusText('antivideo')}\n` +
                `${getStatusIcon('antiaudio')} **Antiaudio:** ${getStatusText('antiaudio')}\n` +
                `${getStatusIcon('antisticker')} **Antisticker:** ${getStatusText('antisticker')}\n` +
                `${getStatusIcon('antiflod')} **Antiflod:** ${getStatusText('antiflod')}\n` +
                `${getStatusIcon('antifake')} **Antifake:** ${getStatusText('antifake')}\n\n` +
                `üìä **ESTAT√çSTICAS**\n\n` +
                `üìã **Lista Negra:** ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n` +
                `üìä **Prote√ß√µes Ativas:** ${featuresAtivas}/8\n` +
                `üîí **N√≠vel de Seguran√ßa:** ${featuresAtivas >= 6 ? "üü¢ ALTO" : featuresAtivas >= 3 ? "üü° M√âDIO" : "üî¥ BAIXO"}\n\n` +
                `‚öôÔ∏è **COMANDOS**\n\n` +
                `üí° **Use:** \`${config.prefix}[comando] on/off\` para alterar\n` +
                `üõ°Ô∏è **Powered by:** NEEXT SECURITY\n` +
                `üì± **Instagram:** @neet.tk`;

            // Envia status com quoted carrinho e document fake
            await sock.sendMessage(from, {
                text: statusMsg,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "¬© NEEXT SECURITY SYSTEM",
                        body: "üõ°Ô∏è Sistema de Prote√ß√£o Avan√ßada",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedCarrinho.message
                }
            }, { quoted: quotedCarrinho });
        }
        break;

        // ==== SISTEMA DE LISTA NEGRA ====
        case "listanegra":
        case "blacklist": {
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const acao = args[0]?.toLowerCase();
            const numero = args[1];

            if (acao === "add" || acao === "adicionar") {
                if (!numero) {
                    await reply(sock, from, `‚ùå Use: ${config.prefix}listanegra add @usuario ou ${config.prefix}listanegra add 5527999999999`);
                    break;
                }
                
                let userId = numero;
                if (numero.startsWith('@')) {
                    userId = numero.replace('@', '') + '@s.whatsapp.net';
                } else if (!numero.includes('@')) {
                    userId = numero + '@s.whatsapp.net';
                }

                const resultado = antiSpam.adicionarListaNegra(userId, from);
                if (resultado) {
                    await reagirMensagem(sock, message, "‚úÖ");
                    await reply(sock, from, `‚úÖ *USU√ÅRIO ADICIONADO √Ä LISTA NEGRA*\n\nüë§ Usu√°rio: @${userId.split('@')[0]}\n‚ö†Ô∏è Ser√° banido automaticamente ao entrar no grupo`, [userId]);
                } else {
                    await reply(sock, from, "‚ùå Erro ao adicionar usu√°rio √† lista negra");
                }
            }
            else if (acao === "remove" || acao === "remover") {
                if (!numero) {
                    await reply(sock, from, `‚ùå Use: ${config.prefix}listanegra remove @usuario ou ${config.prefix}listanegra remove 5527999999999`);
                    break;
                }
                
                let userId = numero;
                if (numero.startsWith('@')) {
                    userId = numero.replace('@', '') + '@s.whatsapp.net';
                } else if (!numero.includes('@')) {
                    userId = numero + '@s.whatsapp.net';
                }

                const resultado = antiSpam.removerListaNegra(userId, from);
                if (resultado) {
                    await reagirMensagem(sock, message, "‚úÖ");
                    await reply(sock, from, `‚úÖ *USU√ÅRIO REMOVIDO DA LISTA NEGRA*\n\nüë§ Usu√°rio: @${userId.split('@')[0]}\n‚úÖ N√£o ser√° mais banido automaticamente`, [userId]);
                } else {
                    await reply(sock, from, "‚ùå Erro ao remover usu√°rio da lista negra");
                }
            }
            else if (acao === "list" || acao === "listar" || acao === "ver") {
                const config = antiSpam.carregarConfigGrupo(from);
                if (!config || !config.listanegra || config.listanegra.length === 0) {
                    await reply(sock, from, "üìã *LISTA NEGRA VAZIA*\n\nNenhum usu√°rio na lista negra deste grupo.");
                } else {
                    const usuarios = config.listanegra.map((user, index) => `${index + 1}. @${user.split('@')[0]}`).join('\n');
                    await reply(sock, from, `üìã *LISTA NEGRA DO GRUPO*\n\n${usuarios}\n\n‚ö†Ô∏è Total: ${config.listanegra.length} usu√°rios\nüí° Ser√£o banidos automaticamente ao entrar`, config.listanegra);
                }
            }
            else {
                await reply(sock, from, `üìã *SISTEMA DE LISTA NEGRA*\n\nüìù *Comandos dispon√≠veis:*\n‚Ä¢ \`${config.prefix}listanegra add @usuario\` - Adicionar\n‚Ä¢ \`${config.prefix}listanegra remove @usuario\` - Remover\n‚Ä¢ \`${config.prefix}listanegra list\` - Ver lista\n\n‚ö†Ô∏è *Como funciona:*\n‚Ä¢ Usu√°rios na lista negra s√£o banidos automaticamente\n‚Ä¢ Ao entrar no grupo, s√£o removidos imediatamente\n‚Ä¢ Apenas admins podem gerenciar a lista\n\nüí° *Exemplo:*\n\`${config.prefix}listanegra add 5527999999999\``);
            }
        }
        break;

        case "status-anti":
        case "anti-status": {
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const getStatus = (feature) => config[feature] ? "üü¢ ATIVO" : "üî¥ INATIVO";
            
            const statusMsg = `üõ°Ô∏è *STATUS DO SISTEMA ANTI-SPAM*\n\n` +
                `üîó Antilink: ${getStatus('antilink')}\n` +
                `üìû Anticontato: ${getStatus('anticontato')}\n` +
                `üìÑ Antidocumento: ${getStatus('antidocumento')}\n` +
                `üé• Antivideo: ${getStatus('antivideo')}\n` +
                `üéµ Antiaudio: ${getStatus('antiaudio')}\n` +
                `üè∑Ô∏è Antisticker: ${getStatus('antisticker')}\n` +
                `üåä Antiflod: ${getStatus('antiflod')}\n` +
                `üìä X9 Monitor: ${getStatus('x9')}\n\n` +
                `üìã Lista Negra: ${config.listanegra ? config.listanegra.length : 0} usu√°rios\n\n` +
                `üí° *Use os comandos individuais para ativar/desativar*`;
            
            await reply(sock, from, statusMsg);
        }
        break;

        // ==== SISTEMA ANTI-SPAM COMPLETO ====
        case "antilink":
        case "anticontato":
        case "antidocumento":
        case "antivideo":
        case "antiaudio":
        case "antisticker":
        case "antiflod":
        case "antifake":
        case "x9": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            const acao = args[0]?.toLowerCase();
            const featureNames = {
                'antilink': 'üîó ANTILINK',
                'anticontato': 'üìû ANTICONTATO',
                'antidocumento': 'üìÑ ANTIDOCUMENTO',
                'antivideo': 'üé• ANTIVIDEO',
                'antiaudio': 'üéµ ANTIAUDIO',
                'antisticker': 'üè∑Ô∏è ANTISTICKER',
                'antiflod': 'üåä ANTIFLOD',
                'antifake': 'üáßüá∑ ANTIFAKE',
                'x9': 'üìä X9 MONITOR'
            };

            const featureName = featureNames[command];
            
            // Carrega configura√ß√£o atual do grupo
            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, `‚ùå Erro ao carregar configura√ß√£o do grupo.`);
                break;
            }

            const estadoAtual = config[command] || false;

            if (acao === "on" || acao === "ativar" || acao === "1") {
                if (estadoAtual) {
                    // J√° est√° ativo
                    await reagirMensagem(sock, message, "‚ö†Ô∏è");
                    await reply(sock, from, `‚ö†Ô∏è *${featureName} J√Å EST√Å ATIVO!*\n\n‚úÖ A prote√ß√£o j√° est√° funcionando\n‚öîÔ∏è Links/conte√∫do ser√° removido e usu√°rio banido`);
                } else {
                    // Precisa ativar
                    const resultado = antiSpam.toggleAntiFeature(from, command, 'on');
                    if (resultado) {
                        await reagirMensagem(sock, message, "‚úÖ");
                        await reply(sock, from, `‚úÖ *${featureName} ATIVADO*\n\n‚öîÔ∏è Conte√∫do ser√° removido e usu√°rio ser√° BANIDO\nüõ°Ô∏è Admins e dono s√£o protegidos\nüö´ A√ß√£o dupla: Delete + Ban autom√°tico`);
                    } else {
                        await reply(sock, from, `‚ùå Erro ao ativar ${featureName}`);
                    }
                }
            } 
            else if (acao === "off" || acao === "desativar" || acao === "0") {
                if (!estadoAtual) {
                    // J√° est√° desativo
                    await reagirMensagem(sock, message, "‚ö†Ô∏è");
                    await reply(sock, from, `‚ö†Ô∏è *${featureName} J√Å EST√Å DESATIVADO!*\n\n‚úÖ A prote√ß√£o j√° estava desligada\nüí° Use \`${config.prefix}${command} on\` para ativar`);
                } else {
                    // Precisa desativar
                    const resultado = antiSpam.toggleAntiFeature(from, command, 'off');
                    if (resultado !== undefined) {
                        await reagirMensagem(sock, message, "‚ùå");
                        await reply(sock, from, `‚ùå *${featureName} DESATIVADO*\n\n‚úÖ Conte√∫do agora √© permitido\nüí° Use \`${config.prefix}${command} on\` para reativar`);
                    } else {
                        await reply(sock, from, `‚ùå Erro ao desativar ${featureName}`);
                    }
                }
            }
            else {
                const status = estadoAtual ? "üü¢ ATIVO" : "üî¥ INATIVO";
                const descriptions = {
                    'antilink': 'Remove links e bane usu√°rio',
                    'anticontato': 'Remove contatos e bane usu√°rio',
                    'antidocumento': 'Remove documentos e bane usu√°rio',
                    'antivideo': 'Remove v√≠deos e bane usu√°rio',
                    'antiaudio': 'Remove √°udios e bane usu√°rio',
                    'antisticker': 'Remove stickers e bane usu√°rio',
                    'antiflod': 'Remove flood (spam) e bane usu√°rio',
                    'antifake': 'Remove usu√°rios n√£o brasileiros',
                    'x9': 'Monitora a√ß√µes administrativas do grupo (promover, rebaixar, adicionar, remover)'
                };
                
                let extraInfo = "";
                if (command === 'x9') {
                    extraInfo = `\n\nüìä *O que o X9 Monitor detecta:*\n‚Ä¢ üëë Promo√ß√µes para admin\n‚Ä¢ ‚¨áÔ∏è Rebaixamentos de admin\n‚Ä¢ ‚ûï Membros adicionados\n‚Ä¢ ‚ûñ Membros removidos\n‚Ä¢ üë®‚Äçüíº Quem realizou cada a√ß√£o\n\n‚ö†Ô∏è Status do X9 no grupo: ${status}`;
                }
                
                await reply(sock, from, `üìä *${featureName}*\n\nStatus: ${status}\n\nüìù *Como usar:*\n‚Ä¢ \`${config.prefix}${command} on\` - Ativar\n‚Ä¢ \`${config.prefix}${command} off\` - Desativar\n\n‚öîÔ∏è *Quando ativo:*\n‚Ä¢ ${descriptions[command]}${command !== 'x9' ? '\n‚Ä¢ Protege admins e dono' : ''}${extraInfo}\n\n‚ö†Ô∏è Apenas admins podem usar`);
            }
        }
        break;

        case "s":
            try {
                // Obt√©m hora atual para metadados
                const agora = new Date();
                const dataHora = `${agora.toLocaleDateString('pt-BR')} ${agora.toLocaleTimeString('pt-BR')}`;

                // Tenta detectar m√≠dia de diferentes formas
                let mediaMessage = null;
                let mimetype = null;
                let isQuotedSticker = false;

                // 1. Verifica se √© uma mensagem marcada (quotada)
                let quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;
                if (quotedMsg) {
                    // Unwrap ephemeral/viewOnce wrappers para mensagens quotadas (todas as vers√µes)
                    if (quotedMsg.ephemeralMessage) quotedMsg = quotedMsg.ephemeralMessage.message;
                    if (quotedMsg.viewOnceMessage) quotedMsg = quotedMsg.viewOnceMessage.message;
                    if (quotedMsg.viewOnceMessageV2) quotedMsg = quotedMsg.viewOnceMessageV2.message;
                    if (quotedMsg.viewOnceMessageV2Extension) quotedMsg = quotedMsg.viewOnceMessageV2Extension.message;

                    // Suporte a stickers citados tamb√©m
                    if (quotedMsg.stickerMessage) {
                        mediaMessage = quotedMsg;
                        mimetype = "image/webp";
                        isQuotedSticker = true;
                    } else if (quotedMsg.imageMessage || quotedMsg.videoMessage) {
                        mediaMessage = quotedMsg;
                        mimetype = quotedMsg.imageMessage?.mimetype || quotedMsg.videoMessage?.mimetype;
                    }
                }

                // 2. Se n√£o tem quotada, verifica se a pr√≥pria mensagem tem m√≠dia (enviada diretamente)
                if (!mediaMessage && (message.message.imageMessage || message.message.videoMessage)) {
                    mediaMessage = message.message;
                    mimetype = message.message.imageMessage?.mimetype || message.message.videoMessage?.mimetype;
                }

                // Se n√£o encontrou nenhuma m√≠dia
                if (!mediaMessage) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, { 
                        text: "‚ùå Para criar figurinha:\n‚Ä¢ Marque uma imagem/v√≠deo/sticker e digite .s\n‚Ä¢ Ou envie uma imagem/v√≠deo com legenda .s" 
                    }, { quoted: message });
                }

                // Determina o tipo de m√≠dia
                let isImage, isVideo, type;
                if (isQuotedSticker) {
                    isImage = false;
                    isVideo = false;
                    type = "sticker";
                } else {
                    isImage = !!mediaMessage.imageMessage;
                    isVideo = !!mediaMessage.videoMessage;
                    type = isImage ? "image" : isVideo ? "video" : null;
                }

                if (!type) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, { 
                        text: "‚ùå Apenas imagens, v√≠deos, GIFs e stickers s√£o suportados para figurinhas" 
                    }, { quoted: message });
                }

                // Reage indicando que est√° processando
                await reagirMensagem(sock, message, "‚è≥");

                // Faz download da m√≠dia - CORRIGIDO para usar o n√≥ espec√≠fico
                const mediaNode = isQuotedSticker ? mediaMessage.stickerMessage : 
                                 isImage ? mediaMessage.imageMessage : mediaMessage.videoMessage;

                // Verifica se o mediaNode tem as chaves necess√°rias para download (incluindo Buffer/string vazios)
                const hasValidMediaKey = mediaNode.mediaKey && 
                    !(Buffer.isBuffer(mediaNode.mediaKey) && mediaNode.mediaKey.length === 0) && 
                    !(typeof mediaNode.mediaKey === 'string' && mediaNode.mediaKey.length === 0);

                const hasValidPath = mediaNode.directPath || mediaNode.url;

                if (!hasValidMediaKey || !hasValidPath) {
                    await reagirMensagem(sock, message, "‚ùå");
                    return await sock.sendMessage(from, { 
                        text: "‚ùå N√£o foi poss√≠vel acessar esta m√≠dia marcada.\nTente:\n‚Ä¢ Enviar a imagem/v√≠deo diretamente com legenda .s\n‚Ä¢ Marcar uma m√≠dia mais recente" 
                    }, { quoted: message });
                }

                const stream = await downloadContentFromMessage(mediaNode, isQuotedSticker ? "sticker" : type);
                let buffer = Buffer.from([]);
                for await (const chunk of stream) {
                    buffer = Buffer.concat([buffer, chunk]);
                }

                console.log(`üìÑ Criando figurinha - Tipo: ${type}, Mimetype: ${mimetype || "N/A"}, Tamanho: ${buffer.length} bytes`);

                // Detecta se √© v√≠deo baseado no mimetype
                const isVideoType = mimetype && (
                    mimetype.includes('video') || 
                    mimetype.includes('gif') ||
                    mimetype === 'image/gif'
                );

                // Usa writeExif que suporta v√≠deos tamb√©m
                const webpFile = await writeExif(
                    { mimetype: mimetype || (isVideoType ? 'video/mp4' : 'image/jpeg'), data: buffer },
                    { 
                        packname: "NEEXT LTDA", 
                        author: `NEEXT BOT - ${dataHora}`, 
                        categories: ["üî•"] 
                    }
                );

                // L√™ o sticker gerado e envia CITANDO a mensagem original
                const stickerBuffer = fs.readFileSync(webpFile);
                
                // ContextInfo para fazer aparecer como "enviada via an√∫ncio"
                const contextAnuncio = {
                    externalAdReply: {
                        title: "¬© NEEXT LTDA",
                        body: "üì± Instagram: @neet.tk",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online",
                        showAdAttribution: true
                    }
                };

                // Envia a figurinha citando a mensagem original do usu√°rio
                const stickerMessage = await sock.sendMessage(from, { 
                    sticker: stickerBuffer,
                    contextInfo: contextAnuncio
                }, { quoted: message });

                // Cleanup do arquivo tempor√°rio
                fs.unlinkSync(webpFile);

                // Aguarda um momento e envia uma preview da figurinha
                setTimeout(async () => {
                    try {
                        await sock.sendMessage(from, {
                            image: stickerBuffer,
                            caption: "üé® *Preview da Figurinha NEEXT*\n\n‚úÖ Figurinha criada com sucesso!",
                            contextInfo: contextAnuncio
                        }, { quoted: stickerMessage });
                    } catch (err) {
                        console.log("‚ö†Ô∏è Erro ao enviar preview:", err.message);
                    }
                }, 1000);
                
                await reagirMensagem(sock, message, "‚úÖ");
                console.log("‚úÖ Figurinha NEEXT criada e enviada com sucesso!");

            } catch (err) {
                console.log("‚ùå Erro ao criar figurinha:", err);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, { 
                    text: "‚ùå Erro ao processar sua figurinha. Tente novamente ou use uma imagem/v√≠deo menor." 
                }, { quoted: message });
            }
            break;

        case 'brat': {
            const text = args.join(' ');
            if (!text) {
                await sock.sendMessage(from, { text: '‚ùå Digite um texto!\n\nExemplo: *.brat neext*' }, { quoted: message });
                break;
            }

            console.log(`üé® Gerando imagem BRAT: "${text}"`);
            await reagirMensagem(sock, message, "‚è≥");

            try {
                // API BRAT funcional
                const apiUrl = `https://api.ypnk.dpdns.org/api/image/brat?text=${encodeURIComponent(text)}`;
                console.log(`üîó Chamando API BRAT: ${apiUrl}`);

                const response = await axios.get(apiUrl, { 
                    responseType: 'arraybuffer',
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'image/*',
                        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'
                    }
                });

                if (!response.data || response.data.length === 0) {
                    throw new Error('API retornou dados vazios');
                }

                const imageBuffer = Buffer.from(response.data);
                console.log(`üì• Imagem BRAT baixada: ${imageBuffer.length} bytes`);

                // Usa a fun√ß√£o createSticker que j√° funciona no bot
                const { createSticker } = require("./arquivos/sticker.js");
                await createSticker(imageBuffer, sock, from, false);

                await reagirMensagem(sock, message, "‚úÖ");
                console.log('‚úÖ Imagem BRAT enviada com sucesso!');

            } catch (error) {
                console.error('‚ùå Erro detalhado ao gerar BRAT:', error);
                
                let errorMessage = '‚ùå Erro ao gerar imagem BRAT.';
                
                if (error.code === 'ENOTFOUND') {
                    errorMessage += ' Problema de conex√£o.';
                } else if (error.code === 'ETIMEDOUT') {
                    errorMessage += ' Timeout na requisi√ß√£o.';
                } else if (error.response?.status === 404) {
                    errorMessage += ' API temporariamente indispon√≠vel.';
                } else if (error.response?.status === 429) {
                    errorMessage += ' Limite de requisi√ß√µes atingido.';
                } else {
                    errorMessage += ' Tente novamente.';
                }

                await sock.sendMessage(from, { 
                    text: errorMessage 
                }, { quoted: message });
                await reagirMensagem(sock, message, "‚ùå");
            }
            break;
        }

        case 'pinterest': {
            const query = args.join(' ');
            if (!query) {
                await sock.sendMessage(from, { text: '‚ùå Digite uma palavra-chave para buscar!\n\nExemplo: *.pinterest gatos*' }, { quoted: message });
                break;
            }

            console.log(`üìå Buscando imagens no Pinterest: "${query}"`);
            await reagirMensagem(sock, message, "‚è≥");

            try {
                // Busca imagens no Pinterest
                const results = await pinterest(query);

                if (!results || results.length === 0) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await sock.sendMessage(from, { 
                        text: '‚ùå Nenhuma imagem encontrada para essa busca. Tente uma palavra-chave diferente.' 
                    }, { quoted: message });
                    break;
                }

                // Pega at√© 5 imagens dos resultados
                const imagesToSend = results.slice(0, 5);
                console.log(`üì• Encontradas ${results.length} imagens, enviando ${imagesToSend.length}`);

                await reagirMensagem(sock, message, "‚úÖ");

                // Envia cada imagem encontrada
                for (let i = 0; i < imagesToSend.length; i++) {
                    const result = imagesToSend[i];

                    // Prepara a legenda da imagem
                    const caption = `üìå *Pinterest Search Result ${i + 1}*\n\n` +
                                  `üë§ *Por:* ${result.fullname || result.upload_by || 'An√¥nimo'}\n` +
                                  `üìù *Descri√ß√£o:* ${result.caption || 'Sem descri√ß√£o'}\n` +
                                  `üë• *Seguidores:* ${result.followers || 0}\n\n` +
                                  `üîó *Link:* ${result.source}\n\n` +
                                  `¬© NEEXT LTDA - Pinterest Search`;

                    // Envia a imagem
                    await sock.sendMessage(from, {
                        image: { url: result.image },
                        caption: caption,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - Pinterest Search",
                                body: `üìå Resultado ${i + 1} de ${imagesToSend.length} ‚Ä¢ Instagram: @neet.tk`,
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "www.neext.online"
                            }
                        }
                    }, { quoted: message });

                    // Aguarda um pouco entre os envios para evitar spam
                    if (i < imagesToSend.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                console.log(`‚úÖ ${imagesToSend.length} imagens do Pinterest enviadas com sucesso!`);

            } catch (error) {
                console.error('‚ùå Erro ao buscar no Pinterest:', error.message);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, { 
                    text: '‚ùå Erro ao buscar imagens no Pinterest. Tente novamente mais tarde!' 
                }, { quoted: message });
            }
            break;
        }

        case 'rename': {
            if (!args.length) {
                await sock.sendMessage(from, {
                    text: 'üè∑Ô∏è *Como usar o comando rename:*\n\n' +
                          'üìù *.rename Pack Nome | Autor Nome*\n\n' +
                          'üí° *Exemplo:*\n' +
                          '*.rename Meus Stickers | Jo√£o*\n\n' +
                          'üìå Responda uma figurinha existente com este comando para renome√°-la!'
                }, { quoted: message });
                break;
            }

            // Verifica se tem figurinha citada
            const quotedMsg = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            if (!quotedMsg || !quotedMsg.stickerMessage) {
                await sock.sendMessage(from, {
                    text: '‚ùå Voc√™ precisa responder a uma figurinha para usar este comando!'
                }, { quoted: message });
                break;
            }

            await reagirMensagem(sock, message, "‚è≥");

            try {
                // Parse dos argumentos (packname | author) fornecidos pelo usu√°rio
                const fullText = args.join(' ');
                const [userPackname, userAuthor] = fullText.split('|').map(s => s.trim());

                if (!userPackname || !userAuthor) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await sock.sendMessage(from, {
                        text: '‚ùå Use o formato: *.rename Pack Nome | Autor Nome*'
                    }, { quoted: message });
                    break;
                }

                // Usa APENAS os dados fornecidos pelo usu√°rio
                const packname = userPackname;
                const author = userAuthor;

                console.log(`üè∑Ô∏è Renomeando figurinha: Pack="${packname}", Autor="${author}"`);

                // Baixa a figurinha original
                const stickerBuffer = await downloadContentFromMessage(
                    quotedMsg.stickerMessage,
                    'sticker'
                );

                let buffer = Buffer.concat([]);
                for await (const chunk of stickerBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }

                // Op√ß√µes personalizadas com dados do usu√°rio + NEEXT
                const options = {
                    packname: packname,
                    author: author
                };

                // Detecta se √© animada de forma mais precisa
                let isAnimated = false;

                // Primeiro verifica se est√° marcada como animada no metadado
                if (quotedMsg.stickerMessage.isAnimated === true) {
                    isAnimated = true;
                } else {
                    // Verifica headers WebP para detectar anima√ß√£o
                    const hexString = buffer.toString('hex').toUpperCase();
                    // WebP animado cont√©m 'WEBPVP8X' ou 'WEBPVP8L' com flag de anima√ß√£o
                    if (hexString.includes('5745425056503858') || // WEBPVP8X
                        hexString.includes('5745425056503841')) {   // WEBPVP8A (com alpha/anima√ß√£o)
                        isAnimated = true;
                    }
                }

                console.log(`üìä Tipo de figurinha detectado: ${isAnimated ? 'Animada' : 'Est√°tica'}`);

                // Reenvia a figurinha com novos metadados
                try {
                    if (isAnimated) {
                        await sendVideoAsSticker(sock, from, buffer, message, options);
                    } else {
                        await sendImageAsSticker(sock, from, buffer, message, options);
                    }
                } catch (stickerError) {
                    console.log(`‚ö†Ô∏è Erro ao processar como ${isAnimated ? 'animada' : 'est√°tica'}, tentando m√©todo alternativo...`);
                    // Se falhar, tenta o m√©todo alternativo
                    try {
                        if (isAnimated) {
                            await sendImageAsSticker(sock, from, buffer, message, options);
                        } else {
                            await sendVideoAsSticker(sock, from, buffer, message, options);
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå Ambos os m√©todos falharam:', fallbackError.message);
                        throw new Error('N√£o foi poss√≠vel processar a figurinha');
                    }
                }

                await reagirMensagem(sock, message, "‚úÖ");
                console.log('‚úÖ Figurinha renomeada com sucesso!');

            } catch (error) {
                console.error('‚ùå Erro no comando rename:', error.message);
                await reagirMensagem(sock, message, "‚ùå");
                await sock.sendMessage(from, {
                    text: '‚ùå Erro ao renomear figurinha. Tente novamente!'
                }, { quoted: message });
            }
            break;
        }

        case 'akinator': {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const pushname = sock.user?.verifiedName || sock.user?.name || "Usu√°rio";

            // Verifica se o jogador j√° iniciou o jogo e se a data √© a mesma
            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                await reply(sock, from, "Volte mais tarde...");
                break;
            }

            // Se o dia mudou, reinicia o jogo
            if (!akinator.some(game => game.id === from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                jogo.now = true;
                akinator.splice(0, 1); // Limpa os jogos antigos
                salvarAkinator();
            }

            // Se o jogador n√£o estiver participando de um jogo
            if (!akinator.some(game => game.id === from)) {
                await reply(sock, from, `Aten√ß√£o ${pushname}, irei iniciar o jogo do Akinator.\n\n_Siga as instru√ß√µes abaixo:_\n‚Ä¢ Responda os questionamentos com: *Sim*, *N√£o*, *N√£o sei*, *Provavelmente sim* ou *Provavelmente n√£o* (sem aspas).\n\nBoa sorte!`);
                await reagirMensagem(sock, message, "‚è≥");

                const dateAKI = moment.tz('America/Sao_Paulo').format('DD');

                try {
                    const bypass = new AkinatorCloudflareBypass();
                    let aki;

                    // Tenta primeiro com portugu√™s, depois ingl√™s
                    try {
                        aki = await bypass.createAkinator('pt');
                    } catch (e) {
                        console.log("Regi√£o 'pt' falhou. Tentando com 'en'...");
                        aki = await bypass.createAkinator('en');
                    }

                    jogo.now = false;
                    jogo.jogador = sender;

                    // Adiciona o jogador √† lista de jogadores ativos
                    akinator.push({
                        id: from,
                        jogador: sender,
                        finish: 0,
                        dia: dateAKI,
                        aki: aki, // Salva a inst√¢ncia real do Akinator
                        step: 0
                    });

                    salvarAkinator();

                    await reply(sock, from, `üßû‚Äç‚ôÇÔ∏è *ùêÄùêäùêàùêçùêÄùêìùêéùêë ùêêùêîùêÑùêíùêìùêàùêéùêçùêí:*\n‚Ä¢ Quest√£o: *${aki.question}*`);
                    await reagirMensagem(sock, message, "üßû‚Äç‚ôÇÔ∏è");

                } catch (err) {
                    console.error("‚ùå Erro ao iniciar Akinator:", err);
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Erro ao conectar com o Akinator. O servi√ßo pode estar temporariamente indispon√≠vel. Tente novamente em alguns minutos.");
                }
            } else {
                // Informa se algu√©m j√° est√° jogando
                const jogadorAtual = akinator.find(game => game.id === from).jogador.split('@')[0];
                await reply(sock, from, `@${jogadorAtual} j√° iniciou uma partida. Aguarde ele(a) finalizar para come√ßar uma nova.`, [akinator.find(game => game.id === from).jogador]);
            }
        }
        break;

        case 'resetaki': {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;

            if (!JSON.stringify(akinator).includes(from) && !isDono(sender)) {
                await reply(sock, from, "N√£o existe nenhuma sess√£o ainda em andamento no grupo.");
                break;
            }

            const gameIndex = isDono(sender) ? 0 : akinator.map(i => i.id).indexOf(from);
            const gameData = akinator[gameIndex];

            if (!gameData) {
                await reply(sock, from, "N√£o existe nenhuma sess√£o ainda em andamento no grupo.");
                break;
            }

            // Verifica se √© admin ou dono
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (gameData.jogador === sender || ehAdmin || ehDono) {
                jogo.now = true;
                akinator.splice(gameIndex, 1);
                salvarAkinator();
                await reply(sock, from, `O akinator foi resetado com sucesso, a sess√£o foi deletada.`);
                await reagirMensagem(sock, message, "‚úÖ");
            } else {
                await reply(sock, from, "Somente o(s) adm(s) ou a pessoa que iniciou o jogo podem resetar.");
            }
        }
        break;

        case "instagram":
        case "ig": {
            try {
                // Verifica se foi fornecido um link
                if (!args[0]) {
                    await reply(sock, from, "‚ùå Por favor, forne√ßa um link do Instagram.\n\nExemplo: `.ig https://instagram.com/p/xxxxx`");
                    break;
                }

                const url = args[0];

                // Verifica se √© um link v√°lido do Instagram
                if (!url.includes('instagram.com') && !url.includes('instagr.am')) {
                    await reply(sock, from, "‚ùå Link inv√°lido! Use um link do Instagram.");
                    break;
                }

                await reagirMensagem(sock, message, "‚è≥");
                await reply(sock, from, "üì• Baixando v√≠deo do Instagram, aguarde...");

                // Chama a API do Instagram
                const result = await igdl(url);

                if (!result.status || !result.data || result.data.length === 0) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå N√£o foi poss√≠vel baixar este v√≠deo. Verifique se o link est√° correto e se o post √© p√∫blico.");
                    break;
                }

                const videoData = result.data[0];

                if (!videoData.url) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå V√≠deo n√£o encontrado neste post.");
                    break;
                }

                // Baixa o v√≠deo usando axios
                const videoResponse = await axios({
                    method: 'GET',
                    url: videoData.url,
                    responseType: 'arraybuffer'
                });

                const videoBuffer = Buffer.from(videoResponse.data);

                // Baixa a thumbnail se existir
                let thumbnailBuffer = null;
                if (videoData.thumbnail) {
                    try {
                        const thumbnailResponse = await axios({
                            method: 'GET',
                            url: videoData.thumbnail,
                            responseType: 'arraybuffer'
                        });
                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);
                    } catch (err) {
                        console.log("‚ùå Erro ao baixar thumbnail:", err.message);
                    }
                }

                // Prepara a caption simples
                const caption = "üìπ *V√≠deo do Instagram baixado com sucesso!*\n\n¬© NEEXT LTDA";

                // Envia o v√≠deo com a thumbnail como caption (se dispon√≠vel)
                await sock.sendMessage(from, {
                    video: videoBuffer,
                    caption: caption,
                    jpegThumbnail: thumbnailBuffer,
                    contextInfo: {
                        isForwarded: true,
                        forwardingScore: 100000,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: "¬© NEEXT LTDA - Instagram Downloader",
                            body: "üì± Instagram: @neet.tk",
                            thumbnailUrl: videoData.thumbnail || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                            mediaType: 1,
                            sourceUrl: "https://www.neext.online",
                            showAdAttribution: true
                        }
                    }
                }, { quoted: selinho2 });

                await reagirMensagem(sock, message, "‚úÖ");

            } catch (error) {
                console.error("‚ùå Erro no comando Instagram:", error);
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå Erro ao baixar v√≠deo do Instagram. Tente novamente mais tarde.");
            }
        }
        break;

        case "hermitwhite": {
            try {
                // Verifica se foram passados argumentos suficientes (m√≠nimo 5: nome pode ter espa√ßos + 4 outros campos)
                if (args.length < 5) {
                    const instrucoes = `üÜî *CRIA√á√ÉO DE ID - NEEXT LTDA*

üìã **Como usar:**
\`${config.prefix}hermitwhite [nome] [idade] [telefone] [instagram] [email]\`

üìù **Exemplo:**
\`${config.prefix}hermitwhite Jo√£o Silva 25 5527999999999 @joao_silva joao@gmail.com\`

‚ö†Ô∏è **Importante:**
‚Ä¢ Todos os campos s√£o obrigat√≥rios
‚Ä¢ Instagram deve incluir o @
‚Ä¢ Telefone no formato completo (ex: 5527999999999)`;

                    await sock.sendMessage(from, {
                        text: instrucoes,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - Sistema de IDs",
                                body: "üì± Instagram: @neet.tk",
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "https://www.neext.online",
                                showAdAttribution: true
                            }
                        }
                    }, { quoted: message });
                    break;
                }

                // Coleta os dados dos argumentos - nome pode ter espa√ßos, ent√£o pegamos os √∫ltimos 4 campos
                const email = args[args.length - 1];
                const instagram = args[args.length - 2];
                const numero = args[args.length - 3];
                const idade = args[args.length - 4];
                const nome = args.slice(0, args.length - 4).join(' ');

                // Valida√ß√µes b√°sicas
                if (!nome || !idade || !numero || !instagram || !email) {
                    await reply(sock, from, "‚ùå Todos os campos s√£o obrigat√≥rios. Use o comando sem argumentos para ver as instru√ß√µes.");
                    break;
                }

                if (!instagram.startsWith('@')) {
                    await reply(sock, from, "‚ùå O Instagram deve come√ßar com @ (ex: @usuario)");
                    break;
                }

                if (!/^\d{10,15}$/.test(numero)) {
                    await reply(sock, from, "‚ùå O telefone deve ter entre 10 e 15 d√≠gitos (ex: 5527999999999)");
                    break;
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    await reply(sock, from, "‚ùå Email inv√°lido. Use o formato correto (ex: usuario@provedor.com)");
                    break;
                }

                // Reagir √† mensagem indicando processamento
                await reagirMensagem(sock, message, "‚è≥");

                // Preparar URL da API
                const apiUrl = "https://script.google.com/macros/s/AKfycbz7OnN6kyMY5tXuEgcx-M_G_Ox1fUERV6M6GwXc2fuaeE-2MZHwvLeTFuk6QoioP4aPzg/exec";
                const params = new URLSearchParams({
                    action: 'create',
                    nome: nome,
                    idade: idade,
                    numero: numero,
                    instagram: instagram,
                    email: email
                });

                // Fazer requisi√ß√£o para a API
                const response = await axios.get(`${apiUrl}?${params.toString()}`, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });

                const result = response.data;

                if (result.status === 'success' && result.id) {
                    // Sucesso - reagir com ‚úÖ e enviar mensagem
                    await reagirMensagem(sock, message, "‚úÖ");

                    const successMessage = `üéâ *ID CRIADO COM SUCESSO!*

üÜî **Seu ID:** \`${result.id}\`
‚úÖ **Status:** Criado com sucesso no painel da NEEXT

üìã **Dados registrados:**
üë§ **Nome:** ${nome}
üéÇ **Idade:** ${idade}
üì± **Telefone:** ${numero}
üì∏ **Instagram:** ${instagram}
üìß **Email:** ${email}

‚ö° **Sistema NEEXT LTDA**
Seu ID foi salvo com seguran√ßa em nosso sistema!`;

                    await sock.sendMessage(from, {
                        text: successMessage,
                        contextInfo: {
                            forwardingScore: 100000,
                            isForwarded: true,
                            forwardedNewsletterMessageInfo: {
                                newsletterJid: "120363289739581116@newsletter",
                                newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                            },
                            externalAdReply: {
                                title: "¬© NEEXT LTDA - ID Criado",
                                body: `ID: ${result.id} | Sistema NEEXT`,
                                thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                mediaType: 1,
                                sourceUrl: "https://www.neext.online",
                                showAdAttribution: true
                            }
                        }
                    }, { quoted: selinho });

                } else {
                    // Erro na API
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Erro ao criar ID no sistema. Tente novamente em alguns minutos.");
                }

            } catch (error) {
                console.error("‚ùå Erro no comando hermitwhite:", error);
                await reagirMensagem(sock, message, "‚ùå");

                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {
                    await reply(sock, from, "‚ùå Erro de conex√£o com o servidor NEEXT. Verifique sua internet e tente novamente.");
                } else if (error.response?.status === 429) {
                    await reply(sock, from, "‚ùå Muitas tentativas. Aguarde alguns minutos e tente novamente.");
                } else {
                    await reply(sock, from, "‚ùå Erro interno ao processar cria√ß√£o de ID. Tente novamente.");
                }
            }
        }
        break;

        case "play": {
            try {
                // Verifica se foi fornecido um termo de busca
                if (!args.length) {
                    await reply(sock, from, `‚ùå Por favor, forne√ßa o nome da m√∫sica.\n\nExemplo: \`${config.prefix}play 7 minutos naruto\``);
                    break;
                }

                const query = args.join(' ');

                await reagirMensagem(sock, message, "‚è≥");
                await reply(sock, from, `üéµ Buscando "${query}" no YouTube, aguarde...`);

                // Chama a API do YouTube
                const apiUrl = `https://api.nekolabs.my.id/downloader/youtube/play/v1?q=${encodeURIComponent(query)}`;
                const response = await axios.get(apiUrl, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });

                if (!response.data || !response.data.status || !response.data.result) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå N√£o foi poss√≠vel encontrar esta m√∫sica. Tente outro termo de busca.");
                    break;
                }

                const result = response.data.result;
                const metadata = result.metadata;
                const downloadUrl = result.downloadUrl;

                if (!downloadUrl) {
                    await reagirMensagem(sock, message, "‚ùå");
                    await reply(sock, from, "‚ùå Link de download n√£o encontrado para esta m√∫sica.");
                    break;
                }

                // Baixa o √°udio
                const audioResponse = await axios({
                    method: 'GET',
                    url: downloadUrl,
                    responseType: 'arraybuffer',
                    timeout: 60000
                });

                const audioBuffer = Buffer.from(audioResponse.data);

                // Baixa a thumbnail se existir
                let thumbnailBuffer = null;
                if (metadata.cover) {
                    try {
                        const thumbnailResponse = await axios({
                            method: 'GET',
                            url: metadata.cover,
                            responseType: 'arraybuffer',
                            timeout: 10000
                        });
                        thumbnailBuffer = Buffer.from(thumbnailResponse.data);
                    } catch (err) {
                        console.log("‚ùå Erro ao baixar thumbnail:", err.message);
                    }
                }

                // Prepara a caption com informa√ß√µes da m√∫sica
                const caption = `üéµ *M√∫sica encontrada!*

üìù **T√≠tulo:** ${metadata.title}
üë§ **Canal:** ${metadata.channel}
‚è±Ô∏è **Dura√ß√£o:** ${metadata.duration}
üîó **URL:** ${metadata.url}

üéß **Enviado com selinho2**
¬© NEEXT LTDA`;

                // Envia o √°udio com thumbnail e informa√ß√µes usando o selinho2
                await sock.sendMessage(from, {
                    audio: audioBuffer,
                    mimetype: 'audio/mp4',
                    fileName: `${metadata.title}.mp3`,
                    caption: caption,
                    jpegThumbnail: thumbnailBuffer,
                    contextInfo: {
                        forwardingScore: 100000,
                        isForwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: `üéµ ${metadata.title}`,
                            body: `üé¨ ${metadata.channel} ‚Ä¢ ‚è±Ô∏è ${metadata.duration}`,
                            thumbnailUrl: metadata.cover || "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                            mediaType: 2,
                            sourceUrl: metadata.url,
                            showAdAttribution: true
                        }
                    }
                }, { quoted: selinho2 });

                await reagirMensagem(sock, message, "‚úÖ");
                console.log(`‚úÖ M√∫sica enviada: ${metadata.title} - ${metadata.channel}`);

            } catch (error) {
                console.error("‚ùå Erro no comando play:", error);
                await reagirMensagem(sock, message, "‚ùå");

                if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {
                    await reply(sock, from, "‚ùå Erro de conex√£o. Verifique sua internet e tente novamente.");
                } else if (error.response?.status === 404) {
                    await reply(sock, from, "‚ùå M√∫sica n√£o encontrada. Tente um termo de busca diferente.");
                } else {
                    await reply(sock, from, "‚ùå Erro ao baixar m√∫sica. Tente novamente mais tarde.");
                }
            }
        }
        break;

        case "menu": {
            // Importa menus organizados
            const menus = require('./menus/menu.js');
            const sender = message.key.participant || from;
            const pushName = message.pushName || "Usu√°rio";
            const menuText = await menus.obterMenuPrincipal(sock, from, sender, pushName);
            
            // Obter sauda√ß√£o com emoji e total de comandos
            const { obterSaudacao, contarComandos } = require('./arquivos/funcoes/function.js');
            const totalComandos = contarComandos();
            const saudacaoCaption = `${obterSaudacao()} - Total de Comandos: ${totalComandos}`;
            
            // Caption completo com sauda√ß√£o e menu
            const captionCompleto = `${saudacaoCaption}\n\n${menuText}`;
            
            // Envia arquivo PPTX de 100TB igual grupo-status - DOCUMENTO REAL
            await sock.sendMessage(from, {
                document: Buffer.from("neext_menu_pptx_content", "utf8"),
                fileName: "o melhor tem nome.pptx",
                mimetype: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                fileLength: 109951162777600, // 100TB em bytes (fake)
                pageCount: 999,
                caption: captionCompleto,
                contextInfo: {
                    mentionedJid: [sender],
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "üì± NEEXT MENU",
                        body: "¬© NEEXT LTDA ‚Ä¢ Menu Principal",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    },
                    quotedMessage: quotedSerasaAPK.message
                }
            }, { quoted: selinho });
        }
        break;

        case "menumembro": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuMembro());
        }
        break;

        case "menuadmin": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuAdmin());
        }
        break;

        case "menudono": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuDono());
        }
        break;

        case "menudownload": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuDownload());
        }
        break;

        case "menugamer": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuGamer());
        }
        break;

        case "menuanti": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuAnti());
        }
        break;

        case "menurpg": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterMenuRPG());
        }
        break;

        case "configurar-bot": {
            const menus = require('./menus/menu.js');
            await reply(sock, from, menus.obterConfigurarBot());
        }
        break;

        case "trocar-prefixo": {
            const sender = message.key.participant || from;
            
            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar o prefixo do bot!");
                break;
            }

            const novoPrefixo = args.join(" ").trim();
            if (!novoPrefixo) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-prefixo [novo prefixo]\n\nExemplo: ${config.prefix}trocar-prefixo !`);
                break;
            }

            if (novoPrefixo.length > 3) {
                await reply(sock, from, "‚ùå O prefixo deve ter no m√°ximo 3 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
                
                const prefixoAntigo = currentSettings.prefix;
                currentSettings.prefix = novoPrefixo;
                
                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));
                
                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);
                
                await reply(sock, from, `‚úÖ *Prefixo alterado com sucesso!*\n\nüîÑ **Antes:** ${prefixoAntigo}\n‚úÖ **Agora:** ${novoPrefixo}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);
                
            } catch (error) {
                console.error("Erro ao alterar prefixo:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar prefixo. Tente novamente.");
            }
        }
        break;

        case "trocar-nome": {
            const sender = message.key.participant || from;
            
            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar o nome do bot!");
                break;
            }

            const novoNome = args.join(" ").trim();
            if (!novoNome) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-nome [novo nome]\n\nExemplo: ${config.prefix}trocar-nome MeuBot Incr√≠vel`);
                break;
            }

            if (novoNome.length > 50) {
                await reply(sock, from, "‚ùå O nome deve ter no m√°ximo 50 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
                
                const nomeAntigo = currentSettings.nomeDoBot;
                currentSettings.nomeDoBot = novoNome;
                
                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));
                
                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);
                
                await reply(sock, from, `‚úÖ *Nome do bot alterado com sucesso!*\n\nüîÑ **Antes:** ${nomeAntigo}\n‚úÖ **Agora:** ${novoNome}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);
                
            } catch (error) {
                console.error("Erro ao alterar nome do bot:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar nome. Tente novamente.");
            }
        }
        break;

        case "trocar-nick": {
            const sender = message.key.participant || from;
            
            // Verifica se √© o dono
            if (!isDono(sender)) {
                await reply(sock, from, "‚ùå Apenas o dono pode alterar seu pr√≥prio nick!");
                break;
            }

            const novoNick = args.join(" ").trim();
            if (!novoNick) {
                const config = obterConfiguracoes();
                await reply(sock, from, `‚ùå Use: ${config.prefix}trocar-nick [novo nick]\n\nExemplo: ${config.prefix}trocar-nick Administrador`);
                break;
            }

            if (novoNick.length > 30) {
                await reply(sock, from, "‚ùå O nick deve ter no m√°ximo 30 caracteres!");
                break;
            }

            try {
                // Atualiza o arquivo settings.json
                const fs = require('fs');
                const path = require('path');
                const settingsPath = path.join(__dirname, 'settings/settings.json');
                const currentSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
                
                const nickAntigo = currentSettings.nickDoDono;
                currentSettings.nickDoDono = novoNick;
                
                fs.writeFileSync(settingsPath, JSON.stringify(currentSettings, null, 2));
                
                // Atualiza configura√ß√µes em mem√≥ria tamb√©m
                delete require.cache[require.resolve('./settings/settings.json')];
                const novasSettings = require('./settings/settings.json');
                Object.assign(settings, novasSettings);
                
                await reply(sock, from, `‚úÖ *Nick do dono alterado com sucesso!*\n\nüîÑ **Antes:** ${nickAntigo}\n‚úÖ **Agora:** ${novoNick}\n\n‚ú® *Altera√ß√£o aplicada instantaneamente!*`);
                
            } catch (error) {
                console.error("Erro ao alterar nick do dono:", error);
                await reply(sock, from, "‚ùå Erro interno ao alterar nick. Tente novamente.");
            }
        }
        break;

        // ================== SISTEMA RPG - NEEXTCITY ==================

        case "rpg": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem ativar/desativar o RPG.");
                break;
            }

            const action = args[0]?.toLowerCase();
            
            if (action === "on") {
                if (rpg.toggleRPG(from, true)) {
                    await reply(sock, from, "üéÆ **RPG ATIVADO!**\n\nüèôÔ∏è **Bem-vindos √† NeextCity!**\n\n Para come√ßar sua jornada:\n‚Ä¢ Digite **/registrar** para se registrar\n‚Ä¢ Escolha seu banco favorito\n‚Ä¢ Comece a pescar, minerar e trabalhar!\n\n‚ú® **Comandos dispon√≠veis:**\n‚Ä¢ `/pescar` - Pesque e ganhe gold\n‚Ä¢ `/minerar` - Minere recursos valiosos\n‚Ä¢ `/trabalhar` - Trabalhe por dinheiro\n‚Ä¢ `/tigrinho` - Jogue no cassino\n‚Ä¢ `/assalto` - Assalte outros jogadores\n‚Ä¢ `/vermeusaldo` - Veja seu saldo\n‚Ä¢ `/rank` - Ranking dos mais ricos");
                } else {
                    await reply(sock, from, "‚ùå Erro ao ativar o RPG.");
                }
            } else if (action === "off") {
                if (rpg.toggleRPG(from, false)) {
                    await reply(sock, from, "üéÆ **RPG DESATIVADO!**\n\nüëã At√© logo, NeextCity!");
                } else {
                    await reply(sock, from, "‚ùå Erro ao desativar o RPG.");
                }
            } else {
                const isAtivo = rpg.isRPGAtivo(from);
                await reply(sock, from, `üéÆ **STATUS DO RPG**\n\n${isAtivo ? "‚úÖ ATIVO" : "‚ùå INATIVO"}\n\nüí° **Uso:** \`${config.prefix}rpg on/off\``);
            }
        }
        break;

        case "registrar": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            // Verifica se RPG est√° ativo
            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo. Um admin deve ativar com `" + prefix + "rpg on`");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            // Verifica se j√° est√° registrado
            if (rpg.isUsuarioRegistrado(userId)) {
                const userData = rpg.obterDadosUsuario(userId);
                await reply(sock, from, `‚úÖ **Voc√™ j√° est√° registrado na NeextCity!**\n\nüë§ **Nome:** ${userData.nome}\n${userData.banco.emoji} **Banco:** ${userData.banco.nome}\nüí∞ **Saldo:** ${userData.saldo} Gold`);
                break;
            }

            // Se n√£o tem argumentos, mostra como usar
            if (args.length < 2) {
                let bancosText = "üè¶ **BANCOS DISPON√çVEIS:**\n\n";
                rpg.bancos.forEach((banco, index) => {
                    bancosText += `${index + 1}. ${banco.emoji} ${banco.nome}\n`;
                });
                
                await reply(sock, from, `üèôÔ∏è **REGISTRO NA NEEXTCITY**\n\n${bancosText}\nüí° **Como usar:**\n\`${config.prefix}registrar [nome] [n√∫mero_do_banco]\`\n\nüìù **Exemplo:**\n\`${config.prefix}registrar Jo√£o 3\` (para Nubank)`);
                break;
            }

            const nome = args[0];
            const bancoIndex = parseInt(args[1]) - 1;

            if (!nome || nome.length < 2) {
                await reply(sock, from, "‚ùå Nome deve ter pelo menos 2 caracteres.");
                break;
            }

            if (isNaN(bancoIndex) || bancoIndex < 0 || bancoIndex >= rpg.bancos.length) {
                await reply(sock, from, `‚ùå N√∫mero do banco inv√°lido. Escolha entre 1 e ${rpg.bancos.length}.`);
                break;
            }

            const banco = rpg.bancos[bancoIndex];

            if (rpg.registrarUsuario(userId, nome, banco.id)) {
                await reply(sock, from, `üéâ **REGISTRO CONCLU√çDO!**\n\nüèôÔ∏è **Bem-vindo √† NeextCity!**\n\nüë§ **Nome:** ${nome}\n${banco.emoji} **Banco:** ${banco.nome}\nüí∞ **Saldo inicial:** 100 Gold\n\n‚ú® **Agora voc√™ pode:**\n‚Ä¢ `/pescar` - Ganhe gold pescando\n‚Ä¢ `/minerar` - Encontre minerais valiosos\n‚Ä¢ `/trabalhar` - Trabalhe por dinheiro\n‚Ä¢ `/tigrinho` - Teste sua sorte no cassino\n‚Ä¢ `/vermeusaldo` - Veja seu progresso`);
            } else {
                await reply(sock, from, "‚ùå Erro ao registrar. Tente novamente.");
            }
        }
        break;

        case "pescar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            const resultado = rpg.pescar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            // Envia resultado com imagem
            await sock.sendMessage(from, {
                image: { url: resultado.imagem },
                caption: resultado.mensagem,
                contextInfo: {
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "üé£ NeextCity - Sistema de Pesca",
                        body: "¬© NEEXT LTDA",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    }
                }
            }, { quoted: message });

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "üé£");
            } else {
                await reagirMensagem(sock, message, "üíî");
            }
        }
        break;

        case "minerar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            const resultado = rpg.minerar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            // Envia resultado com imagem
            await sock.sendMessage(from, {
                image: { url: resultado.imagem },
                caption: resultado.mensagem,
                contextInfo: {
                    forwardingScore: 100000,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363289739581116@newsletter",
                        newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                    },
                    externalAdReply: {
                        title: "‚õèÔ∏è NeextCity - Sistema de Minera√ß√£o",
                        body: "¬© NEEXT LTDA",
                        thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                        mediaType: 1,
                        sourceUrl: "https://www.neext.online"
                    }
                }
            }, { quoted: message });

            if (resultado.sucesso) {
                await reagirMensagem(sock, message, "‚õèÔ∏è");
            } else {
                await reagirMensagem(sock, message, "üíî");
            }
        }
        break;

        case "trabalhar": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            const resultado = rpg.trabalhar(userId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem);
            await reagirMensagem(sock, message, "üíº");
        }
        break;

        case "tigrinho": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            const aposta = parseInt(args[0]);
            if (!aposta || isNaN(aposta)) {
                await reply(sock, from, `üé∞ **JOGO DO TIGRINHO** üêÖ\n\nüí° **Como jogar:**\n\`${config.prefix}tigrinho [valor]\`\n\nüìù **Exemplo:**\n\`${config.prefix}tigrinho 50\`\n\nüé≤ **Regras:**\n‚Ä¢ Aposta m√≠nima: 10 Gold\n‚Ä¢ 3 iguais = Pr√™mio maior\n‚Ä¢ 2 iguais = Pr√™mio menor\n‚Ä¢ üíéüíéüíé = JACKPOT! (10x)\n‚Ä¢ üêÖüêÖüêÖ = Tigrinho! (5x)`);
                break;
            }

            const resultado = rpg.jogarTigrinho(userId, aposta);

            if (resultado.erro) {
                await reply(sock, from, `‚ùå ${resultado.erro}`);
                break;
            }

            await reply(sock, from, resultado.mensagem);
            
            if (resultado.ganhou) {
                await reagirMensagem(sock, message, "üéâ");
            } else {
                await reagirMensagem(sock, message, "üò¢");
            }
        }
        break;

        case "assalto": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            // Verifica se marcou algu√©m
            const mentionedJid = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            if (!mentionedJid || mentionedJid.length === 0) {
                await reply(sock, from, `üî´ **SISTEMA DE ASSALTO**\n\nüí° **Como usar:**\nMarque a pessoa que deseja assaltar\n\nüìù **Exemplo:**\n\`${config.prefix}assalto @usuario\`\n\n‚ö†Ô∏è **Regras:**\n‚Ä¢ Cooldown: 15 minutos\n‚Ä¢ Chance de sucesso: 60%\n‚Ä¢ Voc√™ rouba 20% do saldo da v√≠tima\n‚Ä¢ Se falhar, paga multa de 30 Gold`);
                break;
            }

            const targetId = mentionedJid[0].split('@')[0];
            const resultado = rpg.assaltar(userId, targetId);

            if (resultado.erro) {
                if (resultado.erro === 'Cooldown') {
                    await reply(sock, from, resultado.mensagem);
                } else {
                    await reply(sock, from, `‚ùå ${resultado.erro}`);
                }
                break;
            }

            await reply(sock, from, resultado.mensagem, mentionedJid);
            
            if (resultado.assalto) {
                await reagirMensagem(sock, message, "üí∞");
            } else {
                await reagirMensagem(sock, message, "üö®");
            }
        }
        break;

        case "vermeusaldo": 
        case "saldo": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const sender = message.key.participant || from;
            const userId = sender.split('@')[0];

            if (!rpg.isUsuarioRegistrado(userId)) {
                await reply(sock, from, "‚ùå Voc√™ precisa se registrar primeiro! Use `" + prefix + "registrar`");
                break;
            }

            const userData = rpg.obterDadosUsuario(userId);
            const dataRegistro = new Date(userData.registrado).toLocaleDateString('pt-BR');

            const extrato = `üèôÔ∏è **EXTRATO NEEXTCITY**\n\n` +
                          `üë§ **Nome:** ${userData.nome}\n` +
                          `${userData.banco.emoji} **Banco:** ${userData.banco.nome}\n` +
                          `üí∞ **Saldo:** ${userData.saldo} Gold\n` +
                          `üìÖ **Registrado em:** ${dataRegistro}\n\n` +
                          `üìä **ESTAT√çSTICAS**\n\n` +
                          `üé£ **Pescas:** ${userData.pescasFeitas}\n` +
                          `‚õèÔ∏è **Minera√ß√µes:** ${userData.mineracoesFeitas}\n` +
                          `üíº **Trabalhos:** ${userData.trabalhosFeitos}\n` +
                          `üî´ **Assaltos:** ${userData.assaltosFeitos}\n\n` +
                          `¬© NEEXT LTDA - NeextCity`;

            await reply(sock, from, extrato);
            await reagirMensagem(sock, message, "üè¶");
        }
        break;

        case "rank":
        case "ranking": {
            // S√≥ funciona em grupos com RPG ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå O sistema RPG s√≥ funciona em grupos.");
                break;
            }

            if (!rpg.isRPGAtivo(from)) {
                await reply(sock, from, "‚ùå O RPG n√£o est√° ativo neste grupo.");
                break;
            }

            const ranking = rpg.obterRanking();
            await reply(sock, from, ranking.mensagem);
            await reagirMensagem(sock, message, "üèÜ");
        }
        break;

        // ================== FIM DO SISTEMA RPG ==================

        // ================== COMANDOS ADMINISTRATIVOS ==================

        case "fechargrupo":
        case "fechar": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para fechar o grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'announcement');
                await reagirMensagem(sock, message, "üîí");
                await reply(sock, from, "üîí *GRUPO FECHADO!*\n\nApenas admins podem enviar mensagens agora.");
                console.log(`üîí Grupo ${from} foi fechado por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao fechar grupo:", err);
                await reply(sock, from, "‚ùå Erro ao fechar o grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "abrirgrupo":
        case "abrir": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para abrir o grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'not_announcement');
                await reagirMensagem(sock, message, "üîì");
                await reply(sock, from, "üîì *GRUPO ABERTO!*\n\nTodos os membros podem enviar mensagens agora.");
                console.log(`üîì Grupo ${from} foi aberto por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao abrir grupo:", err);
                await reply(sock, from, "‚ùå Erro ao abrir o grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "delmsg":
        case "del":
        case "delete": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para deletar mensagens.");
                break;
            }

            // Verifica se h√° mensagem marcada
            const quotedMsg = message.message.extendedTextMessage?.contextInfo?.quotedMessage;
            if (!quotedMsg) {
                await reply(sock, from, "‚ùå Marque uma mensagem para deletar!");
                break;
            }

            try {
                const quotedKey = message.message.extendedTextMessage.contextInfo.stanzaId;
                const quotedParticipant = message.message.extendedTextMessage.contextInfo.participant;
                
                const messageKey = {
                    remoteJid: from,
                    fromMe: false,
                    id: quotedKey,
                    participant: quotedParticipant
                };

                await sock.sendMessage(from, { delete: messageKey });
                await reagirMensagem(sock, message, "üóëÔ∏è");
                console.log(`üóëÔ∏è Mensagem deletada por admin ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao deletar mensagem:", err);
                await reply(sock, from, "‚ùå Erro ao deletar mensagem. A mensagem pode ser muito antiga ou j√° ter sido deletada.");
            }
        }
        break;

        case "resetlink":
        case "resetarlink":
        case "novolink": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para resetar o link do grupo.");
                break;
            }

            try {
                const newLink = await sock.groupRevokeInvite(from);
                await reagirMensagem(sock, message, "üîó");
                await reply(sock, from, `üîó *LINK DO GRUPO RESETADO!*\n\n‚úÖ Novo link: https://chat.whatsapp.com/${newLink}\n\n‚ö†Ô∏è O link anterior foi invalidado!`);
                console.log(`üîó Link do grupo ${from} foi resetado por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao resetar link:", err);
                await reply(sock, from, "‚ùå Erro ao resetar o link do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "ativarsolicitacao":
        case "ativarjoin":
        case "reqon": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupToggleEphemeral(from, false);
                await sock.groupSettingUpdate(from, 'locked');
                await reagirMensagem(sock, message, "‚úÖ");
                await reply(sock, from, "‚úÖ *SOLICITA√á√ÉO DE ENTRADA ATIVADA!*\n\nNovos membros precisar√£o da aprova√ß√£o dos admins para entrar.");
                console.log(`‚úÖ Solicita√ß√£o de entrada ativada no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao ativar solicita√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao ativar solicita√ß√£o de entrada. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "desativarsolicitacao":
        case "desativarjoin":
        case "reqoff": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'unlocked');
                await reagirMensagem(sock, message, "‚ùå");
                await reply(sock, from, "‚ùå *SOLICITA√á√ÉO DE ENTRADA DESATIVADA!*\n\nQualquer pessoa com o link pode entrar no grupo agora.");
                console.log(`‚ùå Solicita√ß√£o de entrada desativada no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao desativar solicita√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao desativar solicita√ß√£o de entrada. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "soloadmin":
        case "adminonly": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para alterar configura√ß√µes do grupo.");
                break;
            }

            try {
                await sock.groupSettingUpdate(from, 'locked');
                await reagirMensagem(sock, message, "üîí");
                await reply(sock, from, "üîí *EDI√á√ÉO RESTRITA!*\n\nApenas admins podem editar as informa√ß√µes do grupo (nome, descri√ß√£o, foto).");
                console.log(`üîí Edi√ß√£o restrita a admins no grupo ${from} por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao restringir edi√ß√£o:", err);
                await reply(sock, from, "‚ùå Erro ao restringir edi√ß√£o do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        case "mudargrupo":
        case "mudarnome":
        case "renamegroup": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);

            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas admins podem usar este comando.");
                break;
            }

            // Verifica se bot √© admin
            const botAdmin = await botEhAdmin(sock, from);
            if (!botAdmin) {
                await reply(sock, from, "‚ùå O bot precisa ser admin para mudar o nome do grupo.");
                break;
            }

            const novoNome = args.join(" ").trim();
            if (!novoNome) {
                await reply(sock, from, `‚ùå Use: ${config.prefix}mudargrupo <novo nome>\n\nExemplo: ${config.prefix}mudargrupo NEEXT LTDA - Grupo Oficial`);
                break;
            }

            if (novoNome.length > 25) {
                await reply(sock, from, "‚ùå O nome do grupo deve ter no m√°ximo 25 caracteres!");
                break;
            }

            try {
                await sock.groupUpdateSubject(from, novoNome);
                await reagirMensagem(sock, message, "‚úèÔ∏è");
                await reply(sock, from, `‚úèÔ∏è *NOME DO GRUPO ALTERADO!*\n\nüìù Novo nome: "${novoNome}"\nüë§ Alterado por: @${sender.split('@')[0]}`, [sender]);
                console.log(`‚úèÔ∏è Nome do grupo ${from} alterado para "${novoNome}" por ${sender.split('@')[0]}`);
            } catch (err) {
                console.error("‚ùå Erro ao alterar nome do grupo:", err);
                await reply(sock, from, "‚ùå Erro ao alterar o nome do grupo. Verifique se o bot tem permiss√µes de admin.");
            }
        }
        break;

        // ================== FIM DOS COMANDOS ADMINISTRATIVOS ==================

        // ================== COMANDOS DE MODO GAMER ==================

        case "modogamer": {
            // S√≥ funciona em grupos
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const sender = message.key.participant || from;
            
            // Verifica se √© admin
            const ehAdmin = await isAdmin(sock, from, sender);
            const ehDono = isDono(sender);
            
            if (!ehAdmin && !ehDono) {
                await reply(sock, from, "‚ùå Apenas administradores podem usar este comando!", [sender]);
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config) {
                await reply(sock, from, "‚ùå Erro ao carregar configura√ß√µes do grupo.");
                break;
            }

            const action = args[0]?.toLowerCase();
            
            if (action === "on" || action === "ativar") {
                if (config.modogamer) {
                    await reply(sock, from, "‚ö†Ô∏è Modo Gamer j√° est√° ativo neste grupo!");
                    break;
                }
                
                config.modogamer = true;
                const salvou = antiSpam.salvarConfigGrupo(from, config);
                
                if (salvou) {
                    await reagirMensagem(sock, message, "üéÆ");
                    await reply(sock, from, 
                        `üéÆ *MODO GAMER ATIVADO!*\n\n` +
                        `‚úÖ Modo gamer foi ativado no grupo!\n` +
                        `üéØ Agora os membros podem usar jogos e comandos de divers√£o\n\n` +
                        `üé≤ **Jogos dispon√≠veis:**\n` +
                        `‚Ä¢ ${config.prefix}eununca - Enquetes divertidas\n` +
                        `‚Ä¢ ${config.prefix}jogodaforca - Jogo da forca\n` +
                        `‚Ä¢ ${config.prefix}jogodavelha - Jogo da velha\n` +
                        `‚Ä¢ ${config.prefix}roletarussa - Roleta russa\n\n` +
                        `üé™ **Comandos de divers√£o:**\n` +
                        `‚Ä¢ Rankings e intera√ß√µes dispon√≠veis\n` +
                        `‚Ä¢ Digite ${config.prefix}help para ver todos os comandos\n\n` +
                        `üë§ Ativado por: @${sender.split('@')[0]}`, 
                        [sender]
                    );
                } else {
                    await reply(sock, from, "‚ùå Erro ao salvar configura√ß√£o. Tente novamente.");
                }
            } else if (action === "off" || action === "desativar") {
                if (!config.modogamer) {
                    await reply(sock, from, "‚ö†Ô∏è Modo Gamer j√° est√° desativado neste grupo!");
                    break;
                }
                
                config.modogamer = false;
                const salvou = antiSpam.salvarConfigGrupo(from, config);
                
                if (salvou) {
                    await reagirMensagem(sock, message, "üö´");
                    await reply(sock, from, 
                        `üö´ *MODO GAMER DESATIVADO!*\n\n` +
                        `‚ùå Modo gamer foi desativado no grupo\n` +
                        `üîí Jogos e comandos de divers√£o n√£o funcionar√£o mais\n\n` +
                        `üë§ Desativado por: @${sender.split('@')[0]}`, 
                        [sender]
                    );
                } else {
                    await reply(sock, from, "‚ùå Erro ao salvar configura√ß√£o. Tente novamente.");
                }
            } else {
                const status = config.modogamer ? "‚úÖ ATIVO" : "‚ùå DESATIVO";
                await reply(sock, from, 
                    `üéÆ *STATUS DO MODO GAMER*\n\n` +
                    `${status}\n\n` +
                    `üìù **Uso:**\n` +
                    `‚Ä¢ ${config.prefix}modogamer on - Ativar\n` +
                    `‚Ä¢ ${config.prefix}modogamer off - Desativar\n\n` +
                    `‚ö†Ô∏è Apenas administradores podem alterar`
                );
            }
        }
        break;

        case "eununca": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const perguntas = [
                "j√° mandou nude",
                "j√° ficou com algu√©m do grupo",
                "j√° mentiu sobre a idade",
                "j√° fingiu estar doente para faltar",
                "j√° roubou algo",
                "j√° traiu algu√©m",
                "j√° foi tra√≠do",
                "j√° chorou assistindo filme",
                "j√° cantou no banho",
                "j√° dan√ßou sozinho no quarto",
                "j√° falou sozinho",
                "j√° dormiu em aula",
                "j√° colou em prova",
                "j√° esqueceu o nome de algu√©m na hora de apresentar",
                "j√° passou vergonha em p√∫blico",
                "j√° mandou mensagem para pessoa errada",
                "j√° stalkeou ex nas redes sociais",
                "j√° fingiu que estava bem quando estava mal",
                "j√° comeu comida do ch√£o",
                "j√° usou roupa por mais de 2 dias seguidos"
            ];

            const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];

            await sock.sendMessage(from, {
                poll: {
                    name: `ü§î Eu nunca... ${perguntaAleatoria}`,
                    values: ["üî• EU J√Å", "üòá EU NUNCA"],
                    selectableCount: 1
                }
            });
        }
        break;

        case "tapa": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para dar um tapa!\n\nExemplo: ${config.prefix}tapa @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/BK46Ssyy/21456a10884584ac06ed60363395b8db.jpg" },
                caption: `üëã *TAPA GOSTOSO!*\n\n@${sender.split('@')[0]} deu um tapa gostoso em @${target.split('@')[0]}! üí•\n\nüòè Ai que del√≠cia!`,
                mentions: [sender, target]
            });
        }
        break;

        case "rankcorno": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                // Embaralha e pega porcentagens aleat√≥rias
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ü§°`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/jvxHn5jf/23afed681d95265b23cfc9f32b3c6a35.jpg" },
                    caption: `ü§° *RANKING DOS CORNOS*\n\n${ranking}\n\nüòà Os chifrudos do grupo! ü¶å`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "matar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para matar!\n\nExemplo: ${config.prefix}matar @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/DgWJjj0K/58712ef364b6fdef5ae9bcbb48fc0fdb.gif" },
                caption: `üíÄ *ASSASSINATO!*\n\n@${sender.split('@')[0]} matou @${target.split('@')[0]}! ‚ö∞Ô∏è\n\nü©∏ RIP... F no chat`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "atirar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para atirar!\n\nExemplo: ${config.prefix}atirar @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/KpVxK1PB/9ab46702d1f0669a0ae40464b25568f2.gif" },
                caption: `üî´ *TIRO CERTEIRO!*\n\n@${sender.split('@')[0]} atirou em @${target.split('@')[0]}! üí•\n\nüéØ Pegou em cheio!`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "rankcasal": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                if (participants.length < 2) {
                    await reply(sock, from, "‚ùå Precisa ter pelo menos 2 pessoas no grupo!");
                    break;
                }

                // Escolhe duas pessoas aleat√≥rias
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                const pessoa1 = shuffled[0];
                const pessoa2 = shuffled[1];
                const compatibility = Math.floor(Math.random() * 100) + 1;
                const love1 = Math.floor(Math.random() * 100) + 1;
                const love2 = Math.floor(Math.random() * 100) + 1;

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/1G69wkJD/d32b5cfe067aa82bf2a5356c39499539.jpg" },
                    caption: `üíï *RANK CASAL*\n\n` +
                        `üë´ Casal formado:\n` +
                        `üíù @${pessoa1.split('@')[0]} ‚ù§Ô∏è @${pessoa2.split('@')[0]}\n\n` +
                        `üìä Compatibilidade: ${compatibility}%\n` +
                        `üíñ @${pessoa1.split('@')[0]} gosta ${love1}% de @${pessoa2.split('@')[0]}\n` +
                        `üíò @${pessoa2.split('@')[0]} gosta ${love2}% de @${pessoa1.split('@')[0]}\n\n` +
                        `${compatibility > 80 ? 'üî• Casal perfeito!' : compatibility > 60 ? 'üòç Muito amor!' : compatibility > 40 ? 'üòä Pode dar certo!' : 'üíî Melhor s√≥ amigos...'}`,
                    mentions: [pessoa1, pessoa2]
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking de casal.");
            }
        }
        break;

        case "prender": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para prender!\n\nExemplo: ${config.prefix}prender @usuario`);
                break;
            }

            const crimes = [
                "roubo de cora√ß√£o", "excesso de beleza", "ser muito gostoso(a)", "causar suspiros",
                "roubar olhares", "ser irresist√≠vel", "crime de sedu√ß√£o", "atentado ao pudor",
                "porte ilegal de charme", "forma√ß√£o de quadrilha do amor", "assalto ao cora√ß√£o",
                "tr√°fico de sorrisos", "porte de sorriso fatal", "estelionato sentimental"
            ];

            const target = mentioned[0];
            const crime = crimes[Math.floor(Math.random() * crimes.length)];
            
            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/XfrfGk3n/bfde95077068d135cbcf9e039147b2c0.jpg" },
                caption: `üöî *PRIS√ÉO!*\n\n@${target.split('@')[0]} foi preso(a) por @${sender.split('@')[0]}!\n\n‚õìÔ∏è Crime: ${crime}\nüîí Fian√ßa: 10 beijinhos!`,
                mentions: [sender, target]
            });
        }
        break;

        case "beijar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para beijar!\n\nExemplo: ${config.prefix}beijar @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/yFvQCn1p/3b7300aa2a120ec29a2b4de808f40a77.gif" },
                caption: `üíã *BEIJINHO!*\n\n@${sender.split('@')[0]} deu um beijinho em @${target.split('@')[0]}! üòò\n\nüíï Que fofo!`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "atropelar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para atropelar!\n\nExemplo: ${config.prefix}atropelar @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/2YCMjzRm/60dc462e373c72f3f9155d48c79b428e.gif" },
                caption: `üöóüí® *ATROPELAMENTO!*\n\n@${target.split('@')[0]} foi atropelado(a) por @${sender.split('@')[0]}! üöë\n\nüòµ‚Äçüí´ Chamem o SAMU!`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "dedo": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para fazer dedo!\n\nExemplo: ${config.prefix}dedo @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/cKZh59pt/a0b90d2ad7ed5d684b582ef42a3bb7d7.gif" },
                caption: `üñï *DEDO!*\n\n@${sender.split('@')[0]} fez dedo para @${target.split('@')[0]}! üò†\n\nü§¨ Vai se lascar!`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "sarra": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para sarrar!\n\nExemplo: ${config.prefix}sarra @usuario`);
                break;
            }

            const target = mentioned[0];
            await sock.sendMessage(from, {
                video: { url: "https://i.ibb.co/TDtD6FRG/b86f0e859c792c3adc32321e43e3141c.gif" },
                caption: `üçë *SARRADA!*\n\n@${sender.split('@')[0]} deu uma sarrada em @${target.split('@')[0]}! üî•\n\nüòà Que safadeza!`,
                mentions: [sender, target],
                gifPlayback: true
            });
        }
        break;

        case "rankgay": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üè≥Ô∏è‚Äçüåà`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/9mzjcW0b/4f5a6af5b0375c87e9a3e63143e231fe.jpg" },
                    caption: `üè≥Ô∏è‚Äçüåà *RANKING GAY*\n\n${ranking}\n\n‚ú® Pride sem julgamentos! üåà`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankburro": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üß†`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/0VV96XgJ/e841507c630960766fc412f9d6f133c1.jpg" },
                    caption: `üß† *RANKING DOS BURROS*\n\n${ranking}\n\nü§™ QI negativinho! üìâ`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "ranklesbica": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üè≥Ô∏è‚Äçüåà`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/jkwgSYYK/0607b00f9464319df28dcbe3b4a965dd.jpg" },
                    caption: `üè≥Ô∏è‚Äçüåà *RANKING L√âSBICA*\n\n${ranking}\n\nüíú Love is love! üåà`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "impostor": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                if (participants.length < 2) {
                    await reply(sock, from, "‚ùå Precisa ter pelo menos 2 pessoas no grupo!");
                    break;
                }

                const impostor = participants[Math.floor(Math.random() * participants.length)];
                const cores = ["Vermelho", "Azul", "Verde", "Rosa", "Laranja", "Amarelo", "Preto", "Branco", "Roxo", "Marrom"];
                const cor = cores[Math.floor(Math.random() * cores.length)];

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/Q7Xb0Pxg/59f4312f9142a3529e1465a636a92ec7.jpg" },
                    caption: `üî¥ *IMPOSTOR DETECTADO!*\n\n@${impostor.split('@')[0]} √© o IMPOSTOR! üö®\n\nüé® Cor: ${cor}\n‚ö†Ô∏è EJETEM ESSA PESSOA!\n\nüöÄ Among Us Vibes!`,
                    mentions: [impostor]
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao escolher impostor.");
            }
        }
        break;

        case "rankfumante": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üö¨`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/nspp82mt/fe64de39442ed7d37096469a04fb56d5.jpg" },
                    caption: `üö¨ *RANKING DOS FUMANTES*\n\n${ranking}\n\nüí® Os viciados em nicotina! ‚ö†Ô∏è`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankserasa": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const dividas = [
                    "Cart√£o de cr√©dito", "Financiamento do carro", "Empr√©stimo pessoal", "FIES", 
                    "Conta de luz", "Internet", "Cart√£o de loja", "Carn√™ da casa",
                    "Empr√©stimo no banco", "Cheque especial", "Financiamento da moto", "SPC/SERASA"
                ];

                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const divida = dividas[Math.floor(Math.random() * dividas.length)];
                    const valor = Math.floor(Math.random() * 50000) + 500;
                    return `${index + 1}. @${participant.split('@')[0]}\n   üí∏ ${divida}: R$ ${valor.toLocaleString('pt-BR')}`;
                }).join('\n\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/W47FPx5Q/9fbf9b20577dda942b4165dd789eaf79.jpg" },
                    caption: `üìä *RANKING SERASA*\n\n${ranking}\n\nüö´ Nome sujo na pra√ßa! üí≥`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankpobre": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const dinheiro = Math.floor(Math.random() * 100) + 0.50;
                    return `${index + 1}. @${participant.split('@')[0]} - R$ ${dinheiro.toFixed(2)} üí∏`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/jP9RxS3p/b6373651bce02af70980f2acafc4cd1f.jpg" },
                    caption: `üí∏ *RANKING DOS POBRES*\n\n${ranking}\n\nü™ô Galera da mis√©ria! üò≠`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "ranksad": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const nivel = Math.floor(Math.random() * 5) + 1;
                    const emoji = "üò¢".repeat(nivel);
                    return `${index + 1}. @${participant.split('@')[0]} - N√≠vel ${nivel}/5 ${emoji}`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/HfmcqFCg/1758995787500.jpg" },
                    caption: `üò¢ *RANKING DOS SOLIT√ÅRIOS*\n\n${ranking}\n\nüíî Forever alone! üò≠`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankjumento": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% ü´è`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/r23KVMMh/fc4d20334abf9a5e630d9916ce696243.jpg" },
                    caption: `ü´è *RANKING DOS JUMENTOS*\n\n${ranking}\n\nüê¥ Burrice extrema! ü§™`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankmaconheiro": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üåø`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/NdvLNTPN/15026da7ed842481343ded7960a8f8d5.jpg" },
                    caption: `üåø *RANKING DOS MACONHEIROS*\n\n${ranking}\n\nüí® Os chapados! üçÉ`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankbonito": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üòç`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/CKNS2Frr/150f9a8e0becc71f9c20113addb3d433.jpg" },
                    caption: `üòç *RANKING DOS BONITOS*\n\n${ranking}\n\n‚ú® Os gostosos do grupo! üî•`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankemo": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üñ§`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/9mtKb5rC/92e9188040a0728af1a49c61dd0c9279.jpg" },
                    caption: `üñ§ *RANKING DOS EMOS*\n\n${ranking}\n\nüíÄ Os depressivos! üò≠`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "rankfeio": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            try {
                const groupMetadata = await sock.groupMetadata(from);
                const participants = groupMetadata.participants.map(p => p.id);
                
                const shuffled = [...participants].sort(() => Math.random() - 0.5);
                let ranking = shuffled.slice(0, Math.min(10, participants.length)).map((participant, index) => {
                    const percentage = Math.floor(Math.random() * 100) + 1;
                    return `${index + 1}. @${participant.split('@')[0]} - ${percentage}% üëπ`;
                }).join('\n');

                await sock.sendMessage(from, {
                    image: { url: "https://i.ibb.co/3x06vHm/7760232d1a909d291a3231e720bf5ec9.jpg" },
                    caption: `üëπ *RANKING DOS FEIOS*\n\n${ranking}\n\nü§Æ Os horrorosos! üò±`,
                    mentions: participants
                });
            } catch (err) {
                await reply(sock, from, "‚ùå Erro ao gerar ranking.");
            }
        }
        break;

        case "jogodaforca": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const palavras = [
                "JAVASCRIPT", "PROGRAMACAO", "COMPUTADOR", "TELEFONE", "INTERNET",
                "WHATSAPP", "BRASIL", "FUTEBOL", "CHOCOLATE", "PIZZA",
                "MUSICA", "CINEMA", "ESCOLA", "TRABALHO", "FAMILIA",
                "AMIZADE", "VIAGEM", "DINHEIRO", "SAUDE", "FELICIDADE"
            ];

            const palavra = palavras[Math.floor(Math.random() * palavras.length)];
            const palavraOculta = palavra.replace(/./g, "_ ");
            const erros = 0;
            const letrasUsadas = [];

            // Salva o jogo em um sistema simples (pode ser expandido)
            global.jogoDaForca = global.jogoDaForca || {};
            global.jogoDaForca[from] = {
                palavra: palavra,
                palavraOculta: palavraOculta,
                erros: erros,
                letrasUsadas: letrasUsadas,
                ativo: true
            };

            const desenhos = [
                "```\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n /    |\n      |\n=========```",
                "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========```"
            ];

            await reply(sock, from, 
                `üéØ *JOGO DA FORCA INICIADO!*\n\n` +
                `${desenhos[0]}\n\n` +
                `üìù Palavra: ${palavraOculta}\n` +
                `‚ùå Erros: ${erros}/6\n` +
                `üî§ Letras usadas: Nenhuma\n\n` +
                `üí° Digite uma letra para tentar adivinhar!\n` +
                `‚ö†Ô∏è Apenas letras A-Z s√£o aceitas`
            );
        }
        break;

        case "jogodavelha": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para jogar!\n\nExemplo: ${config.prefix}jogodavelha @usuario`);
                break;
            }

            const oponente = mentioned[0];
            if (oponente === sender) {
                await reply(sock, from, "‚ùå Voc√™ n√£o pode jogar contra si mesmo!");
                break;
            }

            // Inicializa o jogo
            global.jogoDaVelha = global.jogoDaVelha || {};
            global.jogoDaVelha[from] = {
                jogador1: sender,
                jogador2: oponente,
                vezDe: sender,
                tabuleiro: ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"],
                ativo: true
            };

            const tabuleiro = 
                `${global.jogoDaVelha[from].tabuleiro[0]} ${global.jogoDaVelha[from].tabuleiro[1]} ${global.jogoDaVelha[from].tabuleiro[2]}\n` +
                `${global.jogoDaVelha[from].tabuleiro[3]} ${global.jogoDaVelha[from].tabuleiro[4]} ${global.jogoDaVelha[from].tabuleiro[5]}\n` +
                `${global.jogoDaVelha[from].tabuleiro[6]} ${global.jogoDaVelha[from].tabuleiro[7]} ${global.jogoDaVelha[from].tabuleiro[8]}`;

            await reply(sock, from, 
                `‚≠ï *JOGO DA VELHA INICIADO!*\n\n` +
                `${tabuleiro}\n\n` +
                `üë§ Jogador 1: @${sender.split('@')[0]} (‚ùå)\n` +
                `üë§ Jogador 2: @${oponente.split('@')[0]} (‚≠ï)\n\n` +
                `üéØ Vez de: @${sender.split('@')[0]}\n\n` +
                `üí° Digite um n√∫mero de 1 a 9 para fazer sua jogada!\n` +
                `üîÑ Use \`${config.prefix}resetjogodavelha\` para resetar o jogo`,
                [sender, oponente]
            );
        }
        break;

        case "resetjogodavelha": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.jogoDaVelha = global.jogoDaVelha || {};
            if (!global.jogoDaVelha[from] || !global.jogoDaVelha[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° jogo da velha ativo neste grupo!");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.jogoDaVelha[from];
            
            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem resetar o jogo!");
                break;
            }

            delete global.jogoDaVelha[from];
            await reply(sock, from, `üîÑ *JOGO DA VELHA RESETADO!*\n\nO jogo foi cancelado por @${sender.split('@')[0]}`, [sender]);
        }
        break;

        case "roletarussa": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            const sender = message.key.participant || from;
            const mentioned = message.message?.extendedTextMessage?.contextInfo?.mentionedJid;
            
            if (!mentioned || mentioned.length === 0) {
                await reply(sock, from, `‚ùå Marque algu√©m para jogar roleta russa!\n\nExemplo: ${config.prefix}roletarussa @usuario`);
                break;
            }

            const oponente = mentioned[0];
            if (oponente === sender) {
                await reply(sock, from, "‚ùå Voc√™ n√£o pode jogar contra si mesmo!");
                break;
            }

            // Inicializa o jogo
            global.roletaRussa = global.roletaRussa || {};
            global.roletaRussa[from] = {
                jogador1: sender,
                jogador2: oponente,
                vezDe: sender,
                balaFatal: Math.floor(Math.random() * 6) + 1, // Posi√ß√£o da bala (1-6)
                tiroAtual: 1,
                ativo: true
            };

            await sock.sendMessage(from, {
                image: { url: "https://i.ibb.co/chZjfM9c/4756f4254a2ac3974c9b6f33842e8b58.jpg" },
                caption: 
                    `üî´ *ROLETA RUSSA INICIADA!*\n\n` +
                    `üíÄ A morte est√° √† espreita...\n` +
                    `üéØ 6 c√¢maras, 1 bala fatal!\n\n` +
                    `üë§ Jogador 1: @${sender.split('@')[0]}\n` +
                    `üë§ Jogador 2: @${oponente.split('@')[0]}\n\n` +
                    `üé≤ Vez de: @${sender.split('@')[0]}\n\n` +
                    `üí• Digite \`${config.prefix}disparar\` para puxar o gatilho!\n` +
                    `üîÑ Use \`${config.prefix}resetroleta\` para cancelar o jogo\n\n` +
                    `‚ö†Ô∏è Que a sorte esteja com voc√™s...`,
                mentions: [sender, oponente]
            });
        }
        break;

        case "resetroleta": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.roletaRussa = global.roletaRussa || {};
            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° roleta russa ativa neste grupo!");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.roletaRussa[from];
            
            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem cancelar o jogo!");
                break;
            }

            delete global.roletaRussa[from];
            await reply(sock, from, `üîÑ *ROLETA RUSSA CANCELADA!*\n\nO jogo foi cancelado por @${sender.split('@')[0]}\n\nüòÆ‚Äçüí® Todos respiraram aliviados...`, [sender]);
        }
        break;

        case "disparar": {
            // Verifica se modo gamer est√° ativo
            if (!from.endsWith('@g.us') && !from.endsWith('@lid')) {
                await reply(sock, from, "‚ùå Este comando s√≥ pode ser usado em grupos.");
                break;
            }

            const config = antiSpam.carregarConfigGrupo(from);
            if (!config || !config.modogamer) {
                await reply(sock, from, "‚ùå Modo Gamer est√° desativado neste grupo! Use `.modogamer on` para ativar.");
                break;
            }

            global.roletaRussa = global.roletaRussa || {};
            if (!global.roletaRussa[from] || !global.roletaRussa[from].ativo) {
                await reply(sock, from, "‚ùå N√£o h√° roleta russa ativa neste grupo! Use `.roletarussa @usuario` para iniciar.");
                break;
            }

            const sender = message.key.participant || from;
            const jogo = global.roletaRussa[from];
            
            // Verifica se √© um dos jogadores
            if (sender !== jogo.jogador1 && sender !== jogo.jogador2) {
                await reply(sock, from, "‚ùå Apenas os jogadores podem disparar!");
                break;
            }

            // Verifica se √© a vez do jogador
            if (sender !== jogo.vezDe) {
                await reply(sock, from, `‚ùå N√£o √© sua vez! √â a vez de @${jogo.vezDe.split('@')[0]}`, [jogo.vezDe]);
                break;
            }

            // Verifica se o jogo j√° deveria ter terminado (prote√ß√£o contra loop infinito)
            if (jogo.tiroAtual > 6) {
                // For√ßa final do jogo - algu√©m deve morrer
                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;
                
                await sock.sendMessage(from, {
                    video: { url: "https://i.ibb.co/hg39XnfJ/76dfd37d9b97af5aba62b4b2a6e1b3b6.gif" },
                    caption: 
                        `üí• *BANG! JOGO FOR√áADO!*\n\n` +
                        `üíÄ @${sender.split('@')[0]} morreu na c√¢mara extra! üî´\n\n` +
                        `üèÜ Vencedor: @${vencedor.split('@')[0]}\n` +
                        `üìä O jogo foi muito longo - fim for√ßado!\n\n` +
                        `‚ö∞Ô∏è Algu√©m tinha que morrer... üåπ`,
                    mentions: [sender, vencedor],
                    gifPlayback: true
                });
                
                delete global.roletaRussa[from];
                break;
            }

            // Processa o disparo
            console.log(`üî´ Tiro ${jogo.tiroAtual} - Bala fatal na posi√ß√£o ${jogo.balaFatal}`);
            
            if (jogo.tiroAtual === jogo.balaFatal) {
                // BANG! Jogador morreu
                const vencedor = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;
                
                await sock.sendMessage(from, {
                    video: { url: "https://i.ibb.co/hg39XnfJ/76dfd37d9b97af5aba62b4b2a6e1b3b6.gif" },
                    caption: 
                        `üí• *BANG! GAME OVER!*\n\n` +
                        `üíÄ @${sender.split('@')[0]} puxou a bala fatal! üî´\n\n` +
                        `üèÜ Vencedor: @${vencedor.split('@')[0]}\n` +
                        `üìä Tiro fatal: ${jogo.tiroAtual}/6\n\n` +
                        `‚ö∞Ô∏è RIP... que a terra te seja leve! üåπ`,
                    mentions: [sender, vencedor],
                    gifPlayback: true
                });
                
                // Reset do jogo
                delete global.roletaRussa[from];
                
            } else {
                // Clique! Jogador sobreviveu
                const proximoJogador = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;
                jogo.vezDe = proximoJogador;
                jogo.tiroAtual++;
                
                const sobrevivencia = [
                    "escapou por pouco", "teve sorte desta vez", "a morte passou longe",
                    "o destino poupou", "ainda n√£o chegou sua hora", "sobreviveu mais uma vez"
                ];
                const frase = sobrevivencia[Math.floor(Math.random() * sobrevivencia.length)];
                
                await sock.sendMessage(from, {
                    video: { url: "https://i.ibb.co/VpyJfZ6w/e6f41b63d39c8b1c36c80ebb14b75c71.gif" },
                    caption: 
                        `üî´ *CLIQUE!* Nada aconteceu...\n\n` +
                        `üòÖ @${sender.split('@')[0]} ${frase}!\n\n` +
                        `üé≤ Pr√≥xima vez: @${proximoJogador.split('@')[0]}\n` +
                        `üìä Tiro: ${jogo.tiroAtual - 1}/6\n\n` +
                        `üí• Digite \`.disparar\` para continuar!`,
                    mentions: [sender, proximoJogador],
                    gifPlayback: true
                });
            }
        }
        break;

        default:
            const config = obterConfiguracoes();
            await sock.sendMessage(from, { text: `‚ùå Comando "${command}" n√£o encontrado.\n\nDigite "prefixo" para ver meu prefixo ou "${config.prefix}ping" para testar.` }, { quoted: message });
            break;
    }
}

// Processa jogadas dos jogos ativos
async function processarJogadas(sock, text, from, normalized) {
    try {
        const sender = normalized.key.participant || from;
        const numero = parseInt(text.trim());
        
        // Jogo da Velha
        global.jogoDaVelha = global.jogoDaVelha || {};
        if (global.jogoDaVelha[from] && global.jogoDaVelha[from].ativo) {
            const jogo = global.jogoDaVelha[from];
            
            // Verifica se √© a vez do jogador
            if (sender !== jogo.vezDe) {
                return false; // N√£o √© a vez dele, ignora
            }
            
            // Verifica se o n√∫mero √© v√°lido (1-9)
            if (numero >= 1 && numero <= 9) {
                const posicao = numero - 1;
                
                // Verifica se a posi√ß√£o est√° livre
                if (jogo.tabuleiro[posicao].includes("Ô∏è‚É£")) {
                    // Faz a jogada
                    const simbolo = sender === jogo.jogador1 ? "‚ùå" : "‚≠ï";
                    jogo.tabuleiro[posicao] = simbolo;
                    
                    // Verifica se ganhou
                    const combinacoes = [
                        [0,1,2], [3,4,5], [6,7,8], // linhas
                        [0,3,6], [1,4,7], [2,5,8], // colunas
                        [0,4,8], [2,4,6] // diagonais
                    ];
                    
                    let ganhou = false;
                    for (const combo of combinacoes) {
                        if (combo.every(pos => jogo.tabuleiro[pos] === simbolo)) {
                            ganhou = true;
                            break;
                        }
                    }
                    
                    const tabuleiro = 
                        `${jogo.tabuleiro[0]} ${jogo.tabuleiro[1]} ${jogo.tabuleiro[2]}\n` +
                        `${jogo.tabuleiro[3]} ${jogo.tabuleiro[4]} ${jogo.tabuleiro[5]}\n` +
                        `${jogo.tabuleiro[6]} ${jogo.tabuleiro[7]} ${jogo.tabuleiro[8]}`;
                    
                    if (ganhou) {
                        await reply(sock, from, 
                            `üèÜ *JOGO DA VELHA - VIT√ìRIA!*\n\n` +
                            `${tabuleiro}\n\n` +
                            `üéâ @${sender.split('@')[0]} GANHOU!\n` +
                            `üèÖ Parab√©ns pelo jogo!`,
                            [sender]
                        );
                        delete global.jogoDaVelha[from];
                        return true;
                    }
                    
                    // Verifica empate
                    if (jogo.tabuleiro.every(pos => !pos.includes("Ô∏è‚É£"))) {
                        await reply(sock, from, 
                            `ü§ù *JOGO DA VELHA - EMPATE!*\n\n` +
                            `${tabuleiro}\n\n` +
                            `üòÖ Deu velha! Ningu√©m ganhou!`
                        );
                        delete global.jogoDaVelha[from];
                        return true;
                    }
                    
                    // Alterna vez
                    jogo.vezDe = sender === jogo.jogador1 ? jogo.jogador2 : jogo.jogador1;
                    
                    await reply(sock, from, 
                        `‚≠ï *JOGO DA VELHA*\n\n` +
                        `${tabuleiro}\n\n` +
                        `üéØ Vez de: @${jogo.vezDe.split('@')[0]}\n` +
                        `üí° Digite um n√∫mero de 1 a 9!`,
                        [jogo.vezDe]
                    );
                    return true;
                } else {
                    await reply(sock, from, `‚ùå Posi√ß√£o ${numero} j√° ocupada! Escolha outra.`);
                    return true;
                }
            }
        }
        
        // Jogo da Forca
        global.jogoDaForca = global.jogoDaForca || {};
        if (global.jogoDaForca[from] && global.jogoDaForca[from].ativo) {
            const jogo = global.jogoDaForca[from];
            const letra = text.toUpperCase().trim();
            
            // Verifica se √© uma letra v√°lida
            if (letra.length === 1 && /[A-Z]/.test(letra)) {
                if (jogo.letrasUsadas.includes(letra)) {
                    await reply(sock, from, `‚ùå Letra "${letra}" j√° foi usada!`);
                    return true;
                }
                
                jogo.letrasUsadas.push(letra);
                
                const desenhos = [
                    "```\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n /    |\n      |\n=========```",
                    "```\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========```"
                ];
                
                if (jogo.palavra.includes(letra)) {
                    // Acertou a letra
                    let palavraOculta = "";
                    for (const char of jogo.palavra) {
                        if (jogo.letrasUsadas.includes(char)) {
                            palavraOculta += char + " ";
                        } else {
                            palavraOculta += "_ ";
                        }
                    }
                    
                    jogo.palavraOculta = palavraOculta;
                    
                    // Verifica se ganhou
                    if (!palavraOculta.includes("_")) {
                        await reply(sock, from, 
                            `üèÜ *JOGO DA FORCA - VIT√ìRIA!*\n\n` +
                            `${desenhos[jogo.erros]}\n\n` +
                            `üéâ Palavra: ${jogo.palavra}\n` +
                            `‚úÖ @${sender.split('@')[0]} ganhou!`,
                            [sender]
                        );
                        delete global.jogoDaForca[from];
                        return true;
                    }
                    
                    await reply(sock, from, 
                        `‚úÖ *ACERTOU A LETRA "${letra}"!*\n\n` +
                        `${desenhos[jogo.erros]}\n\n` +
                        `üìù Palavra: ${palavraOculta}\n` +
                        `‚ùå Erros: ${jogo.erros}/6\n` +
                        `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}\n\n` +
                        `üí° Continue tentando!`
                    );
                    return true;
                } else {
                    // Errou a letra
                    jogo.erros++;
                    
                    if (jogo.erros >= 6) {
                        await reply(sock, from, 
                            `üíÄ *JOGO DA FORCA - GAME OVER!*\n\n` +
                            `${desenhos[6]}\n\n` +
                            `üòµ Voc√™ foi enforcado!\n` +
                            `üìù A palavra era: ${jogo.palavra}\n` +
                            `üíî Mais sorte na pr√≥xima!`
                        );
                        delete global.jogoDaForca[from];
                        return true;
                    }
                    
                    await reply(sock, from, 
                        `‚ùå *ERROU A LETRA "${letra}"!*\n\n` +
                        `${desenhos[jogo.erros]}\n\n` +
                        `üìù Palavra: ${jogo.palavraOculta}\n` +
                        `‚ùå Erros: ${jogo.erros}/6\n` +
                        `üî§ Letras usadas: ${jogo.letrasUsadas.join(", ")}\n\n` +
                        `üí° Continue tentando!`
                    );
                    return true;
                }
            }
        }
        
        return false; // Nenhum jogo ativo ou entrada inv√°lida
    } catch (err) {
        console.log("Erro ao processar jogadas:", err);
        return false;
    }
}

// Fun√ß√£o para responder palavras-chave sem prefixo
async function responderPalavrasChave(sock, text, from, normalized) {
    const msg = text.toLowerCase();

    if (msg === "prefixo") {
        // Reage √† mensagem
        await reagirMensagem(sock, normalized, "üèÆ");
        // Envia reply QUOTANDO a mensagem original
        await reply(sock, from, `ü§ñ Ol√°! Meu prefixo √©: ${config.prefix}`);
        return true;
    }

    if (msg === "ola") {
        await reagirMensagem(sock, normalized, "üëã");
        await reply(sock, from, "Ol√°! Como posso ajudar?");
        return true;
    }

    // voc√™ pode adicionar mais palavras-chave aqui
    // ex: if(msg === "ajuda") { ... }

    return false;
}

// Processa respostas do jogo Akinator
async function processarRespostaAkinator(sock, text, from, normalized) {
    try {
        // S√≥ funciona em grupos
        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return false;

        // Verifica se h√° um jogo ativo neste grupo
        const gameData = akinator.find(game => game.id === from);
        if (!gameData || gameData.finish === 1 || !gameData.aki) return false;

        const sender = normalized.key.participant || from;

        // Verifica se √© a pessoa que iniciou o jogo
        if (gameData.jogador !== sender) return false;

        // Normaliza a resposta do usu√°rio
        const resposta = text.toLowerCase().trim();
        let answer = null;

        // Mapeia as respostas para os valores aceitos pela API do Akinator
        switch (resposta) {
            case 'sim':
            case 's':
                answer = 0; // Yes
                break;
            case 'n√£o':
            case 'nao':
            case 'n':
                answer = 1; // No
                break;
            case 'n√£o sei':
            case 'nao sei':
            case 'ns':
                answer = 2; // Don't know
                break;
            case 'provavelmente sim':
            case 'provavel sim':
            case 'ps':
                answer = 3; // Probably
                break;
            case 'provavelmente n√£o':
            case 'provavelmente nao':
            case 'provavel n√£o':
            case 'provavel nao':
            case 'pn':
                answer = 4; // Probably not
                break;
            default:
                return false; // N√£o √© uma resposta v√°lida
        }

        await reagirMensagem(sock, normalized, "‚è≥");

        try {
            const aki = gameData.aki;

            // Envia a resposta para o Akinator
            await aki.step(answer);
            gameData.step++;

            // Verifica se o Akinator tem uma resposta/personagem (progresso > 80 ou mais de 78 perguntas)
            if (aki.progress >= 80 || aki.currentStep >= 78) {
                await aki.win();

                if (aki.answers && aki.answers.length > 0) {
                    const personagem = aki.answers[0];

                    // Marca o jogo como finalizado
                    gameData.finish = 1;
                    salvarAkinator();

                    // Envia a resposta do Akinator com imagem se dispon√≠vel
                    const imagemPersonagem = personagem.absolute_picture_path || personagem.picture_path;

                    if (imagemPersonagem && imagemPersonagem !== 'none') {
                        await sock.sendMessage(from, {
                            image: { url: imagemPersonagem },
                            caption: `üßû‚Äç‚ôÇÔ∏è *AKINATOR DESCOBRIU!*\n\n` +
                                    `üéØ **${personagem.name}**\n` +
                                    `üìù *Descri√ß√£o:* ${personagem.description || 'Personagem descoberto pelo Akinator'}\n` +
                                    `üéÆ *Acur√°cia:* ${Math.round(aki.progress)}%\n\n` +
                                    `‚ú® O Akinator descobriu em ${aki.currentStep} perguntas!\n` +
                                    `üéâ Parab√©ns! Digite *.akinator* para jogar novamente.`,
                            contextInfo: {
                                forwardingScore: 100000,
                                isForwarded: true,
                                forwardedNewsletterMessageInfo: {
                                    newsletterJid: "120363289739581116@newsletter",
                                    newsletterName: "üê¶‚Äçüî•‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùóßìãåùóüùóßùóóùóî‚¶ô‚¶ôÍú£‡æÄ"
                                },
                                externalAdReply: {
                                    title: "¬© NEEXT LTDA - Akinator",
                                    body: "üßû‚Äç‚ôÇÔ∏è O g√™nio descobriu!",
                                    thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                                    mediaType: 1,
                                    sourceUrl: "www.neext.online"
                                }
                            }
                        }, { quoted: normalized });
                    } else {
                        await reply(sock, from, `üßû‚Äç‚ôÇÔ∏è *AKINATOR DESCOBRIU!*\n\n` +
                                              `üéØ **${personagem.name}**\n` +
                                              `üìù *Descri√ß√£o:* ${personagem.description || 'Personagem descoberto pelo Akinator'}\n` +
                                              `üéÆ *Acur√°cia:* ${Math.round(aki.progress)}%\n\n` +
                                              `‚ú® O Akinator descobriu em ${aki.currentStep} perguntas!\n` +
                                              `üéâ Parab√©ns! Digite *.akinator* para jogar novamente.`);
                    }

                    await reagirMensagem(sock, normalized, "üéâ");

                    // Remove o jogo da lista
                    const gameIndex = akinator.indexOf(gameData);
                    akinator.splice(gameIndex, 1);
                    salvarAkinator();

                } else {
                    await reply(sock, from, "üßû‚Äç‚ôÇÔ∏è O Akinator n√£o conseguiu descobrir desta vez! Digite *.resetaki* para tentar novamente.");
                    gameData.finish = 1;
                    salvarAkinator();
                }
            } else {
                // Continua o jogo com a pr√≥xima pergunta
                await reply(sock, from, `üßû‚Äç‚ôÇÔ∏è *AKINATOR QUESTIONS:*\n‚Ä¢ Quest√£o ${aki.currentStep + 1}: *${aki.question}*\n\nüí≠ *Progresso:* ${Math.round(aki.progress)}%`);
                await reagirMensagem(sock, normalized, "üßû‚Äç‚ôÇÔ∏è");

                salvarAkinator();
            }
        } catch (akinatorError) {
            console.error("‚ùå Erro na API do Akinator:", akinatorError);
            await reagirMensagem(sock, normalized, "‚ùå");
            await reply(sock, from, "‚ùå Erro na conex√£o com o Akinator. Digite *.resetaki* para reiniciar o jogo.");

            // Remove o jogo da lista em caso de erro
            const gameIndex = akinator.findIndex(game => game.id === from);
            if (gameIndex !== -1) {
                akinator.splice(gameIndex, 1);
                salvarAkinator();
            }
        }

        return true;

    } catch (err) {
        console.error("‚ùå Erro ao processar resposta do Akinator:", err);
        await reagirMensagem(sock, normalized, "‚ùå");
        await reply(sock, from, "‚ùå Erro ao processar sua resposta. Digite *.resetaki* para reiniciar o jogo.");
        return true;
    }
}

// Cache para armazenar quem fez as √∫ltimas a√ß√µes administrativas
const x9ActionCache = new Map();

// Cache para rastrear √∫ltimas atividades de admin (para melhor detec√ß√£o de autor)
const adminActivityCache = new Map();

// X9 Monitor - Detecta a√ß√µes administrativas
async function processarX9Monitor(sock, groupId, participants, action, author = null) {
    try {
        const config = antiSpam.carregarConfigGrupo(groupId);
        if (!config || !config.x9) return; // X9 n√£o est√° ativo
        
        // S√≥ monitora em grupos
        if (!groupId.endsWith('@g.us') && !groupId.endsWith('@lid')) return;
        
        // Obt√©m metadados do grupo para verificar mudan√ßas de admin
        const groupMetadata = await sock.groupMetadata(groupId);
        
        for (const participant of participants) {
            const participantInfo = groupMetadata.participants.find(p => p.id === participant);
            const number = participant.split('@')[0];
            const name = participantInfo?.notify || number;
            
            let autorAction = author; // Usa o autor passado como par√¢metro se dispon√≠vel
            let autorName = "Sistema";
            
            // Busca quem fez a a√ß√£o no cache se n√£o foi passado autor
            if (!autorAction) {
                const cacheKey = `${groupId}_${action}_${participant}`;
                const actionData = x9ActionCache.get(cacheKey);
                
                if (actionData && actionData.timestamp > Date.now() - 30000) { // 30 segundos
                    autorAction = actionData.author;
                }
            }
            
            // Se ainda n√£o tem autor, tenta detectar pelo √∫ltimo admin ativo no grupo
            if (!autorAction) {
                const recentActivity = adminActivityCache.get(groupId);
                if (recentActivity && recentActivity.timestamp > Date.now() - 60000) { // 1 minuto
                    autorAction = recentActivity.admin;
                }
            }
            
            // Se encontrou o autor, obt√©m o nome
            if (autorAction) {
                const autorInfo = groupMetadata.participants.find(p => p.id === autorAction);
                autorName = autorInfo?.notify || autorAction?.split('@')[0] || "Admin";
                
                // Log de sucesso
                console.log(`üìä X9: Autor detectado - ${autorName} (${autorAction.split('@')[0]}) fez ${action} em ${number}`);
            } else {
                console.log(`‚ö†Ô∏è X9: N√£o foi poss√≠vel detectar autor para ${action} de ${number} no grupo ${groupId.split('@')[0]}`);
            }
            
            let mensagem = "";
            let emoji = "";
            let mentionedUsers = [participant];
            
            if (autorAction) {
                mentionedUsers.push(autorAction);
            }
            
            switch (action) {
                case "promote":
                    if (autorAction) {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\nüëë **PROMO√á√ÉO PARA ADMIN**\n\nüë§ @${number} foi promovido para administrador\nüë®‚Äçüíº **Por:** @${autorAction.split('@')[0]}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando a√ß√µes administrativas...`;
                    } else {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\nüëë **PROMO√á√ÉO PARA ADMIN**\n\nüë§ @${number} foi promovido para administrador\nüë®‚Äçüíº **Por:** ${autorName}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando a√ß√µes administrativas...`;
                    }
                    emoji = "üëë";
                    break;
                    
                case "demote":
                    if (autorAction) {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚¨áÔ∏è **REBAIXAMENTO DE ADMIN**\n\nüë§ @${number} foi rebaixado de administrador\nüë®‚Äçüíº **Por:** @${autorAction.split('@')[0]}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando a√ß√µes administrativas...`;
                    } else {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚¨áÔ∏è **REBAIXAMENTO DE ADMIN**\n\nüë§ @${number} foi rebaixado de administrador\nüë®‚Äçüíº **Por:** ${autorName}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando a√ß√µes administrativas...`;
                    }
                    emoji = "‚¨áÔ∏è";
                    break;
                    
                case "add":
                    if (autorAction) {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚ûï **MEMBRO ADICIONADO**\n\nüë§ @${number} foi adicionado ao grupo\nüë®‚Äçüíº **Por:** @${autorAction.split('@')[0]}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando entrada de membros...`;
                    } else {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚ûï **MEMBRO ADICIONADO**\n\nüë§ @${number} foi adicionado ao grupo\nüë®‚Äçüíº **Por:** ${autorName}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando entrada de membros...`;
                    }
                    emoji = "‚ûï";
                    break;
                    
                case "remove":
                    if (autorAction) {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚ûñ **MEMBRO REMOVIDO**\n\nüë§ @${number} foi removido do grupo\nüë®‚Äçüíº **Por:** @${autorAction.split('@')[0]}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando sa√≠da de membros...`;
                    } else {
                        mensagem = `üìä *X9 MONITOR DETECTOU*\n\n‚ûñ **MEMBRO REMOVIDO**\n\nüë§ @${number} foi removido do grupo\nüë®‚Äçüíº **Por:** ${autorName}\nüì± Nome: ${name}\n‚è∞ Hor√°rio: ${new Date().toLocaleString('pt-BR')}\n\nüîç Monitorando sa√≠da de membros...`;
                    }
                    emoji = "‚ûñ";
                    break;
            }
            
            if (mensagem) {
                // Envia notifica√ß√£o do X9 Monitor
                await sock.sendMessage(groupId, {
                    text: mensagem,
                    contextInfo: {
                        mentionedJid: mentionedUsers,
                        forwardingScore: 100000,
                        isForwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363289739581116@newsletter",
                            newsletterName: "üìä‚Éù ùÜÖ‡øô‚µø◊ÇùÜÜùù¢ùù£ùù£ùù¨ùó´ìãåùüø ùó†ùó¢ùó°ùóúùóßùó¢ùó•‚¶ô‚¶ôÍú£‡æÄ"
                        },
                        externalAdReply: {
                            title: "¬© NEEXT LTDA - X9 Monitor",
                            body: `${emoji} A√ß√£o detectada no grupo`,
                            thumbnailUrl: "https://i.ibb.co/nqgG6z6w/IMG-20250720-WA0041-2.jpg",
                            mediaType: 1,
                            sourceUrl: "www.neext.online"
                        }
                    }
                });
                
                console.log(`üìä X9 MONITOR: ${action} detectado para ${number} no grupo ${groupId} ${autorAction ? 'por ' + autorAction.split('@')[0] : ''}`);
            }
            
            // Limpa o cache ap√≥s usar
            x9ActionCache.delete(cacheKey);
        }
        
    } catch (err) {
        console.error("‚ùå Erro no X9 Monitor:", err);
    }
}

// Fun√ß√£o para registrar atividade de admin (para melhor detec√ß√£o de autor)
async function registrarAtividadeAdmin(sock, message, from) {
    try {
        const config = antiSpam.carregarConfigGrupo(from);
        if (!config || !config.x9) return; // X9 n√£o est√° ativo
        
        // S√≥ funciona em grupos
        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return;
        
        const sender = message.key.participant || from;
        
        // Verifica se quem mandou a mensagem √© admin
        const ehAdmin = await isAdmin(sock, from, sender);
        if (ehAdmin) {
            // Registra a √∫ltima atividade do admin neste grupo
            adminActivityCache.set(from, {
                admin: sender,
                timestamp: Date.now()
            });
            
            // Auto-limpa ap√≥s 2 minutos
            setTimeout(() => {
                const current = adminActivityCache.get(from);
                if (current && current.admin === sender && current.timestamp <= Date.now() - 120000) {
                    adminActivityCache.delete(from);
                }
            }, 120000);
        }
        
    } catch (err) {
        console.error("‚ùå Erro ao registrar atividade admin:", err);
    }
}

// Fun√ß√£o para detectar quem fez a√ß√µes administrativas atrav√©s de mensagens do sistema
async function detectarAutorAcaoX9(sock, message, from) {
    try {
        const config = antiSpam.carregarConfigGrupo(from);
        if (!config || !config.x9) return; // X9 n√£o est√° ativo
        
        // S√≥ funciona em grupos
        if (!from.endsWith('@g.us') && !from.endsWith('@lid')) return;
        
        const sender = message.key.participant || from;
        const texto = getMessageText(message.message);
        
        // Detecta mensagens de sistema do WhatsApp sobre mudan√ßas de admin
        if (texto.includes('foi promovido') || texto.includes('foi rebaixado') || 
            texto.includes('foi removido') || texto.includes('foi adicionado') ||
            texto.includes('agora √© admin') || texto.includes('n√£o √© mais admin') ||
            texto.includes('promoveu') || texto.includes('rebaixou') ||
            texto.includes('removeu') || texto.includes('adicionou')) {
            
            // Extrai o n√∫mero da pessoa que foi afetada
            const numeroAfetado = texto.match(/@(\d+)/)?.[1];
            if (numeroAfetado) {
                const participantAfetado = numeroAfetado + '@s.whatsapp.net';
                
                // Determina a a√ß√£o
                let action = '';
                if (texto.includes('agora √© admin') || texto.includes('foi promovido') || texto.includes('promoveu')) {
                    action = 'promote';
                } else if (texto.includes('n√£o √© mais admin') || texto.includes('foi rebaixado') || texto.includes('rebaixou')) {
                    action = 'demote';
                } else if (texto.includes('foi adicionado') || texto.includes('adicionou')) {
                    action = 'add';
                } else if (texto.includes('foi removido') || texto.includes('removeu')) {
                    action = 'remove';
                }
                
                if (action) {
                    // Armazena quem fez a a√ß√£o no cache
                    const cacheKey = `${from}_${action}_${participantAfetado}`;
                    x9ActionCache.set(cacheKey, {
                        author: sender,
                        timestamp: Date.now()
                    });
                    
                    console.log(`üìä X9: A√ß√£o ${action} de ${participantAfetado.split('@')[0]} por ${sender.split('@')[0]} armazenada no cache`);
                    
                    // Auto-limpa o cache ap√≥s 30 segundos
                    setTimeout(() => {
                        x9ActionCache.delete(cacheKey);
                    }, 30000);
                }
            }
        }
        
    } catch (err) {
        console.error("‚ùå Erro ao detectar autor da a√ß√£o X9:", err);
    }
}

// Listener de mensagens
function setupListeners(sock) {
    // Event listener para participantes do grupo (lista negra + X9 Monitor)
    sock.ev.on("group-participants.update", async (update) => {
        try {
            const { id: groupId, participants, action, author } = update;
            
            console.log(`üìä X9 Event - Grupo: ${groupId.split('@')[0]}, A√ß√£o: ${action}, Participantes: ${participants.map(p => p.split('@')[0]).join(', ')}, Autor: ${author ? author.split('@')[0] : 'n√£o detectado'}`);
            
            // Processamento da lista negra
            await processarListaNegra(sock, participants, groupId, action);
            
            // Monitoramento X9 de a√ß√µes administrativas com autor detectado
            await processarX9Monitor(sock, groupId, participants, action, author);
            
        } catch (err) {
            console.error("‚ùå Erro no event listener de participantes:", err);
        }
    });

    sock.ev.on("messages.upsert", async (msgUpdate) => {
    const messages = msgUpdate?.messages;
    if (!messages || !Array.isArray(messages)) return;

    for (const m of messages) {
        try {
            if (!m.message) continue;
            const messageId = `${m.key.remoteJid}-${m.key.id}`;
            if (processedMessages.has(messageId)) continue;
            processedMessages.add(messageId);

            const { normalized, quoted } = normalizeMessage(m);
            const text = getMessageText(normalized.message).trim();
            normalized.text = text;

            const from = normalized.key.remoteJid;

            // logger central
            const config = obterConfiguracoes();
            const isCmd = text.startsWith(config.prefix);
            logMensagem(normalized, text, isCmd);

            // üîπ Detectar a√ß√µes administrativas X9 (antes do anti-spam para capturar o autor)
            await detectarAutorAcaoX9(sock, normalized, from);
            
            // üîπ Registrar atividade de admin para X9 Monitor
            await registrarAtividadeAdmin(sock, normalized, from);

            // üîπ Verifica√ß√£o de ANTI-SPAM COMPLETO (antes de tudo)
            const violacaoDetectada = await processarAntiSpam(sock, normalized);
            if (violacaoDetectada) continue; // se detectou viola√ß√£o, n√£o processa mais nada

            // üîπ Processamento do jogo Akinator
            const akinatorProcessed = await processarRespostaAkinator(sock, text, from, normalized);
            if (akinatorProcessed) continue; // se processou resposta do Akinator, n√£o processa mais nada

            // üîπ Processamento de jogadas (Jogo da Velha, Forca, etc.)
            const jogadaProcessada = await processarJogadas(sock, text, from, normalized);
            if (jogadaProcessada) continue; // se processou jogada, n√£o processa mais nada

            // üîπ Palavras-chave sem prefixo
            const respondeu = await responderPalavrasChave(sock, text, from, normalized);
            if (respondeu) continue; // se respondeu, n√£o processa comandos

            // üîπ Comandos com prefixo
            if (isCmd) {
                const [cmd, ...args] = text.slice(config.prefix.length).trim().split(/ +/);
                const command = cmd.toLowerCase();

                // üîπ Verifica√ß√£o de registro (exceto para comando "rg")
                if (command !== "rg") {
                    const sender = normalized.key.participant || from;
                    const numeroUsuario = sender.split('@')[0];
                    
                    if (!registros.usuarioRegistrado(numeroUsuario)) {
                        await reagirMensagem(sock, normalized, "üö´");
                        await reply(sock, from, `üö´ *ACESSO NEGADO!*\n\n‚ùå Voc√™ n√£o est√° registrado no sistema!\n\nüìù Para se registrar, digite:\n\`\`\`${config.prefix}rg\`\`\`\n\n‚ö†Ô∏è Apenas usu√°rios registrados podem usar o bot!`, [sender]);
                        continue; // N√£o processa o comando se n√£o estiver registrado
                    }
                }

                try {
                    await handleCommand(sock, normalized, command, args, from, quoted);
                } catch (err) {
                    console.error(`‚ùå Erro no comando "${command}":`, err);
                    await reply(sock, from, "‚ùå Comando falhou. Tente novamente.");
                }
            }

            // üîπ /s sem prefixo (comando especial)
            else if (text.startsWith("/s")) {
                try {
                    // üîπ Verifica√ß√£o de registro para comando /s
                    const sender = normalized.key.participant || from;
                    const numeroUsuario = sender.split('@')[0];
                    
                    if (!registros.usuarioRegistrado(numeroUsuario)) {
                        await reagirMensagem(sock, normalized, "üö´");
                        await reply(sock, from, `üö´ *ACESSO NEGADO!*\n\n‚ùå Voc√™ n√£o est√° registrado no sistema!\n\nüìù Para se registrar, digite:\n\`\`\`${config.prefix}rg\`\`\`\n\n‚ö†Ô∏è Apenas usu√°rios registrados podem usar o bot!`, [sender]);
                        continue;
                    }

                    // Verifica se tem m√≠dia marcada ou na pr√≥pria mensagem
                    const quotedMsg = normalized.message.extendedTextMessage?.contextInfo?.quotedMessage;
                    const hasQuotedMedia = quotedMsg && (quotedMsg.imageMessage || quotedMsg.videoMessage);
                    const hasDirectMedia = normalized.message.imageMessage || normalized.message.videoMessage;

                    if (hasQuotedMedia || hasDirectMedia) {
                        await handleCommand(sock, normalized, "s", [], from, quoted);
                    } else {
                        await reagirMensagem(sock, normalized, "‚ùå");
                        await reply(sock, from, "‚ùå Para usar /s voc√™ precisa:\n‚Ä¢ Marcar uma imagem/v√≠deo e digitar /s\n‚Ä¢ Ou enviar uma imagem/v√≠deo com legenda /s");
                    }
                } catch (err) {
                    console.error("‚ùå Erro no comando /s:", err);
                    await reply(sock, from, "‚ùå Erro ao processar comando /s");
                }
            }

        } catch (err) {
            console.error(`‚ùå Erro ao processar ${m.key.id}:`, err);
            try { 
                await sock.sendMessage(m.key.remoteJid, { text: "‚ùå Erro interno. Tente novamente." }, { quoted: m }); 
            } catch (e) { 
                console.error("Falha ao enviar erro:", e); 
            }
        }
    }
});
    console.log("‚úÖ Listener de mensagens ATIVADO ‚Äî processando TUDO (inclusive fromMe).");
}

// Exporta para iniciar no arquivo principal de conex√£o
module.exports = { handleCommand, setupListeners };